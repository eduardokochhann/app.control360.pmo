{% extends 'base.html' %} {# Ou o seu template base principal #}

{% block title %}Quadro de Backlog - {{ current_project.name if current_project else 'Projeto' }} {% endblock %}

{% block head %}
{{ super() }}
{# CSS movido para extra_css para maior especificidade #}
{% endblock %}

{# --- Bloco para CSS Específico da Página --- #}
{% block extra_css %}
<style>
  /* --- Ajustes Gerais --- */
  .kanban-board-wrapper .card {
      /* Remover sombra dupla se o wrapper já tiver sombra */
      box-shadow: none; 
  }
  .kanban-board-wrapper .card-body {
      padding: 1rem 1.25rem; /* Leve ajuste no padding */
      background-color: #f8f9fc; /* Fundo muito leve para área do board */
  }
  .kanban-board {
      display: flex;
      gap: 1rem; /* Reduz um pouco o espaço entre colunas */
      overflow-x: auto;
      padding-bottom: 1rem;
      /* Tenta calcular altura para preencher espaço vertical */
      /* Ajuste o valor (318px) se necessário, baseado na altura dos elementos acima */
      height: calc(100vh - 318px);
      min-height: 400px; /* Garante altura mínima ainda */
      justify-content: center; /* Centraliza as colunas se houver espaço */
  }
  .kanban-column {
      flex: 1 1 300px; /* Permite crescer/encolher, base 300px */
      max-width: 380px; /* Limite máximo para não esticar demais */
      background-color: #f1f3f5; /* Fundo da coluna um pouco mais escuro que o board */
      border-radius: 0.375rem; /* Raio padrão Bootstrap */
      /* Sombra sutil padrão Bootstrap */
      /* box-shadow: var(--bs-box-shadow-sm); */ 
      box-shadow: none; /* Remover sombra da coluna, deixar só no card? Testar */
      border: 1px solid #dee2e6; /* Borda leve para definir a coluna */
      display: flex;
      flex-direction: column;
  }
  .kanban-column-header {
      padding: 0.75rem 1rem; /* Ajuste padding */
      background-color: #fff; /* Cabeçalho branco */
      border-bottom: 1px solid #dee2e6; /* Borda padrão */
      font-weight: 500; /* Peso da fonte ligeiramente menor */
      color: #495057; /* Cor do texto mais escura */
      border-top-left-radius: calc(0.375rem - 1px); /* Corresponde à coluna */
      border-top-right-radius: calc(0.375rem - 1px); /* Corresponde à coluna */
      position: sticky;
      top: 0;
      z-index: 10; /* Garante que fique sobre os cards */
      display: flex;
      justify-content: space-between;
      align-items: center;
  }
  /* Nome da Coluna */
  .kanban-column-header .column-title {
      font-size: 0.9rem;
  }
  /* Container para contadores */
  .kanban-column-header .column-meta {
       display: flex;
       align-items: center;
       gap: 0.5rem;
  }
  /* Contagem de Tarefas - Estilo Badge sutil */
  .kanban-column-header .task-count {
      font-size: 0.7rem;
      font-weight: 500;
      color: #6c757d; /* Cor muted */
      background-color: #e9ecef; /* Fundo bem claro */
      padding: 0.2rem 0.45rem;
      border-radius: 0.25rem;
      display: inline-flex; /* Para alinhar ícone */
      align-items: center;
      gap: 0.2rem;
  }
  .kanban-column-header .task-count i {
       font-size: 0.8em; /* Ícone pequeno */
  }
  /* Totais de Horas */
  .kanban-column-header .column-totals {
     font-size: 0.7rem;
     color: #6c757d; /* Muted */
     display: flex;
     align-items: center;
     gap: 0.4rem; /* Espaço entre estimadas/restantes */
  }
  .kanban-column-header .column-totals span[title] { /* Target spans com title */
      display: inline-flex;
      align-items: center;
      gap: 0.15rem;
  }
  .kanban-column-header .column-totals i {
      font-size: 0.85em;
      vertical-align: baseline; /* Melhor alinhamento vertical */
  }

  .kanban-tasks {
      padding: 0.5rem 0.5rem 0.75rem 0.5rem; /* Padding: cima | dir/esq | baixo */
      overflow-y: auto;
      flex-grow: 1;
      min-height: 150px; /* Garante espaço mínimo mesmo vazio */
      /* Adiciona um background sutil para diferenciar da coluna */
      /* background-color: #f8f9fa; */ /* Ou manter o da coluna? Testar */
      border-bottom-left-radius: 0.375rem;
      border-bottom-right-radius: 0.375rem;
  }
  .kanban-task-card {
      background-color: #ffffff;
      border: 1px solid #e1e4e8; /* Borda bem sutil */
      border-radius: 0.375rem; /* Raio padrão */
      padding: 0.6rem 0.8rem; /* Padding interno do card */
      margin: 0.5rem 0.2rem; /* Margem vertical e leve horizontal */
      cursor: grab;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); /* Sombra bem leve */
      border-top: 3px solid transparent; /* BORDA SUPERIOR para cor status (inicialmente transparente) */
      transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.15s ease-in-out;
  }
  .kanban-task-card:hover {
      box-shadow: 0 3px 6px rgba(0,0,0,0.08); /* Sombra hover sutilmente maior */
      border-color: #ced4da; /* Borda geral fica mais visível no hover */
      /* Mantém a borda superior colorida se existir */
      border-top-color: inherit; /* Ou recalcular a cor da coluna */
      transform: translateY(-1px); /* Leve elevação no hover */
  }
  .kanban-task-card .task-header {
       display: flex;
       justify-content: space-between;
       align-items: flex-start;
       margin-bottom: 0.3rem; /* Menos espaço após header */
  }

  .kanban-task-card .task-title {
      font-weight: 500; /* Menos bold */
      color: #343a40; /* Cor de texto principal */
      line-height: 1.35;
      font-size: 0.88rem; /* Tamanho título */
      flex-grow: 1;
      margin-right: 0.5rem;
      /* word-break: break-word; */ /* Evitar quebra feia */
  }
  .kanban-task-card .task-full-id {
      font-size: 0.65em; /* ID ainda menor */
      color: #adb5bd; /* ID bem claro */
      background-color: transparent; /* Sem fundo */
      padding: 0; /* Sem padding extra */
      border-radius: 0;
      align-self: flex-start;
      white-space: nowrap;
      flex-shrink: 0;
      margin-top: 0.1rem; /* Alinha um pouco melhor com o título */
  }

  .kanban-task-card .task-body {
      /* Agrupa prioridade e detalhes */
      margin-top: 0.5rem; /* Aumentado levemente o espaço antes do corpo */
      /* display: flex; */ /* <<< REMOVIDO: Não mais flex lado a lado */
      /* justify-content: space-between; */ /* <<< REMOVIDO */
      /* align-items: center; */ /* <<< REMOVIDO */
      /* flex-wrap: wrap; */ /* <<< REMOVIDO */
      /* gap: 0.5rem; */ /* <<< REMOVIDO */
      display: block; /* <<< ALTERADO: Elementos filhos em bloco */
  }

  /* Grupo Esquerdo: Badge de Prioridade e Ícone Descrição */
  .kanban-task-card .task-meta-left {
      display: flex;
      align-items: center;
      gap: 0.4rem; /* Espaço entre badge e ícone desc */
      margin-bottom: 0.4rem; /* <<< ADICIONADO: Espaço abaixo deste grupo */
  }

   /* Badge de Prioridade */
  .kanban-task-card .task-priority-badge {
      font-size: 0.7rem; /* Badge um pouco maior */
      font-weight: 600; /* Deixa o texto do badge mais forte */
      padding: 0.2em 0.5em; /* Mais padding */
      vertical-align: middle;
      display: inline-flex; /* Para alinhar o círculo interno */
      align-items: center;
      gap: 0.3em; /* Espaço entre círculo e texto */
      /* Cores definidas pelas classes text-bg-* */
  }

  /* Ícone de Descrição (se houver) */
  .kanban-task-card .task-desc-icon {
      color: #6c757d; /* Cor muted */
      font-size: 0.9rem; /* Tamanho do ícone */
      cursor: help; /* Indica que tem tooltip */
  }

  /* Grupo Direito: Detalhes de Tempo, Sprint, Especialista */
  .kanban-task-card .task-details {
      font-size: 0.7rem; /* Tamanho dos detalhes */
      color: #6c757d; /* Cor muted */
      display: flex; /* Ícones e texto na mesma linha AINDA ÚTIL para alinhar ícone/texto */
      align-items: center; /* Alinha itens verticalmente dentro do flex */
      /* gap: 0.5rem; */ /* <<< REMOVIDO: Gap principal entre grupos não necessário */
      /* white-space: nowrap; */ /* <<< REMOVIDO: Permite quebrar linha */
      flex-wrap: wrap; /* <<< ADICIONADO: Permite que itens quebrem linha */
      gap: 0.2rem 0.6rem; /* <<< ADICIONADO: Gap vertical pequeno, horizontal maior */
      margin-top: 0.2rem; /* <<< ADICIONADO: Pequeno espaço acima dos detalhes */
  }
  .kanban-task-card .task-details span[title] { /* Target spans com title */
       display: inline-flex;
       align-items: center;
       gap: 0.2rem; /* Espaço ícone-texto */
  }
  .kanban-task-card .task-details i {
      margin-right: 0; /* Removido, usando gap */
      vertical-align: text-bottom;
      font-size: 0.9em;
  }

  /* Estilo específico para data de conclusão */
  .task-completion-date {
      color: var(--bs-success); /* Verde sucesso */
      font-weight: 500; /* Leve destaque */
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
  }

  /* --- Cores da Borda Superior por Coluna --- */
  .kanban-task-card.task-col-afazer { border-top-color: var(--bs-primary, #0d6efd); }
  .kanban-task-card.task-col-andamento { border-top-color: var(--bs-orange, #fd7e14); }
  .kanban-task-card.task-col-revisao { border-top-color: var(--bs-purple, #6f42c1); }
  .kanban-task-card.task-col-concluido { border-top-color: var(--bs-success, #198754); }
  .kanban-task-card.task-col-bloqueado { border-top-color: var(--bs-danger, #dc3545); } /* Exemplo: Se tiver bloqueado */
  /* Default/Outro: Cinza sutil ou transparente (já definido) */
  .kanban-task-card.task-col-default { border-top-color: var(--bs-secondary, #6c757d); }


  /* --- Indicador de Prioridade (usando badge, remove anterior) --- */
  /* .kanban-task-card .priority-indicator { display: none; } */
  /* .priority-indicator.prio-urgente { ... } etc - Removido, usamos text-bg-* no badge */
  /* --------------------------------------------------------------- */

  /* Estilo para arrastar (SortableJS) */
  .sortable-ghost {
      opacity: 0.5;
      background-color: #cfe2ff; /* Azul claro */
      border: 1px dashed #0d6efd;
  }
  .sortable-chosen {
      cursor: grabbing;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
      transform: scale(1.02); /* Leve aumento ao pegar */
  }
  /* Mensagem quando coluna vazia */
  .no-tasks {
      text-align: center;
      color: #6c757d;
      padding: 1.5rem 1rem; /* Mais padding vertical */
      font-style: italic;
      font-size: 0.8rem;
  }
  /* Estilos para o modal (mantendo consistência) */
  #addTaskModal .modal-dialog {
      max-width: 750px; /* Aumenta um pouco a largura */
      margin-top: 3rem; /* Mais margem no topo */
  }
  #addTaskModal .modal-content {
      border: none; /* Remove borda padrão */
      border-radius: 0.375rem; /* Raio padrão Bootstrap */
      box-shadow: 0 0.5rem 1.5rem rgba(0, 0, 0, 0.15); /* Sombra mais pronunciada */
  }
  #addTaskModal .modal-header {
      background-color: #343a40; /* FUNDO ESCURO */
      color: #fff; /* Texto claro */
      border-bottom: none; /* Sem borda inferior */
      padding: 1rem 1.5rem; /* Mais padding */
      align-items: center; /* Alinha título e botão fechar */
      border-top-left-radius: calc(0.375rem - 1px); /* Ajusta raio */
      border-top-right-radius: calc(0.375rem - 1px);
  }
  #addTaskModal .modal-title {
      font-size: 1.15rem; /* Título maior */
      font-weight: 600; /* Mais peso */
      color: #fff; /* Cor do título clara */
      display: inline-flex; /* Para alinhar ícone */
      align-items: center;
      gap: 0.5rem; /* Espaço entre ícone e texto */
  }
  #addTaskModal .btn-close {
      padding: 0.5rem;
      margin: -0.5rem -0.5rem -0.5rem auto; /* Ajusta posição */
      filter: invert(1) grayscale(100%) brightness(200%); /* Deixa o X branco */
  }
  #addTaskModal .modal-body {
       padding: 1.5rem 1.5rem 0.5rem 1.5rem; /* Ajusta padding (menos embaixo antes do footer) */
  }
  #addTaskModal .modal-body .row {
       margin-bottom: 1.25rem; /* Aumenta espaço entre linhas */
  }
  /* Linha divisória sutil */
  #addTaskModal .modal-body hr {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      border-color: #e9ecef; /* Cor bem clara */
  }
  /* Ajuste nos labels e inputs do modal para consistência */
  #addTaskModal .form-label {
      font-size: 0.78rem; /* Tamanho label */
      font-weight: 500; /* Leve bold */
      color: #495057; /* Cor label */
      margin-bottom: 0.3rem;
  }
  #addTaskModal .form-control-sm, #addTaskModal .form-select-sm {
      font-size: 0.9rem; /* Tamanho do texto interno */
      padding: 0.45rem 0.8rem; /* Padding interno levemente ajustado */
      border: 1px solid #ced4da; /* Borda padrão */
      border-radius: 0.25rem; /* Cantos levemente arredondados */
      background-color: #fff !important; /* Garante fundo branco */
  }
  #addTaskModal .form-control-sm:focus, #addTaskModal .form-select-sm:focus {
      border-color: #86b7fe; /* Cor de foco padrão Bootstrap */
      box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25); /* Sombra de foco padrão Bootstrap */
      background-color: #fff !important;
  }
  #addTaskModal textarea.form-control-sm {
      min-height: 80px; /* Altura mínima para descrição */
  }
  #addTaskModal .modal-footer {
      background-color: #343a40; /* FUNDO ESCURO */
      color: #fff; /* Texto claro padrão */
      border-top: none; /* Sem borda superior */
      padding: 1rem 1.5rem; /* Padding */
      display: flex; /* Habilita flexbox */
      justify-content: space-between; /* Separa botão excluir dos outros */
      border-bottom-left-radius: calc(0.375rem - 1px);
      border-bottom-right-radius: calc(0.375rem - 1px);
  }

  /* Estilo dos botões no Footer */
  #addTaskModal .modal-footer .btn {
      padding: 0.5rem 1rem; /* Padding botões */
      font-size: 0.9rem;
      font-weight: 500;
      border-radius: 0.25rem;
      /* Transição suave */
      transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out;
  }
  /* Botão Excluir específico */
  #addTaskModal #deleteTaskBtn {
      /* Já tem btn-danger, sem mudanças extras por enquanto */
  }
  #addTaskModal #deleteTaskBtn:hover {
      /* background-color: var(--bs-danger);
      color: #fff; */
  }
  /* Grupo Cancelar/Salvar */
  #addTaskModal .modal-footer div:last-child { /* Target a div que agrupa Cancelar/Salvar */
      display: flex;
      gap: 0.5rem; /* Espaço entre Cancelar e Salvar */
  }

  /* Estilos para loading (mantidos) */
  .loading-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(255, 255, 255, 0.8); /* Fundo um pouco mais opaco */
      display: flex; justify-content: center; align-items: center;
      z-index: 1056; /* Acima do conteúdo do modal */
      border-radius: inherit; /* Herda raio do modal-content */
  }

  /* Ajuste na área de detalhes do projeto no topo */
  #projectDetailsHeader {
      font-size: 0.85rem; /* Tamanho da fonte para detalhes do projeto */
      gap: 0.5rem 1.5rem; /* Gap vertical e horizontal */
  }
   #projectDetailsHeader .col-md-auto {
      padding-left: 0; /* Remove padding padrão do col */
      padding-right: 0;
   }
  #projectDetailsHeader small {
      font-size: 0.7rem; /* Label menor */
      color: #6c757d; /* Muted */
      text-transform: uppercase;
      display: block;
      margin-bottom: 0.1rem;
  }
  #projectDetailsHeader span.fw-bold {
      font-weight: 500 !important; /* Menos bold */
      color: #343a40;
  }

</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    {# Card Principal Envolvendo Tudo - REMOVIDO shadow mb-4 daqui, colocado no wrapper interno #}
    <div class="card kanban-board-wrapper shadow-sm mb-4"> 
        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between bg-light border-bottom"> {# Cabeçalho do card principal mais leve #}
            <div class="d-flex align-items-center"> {# Agrupa botão Voltar e Título #}
                <a href="{{ url_for('backlog.project_selection') }}" class="btn btn-sm btn-outline-secondary me-3" title="Voltar para Seleção de Projetos">
                    <i class="bi bi-arrow-left"></i>
                    <span class="d-none d-sm-inline"> Projetos</span> {# Texto opcional em telas maiores #}
                </a>
                <h6 class="m-0 font-weight-bold text-primary">
                    <i class="bi bi-kanban me-1"></i> {# Ícone Kanban #}
                    Quadro: {{ current_project.name if current_project else 'Projeto Inválido' }} (#{{ current_project.id if current_project else '-' }})
                </h6>
            </div>
            {# --- BOTÃO ADICIONAR TAREFA DIRETAMENTE --- #}
            <button class="btn btn-sm btn-primary" id="addTaskBtn" {% if not current_backlog_id %}disabled{% endif %}>
                <i class="bi bi-plus-lg me-1"></i>Nova Tarefa
            </button>
        </div>
        <div class="card-body"> {# Padding já ajustado no CSS #}
            {# --- ÁREA PARA DETALHES DO PROJETO (CARREGADOS PELA ROTA) --- #}
            <div id="projectDetailsHeader" class="row border-bottom pb-2 mb-3 align-items-center"> {# Menos padding bottom e margin bottom #}
                <div class="col-md-auto">
                    <small class="text-muted d-block">Status</small>
                    <span id="projectStatus" class="fw-bold">{{ current_project.status if current_project else '-' }}</span>
                </div>
                <div class="col-md-auto">
                    <small class="text-muted d-block">Squad</small>
                    <span id="projectSquad" class="fw-bold">{{ current_project.squad if current_project else '-' }}</span>
                </div>
                <div class="col-md-auto">
                    <small class="text-muted d-block">Especialista</small>
                    <span id="projectSpecialist" class="fw-bold">{{ current_project.specialist if current_project else '-' }}</span>
                </div>
                {# Horas movidas para o final e agrupadas #}
                <div class="col-md-auto ms-md-auto d-flex gap-3"> {# Agrupa horas #}
                    <div>
                        <small class="text-muted d-block">Estimadas</small>
                        <span id="projectOverallEstimatedHours" class="fw-bold">{{ "%.1f"|format(current_project.estimated_hours) if current_project and current_project.estimated_hours is not none else '-' }}</span>h
                    </div>
                    <div>
                        <small class="text-muted d-block">Trabalhadas</small>
                        <span id="projectOverallLoggedHours" class="fw-bold">{{ "%.1f"|format(current_project.logged_hours) if current_project and current_project.logged_hours is not none else '-' }}</span>h
                    </div>
                    <div>
                        <small class="text-muted d-block">Restantes</small>
                        <span id="projectOverallRemainingHours" class="fw-bold">{{ "%.1f"|format(current_project.remaining_hours) if current_project and current_project.remaining_hours is not none else '-' }}</span>h
                    </div>
                     <div>
                        <small class="text-muted d-block">Kanban (Rest.)</small>
                        <span id="kanbanTotalRemainingHours" class="fw-bold">-</span>h
                    </div>
                </div>
            </div>

            {# Guarda o ID do backlog atual (se existir) e o ID do projeto atual #}
            <input type="hidden" id="currentBacklogId" value="{{ current_backlog_id if current_backlog_id else '' }}">
            <input type="hidden" id="currentProjectId" value="{{ current_project.id if current_project else '' }}">

            {# Mensagem de Status #}
            <div id="boardStatus" class="alert d-flex align-items-center mb-3" role="alert" style="display: none;">
              <i class="bi flex-shrink-0 me-2"></i>
              <div>{# Mensagem será definida pelo JS #}</div>
            </div>

            {# Placeholder para o botão Criar Backlog, se necessário #}
            <div id="createBacklogPlaceholder" class="mb-3"></div>

            {# Define estado inicial se não houver backlog #}
            {% if not current_backlog_id %}
            <script>
                // Certifique-se que as funções showBoardStatus e addCreateBacklogListener estão definidas
                // no script principal ou mova a definição delas para cá se necessário.
                document.addEventListener('DOMContentLoaded', function() {
                    if (typeof showBoardStatus === 'function') {
                        showBoardStatus('Nenhum backlog encontrado para este projeto.', 'warning', false);
                    } else {
                        console.error('showBoardStatus não definida no momento da chamada inicial.');
                    }
                    const placeholder = document.getElementById('createBacklogPlaceholder');
                    if (placeholder && typeof addCreateBacklogListener === 'function'){
                        const createBtn = document.createElement('button');
                        createBtn.id = 'createBacklogBtn';
                        createBtn.className = 'btn btn-sm btn-outline-secondary';
                        createBtn.innerHTML = '<i class="bi bi-plus-lg me-1"></i>Criar Backlog';
                        placeholder.appendChild(createBtn);
                        addCreateBacklogListener(createBtn);
                    } else {
                        console.error('Placeholder ou addCreateBacklogListener não encontrados/definidos.');
                    }
                });
            </script>
            {% endif %}

            {# Quadro Kanban #}
            <div class="kanban-board" id="kanbanBoard">
                {% for column in columns %}
                <div class="kanban-column" data-column-id="{{ column.id }}">
                    <div class="kanban-column-header">
                        <span class="column-title">{{ column.name }}</span>
                        {# NOVO: Container para contagem e totais #}
                        <div class="column-meta">
                            <span class="task-count" title="Número de Tarefas">
                                <i class="bi bi-list-task"></i> {# Ícone diferente #}
                                <span class="count-value">0</span>
                            </span>
                            <span class="column-totals text-muted small">
                                <span title="Total Horas Estimadas"><i class="bi bi-clock-history"></i> <span class="total-estimated">0</span>h</span>
                                {# <span class="mx-1">|</span> Separador removido, usando gap CSS #}
                                <span title="Total Horas Restantes"><i class="bi bi-hourglass-split"></i> <span class="total-remaining">0</span>h</span>
                            </span>
                        </div>
                    </div>
                    <div class="kanban-tasks sortable-list" data-column-id="{{ column.id }}">
                         <div class="no-tasks">Carregando...</div> {# Mensagem ajustada no CSS #}
                    </div>
                </div>
                {% endfor %}
            </div>
            
            <!-- *** SEÇÃO DE MARCOS DO PROJETO (POSIÇÃO CORRETA) *** -->
            <div class="row mt-4"> {# Mantendo mt-4 para um espaçamento consistente #}
                <div class="col-12">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-flag-fill me-1"></i> Marcos do Projeto
                            </h6>
                            {# Botão para adicionar novo marco #}
                            <div>
                                <button class="btn btn-sm btn-outline-primary" id="addMilestoneBtn">
                                    <i class="bi bi-plus-lg"></i> Novo Marco
                                </button>
                                <button class="btn btn-sm btn-outline-secondary ms-2" id="reloadMilestonesBtn" title="Recarregar Marcos">
                                    <i class="bi bi-arrow-clockwise"></i> Recarregar
                                </button>
                            </div>
                        </div>
                        <div class="card-body" style="max-height: 350px; overflow-y: auto;">
                            <div class="table-responsive">
                                <table class="table table-sm table-hover" id="milestonesTable">
                                    <thead>
                                        <tr>
                                            <th scope="col">Marco</th>
                                            <th scope="col">Data Planejada</th>
                                            <th scope="col">Data Real</th>
                                            <th scope="col">Status</th>
                                            <th scope="col">Criticidade</th>
                                            <th scope="col">Ações</th>
                                        </tr>
                                    </thead>
                                    <tbody id="milestonesTableBody"> {# Adicionado ID ao tbody #}
                                        <tr>
                                            <td colspan="6" class="text-center text-muted small">
                                                <i class="bi bi-hourglass me-1"></i> Carregando marcos...
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- *** FIM SEÇÃO DE MARCOS DO PROJETO *** -->

            <!-- Seções Linha do Tempo e Riscos (POSIÇÃO CORRETA - APÓS MARCOS) -->
            <div class="row mt-4">
                <!-- Seção de Linha do Tempo (Tarefas) -->
                <div class="col-md-6">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-calendar-range me-1"></i> Linha do Tempo (Tarefas)
                            </h6>
                        </div>
                        <div class="card-body" style="max-height: 350px; overflow-y: auto;">
                            <div id="timelineContainer">
                                <div class="timeline-section mb-3">
                                    <h6 class="text-muted"><i class="bi bi-check-circle-fill text-success me-2"></i>Recentemente Concluídas</h6>
                                    <ul class="list-group list-group-flush" id="completedTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                                <div class="timeline-section mb-3">
                                    <h6 class="text-muted"><i class="bi bi-alarm-fill text-warning me-2"></i>Próximas Tarefas (7 dias)</h6>
                                    <ul class="list-group list-group-flush" id="upcomingTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                                <div class="timeline-section">
                                    <h6 class="text-muted"><i class="bi bi-play-circle-fill text-primary me-2"></i>Iniciadas Recentemente</h6>
                                    <ul class="list-group list-group-flush" id="startedTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Seção de Riscos e Impedimentos -->
                <div class="col-md-6">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-exclamation-triangle-fill me-1"></i> Riscos e Impedimentos
                            </h6>
                            <button class="btn btn-sm btn-outline-primary" id="addRiskBtn">
                                <i class="bi bi-plus-lg"></i> Novo Risco
                            </button>
                        </div>
                        <div class="card-body" style="max-height: 350px; overflow-y: auto;">
                            <div class="table-responsive">
                                <table class="table table-sm table-hover" id="risksTable">
                                    <thead>
                                        <tr>
                                            <th scope="col">Descrição</th>
                                            <th scope="col">Severidade</th>
                                            <th scope="col">Status</th>
                                            <th scope="col">Ações</th> {# Coluna Ações #}
                                        </tr>
                                    </thead>
                                    <tbody id="risksTableBody"> {# Adicionado ID para tbody #}
                                        <tr>
                                            <td colspan="4" class="text-center text-muted">
                                                <i class="bi bi-hourglass me-1"></i> Carregando riscos...
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- *** FIM DAS SEÇÕES LINHA DO TEMPO E RISCOS *** -->
        </div> {# Fim card-body #}
    </div> {# Fim card #}
</div> {# Fim container-fluid #}

{# Modal Adicionar/Editar Tarefa (estrutura mantida) #}
<div class="modal fade" id="addTaskModal" tabindex="-1" aria-labelledby="addTaskModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="addTaskForm">
        <div class="modal-header">
          <h5 class="modal-title" id="addTaskModalLabel">Adicionar Nova Tarefa</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="taskId" name="taskId">
          
          {# Seção 1: Nome e Descrição #}
          <div class="row">
            <div class="col-12">
              <label for="taskName" class="form-label">Nome da Tarefa <span class="text-danger">*</span></label>
              <input type="text" class="form-control form-control-sm" id="taskName" name="name" required>
            </div>
          </div>
          <div class="row">
            <div class="col-12">
              <label for="taskDescription" class="form-label">Descrição</label>
              <textarea class="form-control form-control-sm" id="taskDescription" name="description" rows="3"></textarea>
            </div>
          </div>

          <hr> {# Divisor #}

          {# Seção 2: Prioridade e Status #}
          <div class="row">
            <div class="col-md-6">
                <label for="taskPriority" class="form-label">Prioridade</label>
                <select class="form-select form-select-sm" id="taskPriority" name="priority">
                    <option value="Baixa">Baixa</option>
                    <option value="Média" selected>Média</option>
                    <option value="Alta">Alta</option>
                    <option value="Urgente">Urgente</option>
                </select>
            </div>
             <!-- <div class="col-md-6">
                 {# Espaço reservado para Status - Exemplo:
                 <label for="taskStatusColumn" class="form-label">Status (Coluna)</label>
                 <select class="form-select form-select-sm" id="taskStatusColumn" name="column_id" disabled title="O status é definido ao mover o card no quadro.">
                     {# Opções seriam carregadas dinamicamente ou estáticas #}
                 </select>
                 #}
             </div> -->
          </div>

          <hr> {# Divisor #}

          {# Linha 3: Horas Estimadas e Restantes #}
          <div class="row">
             <div class="col-md-6">
              <label for="taskEstimatedHours" class="form-label">Horas Estimadas</label>
              <input type="number" step="0.1" min="0" class="form-control form-control-sm" id="taskEstimatedHours" name="estimated_hours" placeholder="ex: 8.0">
            </div>
            <div class="col-md-6" id="remainingHoursGroup">
                <label for="taskRemainingHours" class="form-label">Horas Restantes</label>
                <input type="number" step="0.1" min="0" class="form-control form-control-sm" id="taskRemainingHours" name="remaining_hours" placeholder="Igual Estimadas" title="Pode ser recalculado. Deixe em branco para usar Estimadas.">
            </div>
           </div>

           {# Seção 4: Datas Início e Fim #}
           <div class="row">
            <div class="col-md-6">
              <label for="taskStartDate" class="form-label">Data Início</label>
              <input type="date" class="form-control form-control-sm" id="taskStartDate" name="start_date">
            </div>
            <div class="col-md-6">
              <label for="taskDueDate" class="form-label">Data Fim (Prazo)</label>
              <input type="date" class="form-control form-control-sm" id="taskDueDate" name="due_date">
            </div>
           </div>

           {# <<< INÍCIO: Campo Especialista >>> #}
           <hr> {# Divisor #}
           <div class="row">
                <div class="col-md-6">
                     <label for="taskSpecialist" class="form-label">Especialista</label>
                     {# <<< INÍCIO: Substituir input por select >>> #}
                     <select class="form-select form-select-sm" id="taskSpecialist" name="specialist_name" title="Selecione o especialista ou deixe em branco para usar o padrão do projeto.">
                        <option value="" selected>-- Padrão do Projeto --</option>
                        {# Opções serão carregadas pelo JavaScript #}
                     </select>
                     {# <<< FIM: Substituir input por select >>> #}
                     {# TODO: Transformar em <select> futuramente? #}
                </div>
           </div>
           {# <<< FIM: Campo Especialista >>> #}
        </div>
        <div class="modal-footer justify-content-between">
            {# Botão Excluir (visível apenas na edição) #}
            <button type="button" class="btn btn-danger" id="deleteTaskBtn" style="display: none;">Excluir Tarefa</button>
            <div>
                 {# Botão Cancelar #}
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                 {# Botão Salvar/Criar #}
                <button type="submit" class="btn btn-primary">Salvar Tarefa</button>
            </div>
        </div>
        {# Loading Feedback #}
        <div class="loading-overlay" style="display: none;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- *** NOVO MODAL PARA MARCOS DO PROJETO *** -->
<div class="modal fade" id="milestoneModal" tabindex="-1" aria-labelledby="milestoneModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg"> {# Modal um pouco maior #}
        <div class="modal-content">
            <form id="milestoneForm">
                <div class="modal-header bg-primary text-white"> {# Header com cor #}
                    <h5 class="modal-title" id="milestoneModalLabel">
                        <i class="bi bi-flag-fill me-2"></i> <span id="milestoneModalTitle">Adicionar Marco</span>
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="milestoneId" name="milestoneId">
                    
                    {# Linha 1: Nome #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <label for="milestoneName" class="form-label">Nome do Marco <span class="text-danger">*</span></label>
                            <input type="text" class="form-control form-control-sm" id="milestoneName" name="name" required>
                        </div>
                    </div>
                    
                    {# Linha 2: Descrição #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <label for="milestoneDescription" class="form-label">Descrição</label>
                            <textarea class="form-control form-control-sm" id="milestoneDescription" name="description" rows="3"></textarea>
                        </div>
                    </div>
                    
                    {# Linha 3: Datas #}
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="milestonePlannedDate" class="form-label">Data Planejada <span class="text-danger">*</span></label>
                            <input type="date" class="form-control form-control-sm" id="milestonePlannedDate" name="planned_date" required>
                        </div>
                        <div class="col-md-6">
                            <label for="milestoneActualDate" class="form-label">Data Real</label>
                            <input type="date" class="form-control form-control-sm" id="milestoneActualDate" name="actual_date">
                        </div>
                    </div>
                    
                    {# Linha 4: Status e Criticidade #}
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="milestoneStatus" class="form-label">Status</label>
                            <select class="form-select form-select-sm" id="milestoneStatus" name="status">
                                <option value="Pendente" selected>Pendente</option>
                                <option value="Em Andamento">Em Andamento</option>
                                <option value="Concluído">Concluído</option>
                                <option value="Atrasado">Atrasado</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="milestoneCriticality" class="form-label">Criticidade</label>
                            <select class="form-select form-select-sm" id="milestoneCriticality" name="criticality">
                                <option value="Baixa">Baixa</option>
                                <option value="Média" selected>Média</option>
                                <option value="Alta">Alta</option>
                                <option value="Crítica">Crítica</option>
                            </select>
                        </div>
                    </div>
                    
                    {# Linha 5: Checkpoint #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="milestoneIsCheckpoint" name="is_checkpoint">
                                <label class="form-check-label" for="milestoneIsCheckpoint">
                                    É um marco crítico (checkpoint)?
                                </label>
                            </div>
                        </div>
                    </div>
                    
                </div> {# Fim modal-body #}
                <div class="modal-footer justify-content-between">
                    {# Botão Excluir (visível apenas na edição) #}
                    <button type="button" class="btn btn-danger btn-sm" id="deleteMilestoneBtn" style="display: none;">
                        <i class="bi bi-trash me-1"></i> Excluir
                    </button>
                    {# Grupo Cancelar/Salvar #}
                    <div>
                        <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-primary btn-sm" id="saveMilestoneBtn">
                            <i class="bi bi-check-lg me-1"></i> Salvar Marco
                        </button>
                    </div>
                </div>
                {# Loading Feedback #}
                <div class="loading-overlay" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Carregando...</span>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>
<!-- *** FIM NOVO MODAL PARA MARCOS *** -->

<!-- Modal para Adicionar/Editar Risco do Projeto -->
<div class="modal fade" id="riskModal" tabindex="-1" aria-labelledby="riskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="riskForm"> <!-- ADICIONADO ID AQUI -->
                <div class="modal-header">
                    <h5 class="modal-title" id="riskModalLabel">Adicionar Risco</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="riskDescription" class="form-label">Descrição do Risco</label>
                        <textarea class="form-control" id="riskDescription" rows="3"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="riskSeverity" class="form-label">Severidade</label>
                        <input type="number" class="form-control" id="riskSeverity" min="1" max="10" placeholder="1-10">
                    </div>
                    <div class="mb-3">
                        <label for="riskStatus" class="form-label">Status</label>
                        <select class="form-select" id="riskStatus">
                            <option value="Ativo" selected>Ativo</option>
                            <option value="Mitigado">Mitigado</option>
                            <option value="Resolvido">Resolvido</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="submit" class="btn btn-primary">Salvar Risco</button>
                </div>
            </form>
        </div>
    </div>
</div>

{# Script dedicado para armazenar os dados JSON das tarefas iniciais #}
<script id="initial-tasks-data" type="application/json">
{{ tasks_json|safe if tasks_json else '[]' }}
</script>

{# SortableJS (link mantido, mas JS removido) #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

{# JavaScript Específico da Página #}
<script>
  // Obtém IDs do Flask
  const initialBacklogId = document.getElementById('currentBacklogId')?.value || '';
  const initialProjectId = document.getElementById('currentProjectId')?.value || '';
  const projectNameForLogs = "{{ current_project.name if current_project else 'Projeto Desconhecido' }}";

  // Elementos do DOM para Marcos (definindo globalmente no topo)
  const addMilestoneBtn = document.getElementById('addMilestoneBtn');
  const milestonesTableBody = document.getElementById('milestonesTableBody');
  const milestoneModalElement = document.getElementById('milestoneModal');
  const milestoneModal = milestoneModalElement ? new bootstrap.Modal(milestoneModalElement) : null;
  const milestoneForm = document.getElementById('milestoneForm');
  const milestoneModalTitle = document.getElementById('milestoneModalTitle');
  const milestoneIdInput = document.getElementById('milestoneId');
  const deleteMilestoneBtn = document.getElementById('deleteMilestoneBtn');
  const saveMilestoneBtn = document.getElementById('saveMilestoneBtn');

  // Verifica se os elementos essenciais existem
  if (!milestonesTableBody) {
      console.error("[CRITICAL] Elemento #milestonesTableBody não encontrado no DOM. Marcos não poderão ser exibidos.");
  } else {
      console.log("[Init] Elemento #milestonesTableBody encontrado com sucesso.");
  }

  // Lê e parseia as tarefas iniciais do script JSON dedicado
  let initialTasks = []; // Default para array vazio
  try {
      const tasksDataElement = document.getElementById('initial-tasks-data');
      if (tasksDataElement) {
          initialTasks = JSON.parse(tasksDataElement.textContent || '[]');
      } else {
          console.warn("Elemento #initial-tasks-data não encontrado. Usando array vazio para tarefas.");
      }
  } catch (error) {
      console.error("Erro ao parsear JSON das tarefas iniciais:", error, "Conteúdo:", document.getElementById('initial-tasks-data')?.textContent);
      // Mantém initialTasks como [] em caso de erro
      showBoardStatus("Erro ao carregar dados das tarefas iniciais. Verifique o console.", "danger");
  }

  // Define funções aqui fora se necessário para o script do 'if not current_backlog_id'
  function showBoardStatus(message, type = 'info', showBoard = false) {
      const boardStatus = document.getElementById('boardStatus');
      const kanbanBoard = document.getElementById('kanbanBoard');
      if (!boardStatus) { console.error("Elemento #boardStatus não encontrado."); return; }
      const boardStatusDiv = boardStatus.querySelector('div');
      const boardStatusIcon = boardStatus.querySelector('i');
      if (!boardStatusDiv || !boardStatusIcon) { console.error("Elementos internos de #boardStatus não encontrados."); return; }

      console.log(`[Status Update] Type: ${type}, Message: ${message}, ShowBoard: ${showBoard}`);
      boardStatusDiv.textContent = message;
      let iconClass = 'bi-info-circle-fill';
      if (type === 'warning') iconClass = 'bi-exclamation-triangle-fill';
      else if (type === 'danger') iconClass = 'bi-x-octagon-fill';
      else if (type === 'success') iconClass = 'bi-check-circle-fill';
      boardStatusIcon.className = `bi ${iconClass} flex-shrink-0 me-2`;
      boardStatus.className = `alert alert-${type} d-flex align-items-center mb-3`;
      boardStatus.innerHTML = `
        <i class="bi ${iconClass} flex-shrink-0 me-2"></i>
        <div>${message}</div>
      `;
      boardStatus.style.display = 'flex';
      if (kanbanBoard) {
           kanbanBoard.style.display = showBoard ? 'flex' : 'none';
      } else { console.error('#kanbanBoard não encontrado ao tentar definir display em showBoardStatus'); }
  }

  function addCreateBacklogListener(buttonElement) {
       if (!buttonElement) return;
       buttonElement.addEventListener('click', async function() {
          if (!initialProjectId) {
              alert("Erro crítico: ID do projeto atual não definido.");
              return;
          }
          console.log(`[Create Backlog Button] Clicado para Projeto ID: ${initialProjectId}`);
          this.disabled = true; this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Criando...';
          try {
              const response = await fetch(`/backlog/api/projects/${initialProjectId}/backlog`, {
                  method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({})
              });
              console.log(`[Create Backlog Button] Resposta API (${response.status}):`, response);
              if (!response.ok) {
                  let errorMsg = `Erro ${response.status}`;
                  try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                  throw new Error(errorMsg);
              }
              const newBacklog = await response.json();
              console.log("[Create Backlog Button] Backlog criado:", newBacklog);
              alert(`Backlog para ${projectNameForLogs} criado com sucesso! A página será recarregada.`);
              window.location.reload();
          } catch (error) {
              console.error('[Create Backlog Button] Erro:', error);
              alert(`Erro ao criar backlog: ${error.message}`);
              this.disabled = false; this.innerHTML = '<i class="bi bi-plus-lg me-1"></i>Criar Backlog';
          }
      });
  }

  // --- Funções Essenciais de Renderização (Definidas fora do DOMContentLoaded) ---
  let currentTasksData = []; // Precisa estar no escopo global
  let editingTaskId = null;  // Precisa estar no escopo global
  const sortableInstances = []; // Precisa estar no escopo global

  // Limpa as tarefas de todas as colunas
  function clearBoard() {
      console.log("[Clear Board] Limpando tarefas das colunas.");
      const taskLists = document.querySelectorAll('.kanban-tasks');
      taskLists.forEach(list => {
          list.innerHTML = '<div class="no-tasks">Nenhuma tarefa nesta coluna.</div>';
      });
      // updateColumnTotals() é chamado por renderTasks
  }

  // Escapa HTML para tooltips seguros
  function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
          .toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
  }

  // Mostra/esconde o overlay de loading no modal
  function showLoadingFeedback(isLoading) {
      const form = document.getElementById('addTaskForm');
      if (!form) return;
      const overlay = form.querySelector('.loading-overlay');
      const submitButton = form.querySelector('button[type="submit"]');
      const cancelButton = form.querySelector('button[data-bs-dismiss="modal"]');
      const deleteButton = document.getElementById('deleteTaskBtn');
      if (overlay) {
          overlay.style.display = isLoading ? 'flex' : 'none';
      } else {
           console.warn('Elemento .loading-overlay não encontrado no modal.');
      }
      if(submitButton) submitButton.disabled = isLoading;
      if (cancelButton) cancelButton.disabled = isLoading;
      if (deleteButton) deleteButton.disabled = isLoading;
  }

  // Lida com o clique em um card de tarefa para edição
  async function handleTaskClick(event) {
      const taskCard = event.currentTarget;
      const taskId = taskCard.dataset.taskId;
      if (!taskId) {
          console.error("Não foi possível obter o ID da tarefa do card.");
          return;
      }
      editingTaskId = taskId; // Atualiza global
      console.log(`[Task Click] Tarefa ID ${editingTaskId} clicada para edição.`);
      
      // Seleciona elementos do modal
      const addTaskModalEl = document.getElementById('addTaskModal');
      if (!addTaskModalEl) { console.error("Modal #addTaskModal não encontrado."); return; }
      const addTaskModalInstance = bootstrap.Modal.getInstance(addTaskModalEl) || new bootstrap.Modal(addTaskModalEl);
      const addTaskForm = document.getElementById('addTaskForm');
      const addTaskModalLabel = document.getElementById('addTaskModalLabel');
      const deleteTaskBtn = document.getElementById('deleteTaskBtn');
      const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
      if (!addTaskForm || !addTaskModalLabel || !deleteTaskBtn || !remainingHoursGroup) {
           console.error("Elementos do modal (form, label, deleteBtn, remainingHoursGroup) não encontrados!");
           return;
      }
      
      // Reset e mostra loading ANTES da chamada API
      addTaskForm.reset(); 
      // Define título e ícone para EDIÇÃO
      addTaskModalLabel.innerHTML = '<i class="bi bi-pencil-square me-2"></i>Editar Tarefa';
      deleteTaskBtn.style.display = 'none'; // Esconde botão excluir enquanto carrega
      if(remainingHoursGroup) remainingHoursGroup.style.display = 'block'; // *** MOSTRA HORAS RESTANTES NA EDIÇÃO ***
      showLoadingFeedback(true);
      addTaskModalInstance.show(); // Mostra o modal com loading
      
      try {
          const response = await fetch(`/backlog/api/tasks/${editingTaskId}`);
          if (!response.ok) {
               let errorMsg = `Erro ${response.status}`;
               try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
               throw new Error(errorMsg);
          }
          const taskData = await response.json();
          console.log("[Task Click] Dados da tarefa recebidos:", taskData);
          
          // Popula o formulário com os dados recebidos
          addTaskForm.querySelector('#taskId').value = taskData.id;
          addTaskForm.querySelector('#taskName').value = taskData.name;
          addTaskForm.querySelector('#taskDescription').value = taskData.description || '';
          addTaskForm.querySelector('#taskPriority').value = taskData.priority || 'Média';
          addTaskForm.querySelector('#taskEstimatedHours').value = taskData.estimated_hours != null ? taskData.estimated_hours : '';
          // Exibe 0.0 se for zero, senão vazio
          addTaskForm.querySelector('#taskRemainingHours').value = taskData.remaining_hours != null ? taskData.remaining_hours : ''; 
          addTaskForm.querySelector('#taskStartDate').value = taskData.start_date ? taskData.start_date.substring(0, 10) : '';
          addTaskForm.querySelector('#taskDueDate').value = taskData.due_date ? taskData.due_date.substring(0, 10) : '';
          
          // Atualiza título final (se necessário, embora já setado como Editar)
          // addTaskModalLabel.textContent = 'Editar Tarefa'; // Removido, já feito com innerHTML e ícone
          deleteTaskBtn.style.display = 'inline-block'; 
          
          // <<< INÍCIO: Popular campo Especialista (agora um select) >>>
          const specialistSelect = addTaskForm.querySelector('#taskSpecialist');
          if (specialistSelect) {
              // Define o valor do select. Se taskData.specialist_name for null/undefined/vazio, selecionará a opção padrão com value=""
              specialistSelect.value = taskData.specialist_name || ''; 
          } else {
              console.error("Elemento select #taskSpecialist não encontrado no modal.");
          }
          // <<< FIM: Popular campo Especialista (agora um select) >>>
          
      } catch (error) {
          console.error('[Task Click] Erro ao carregar dados da tarefa:', error);
          addTaskModalLabel.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>Erro ao Carregar'; // Indica erro no título com ícone
          alert(`Erro ao carregar dados da tarefa: ${error.message}`);
          // Considerar fechar o modal ou manter aberto com erro? Manter aberto por enquanto.
      } finally {
          // Esconde o loading DEPOIS de popular ou dar erro
          showLoadingFeedback(false); 
      }
  }

  // Adiciona um único card de tarefa �  coluna correta
  function addTaskToBoard(task) {
      const column = document.querySelector(`.kanban-tasks[data-column-id="${task.column_id}"]`);
      if (column) {
          const noTasksMsg = column.querySelector('.no-tasks');
          if (noTasksMsg) noTasksMsg.remove();
          const taskCard = document.createElement('div');
          
          // Determina a classe da coluna para a cor da borda superior
          const columnIdentifier = task.column_identifier || 'default'; 
          const colorClass = `task-col-${columnIdentifier}`;
          // console.log(`[Task Board] ID: ${task.id}, Identifier: ${columnIdentifier}, Classe CSS Cor: ${colorClass}`); 

          taskCard.className = `kanban-task-card ${colorClass}`; // Adiciona a classe de cor
          taskCard.dataset.taskId = task.id;
          taskCard.addEventListener('click', handleTaskClick); 
          
          // Monta o ID completo (como antes)
          const projectPart = initialProjectId || 'PROJ'; 
          const columnPartForId = (task.column_name || columnIdentifier).substring(0, 3).toUpperCase();
          const fullTaskId = `${projectPart}-${columnPartForId}-${task.id}`;

          // --- Determina Classe CSS para Badge de Prioridade e ÍCONE ---
          let priorityBadgeClass = 'text-bg-primary'; // Default: Média
          let priorityIconClass = 'bi-dash-lg';      // Default: Média
          const priorityLower = (task.priority || '').toLowerCase();
          if (priorityLower === 'urgente') {
              priorityBadgeClass = 'text-bg-danger';
              priorityIconClass = 'bi-exclamation-octagon-fill';
          }
          // Ajuste para Amarelo do Warning ter texto escuro
          else if (priorityLower === 'alta') {
               priorityBadgeClass = 'text-bg-warning'; 
               priorityIconClass = 'bi-chevron-double-up';
          }
          else if (priorityLower === 'baixa') {
              priorityBadgeClass = 'text-bg-secondary';
              priorityIconClass = 'bi-chevron-double-down';
          }
          const priorityText = task.priority || 'Média';
          // -----------------------------------------------------------

          // --- Formata Data de Conclusão (se aplicável) ---
          let completionDateHtml = '';
          if (task.column_identifier === 'concluido' && task.completed_at) {
              try {
                  const completedDate = new Date(task.completed_at);
                  const formattedDate = completedDate.toLocaleDateString('pt-BR', {
                      day: '2-digit', month: '2-digit', year: 'numeric'
                  });
                  completionDateHtml = `
                      <span class="task-completion-date ms-auto" title="Concluído em">
                          <i class="bi bi-calendar-check-fill"></i>
                          ${formattedDate}
                      </span>
                  `;
              } catch (e) {
                  console.error("Erro ao formatar data de conclusão:", e, task.completed_at);
                  completionDateHtml = '<span class="task-completion-date text-danger ms-auto" title="Erro na data"><i class="bi bi-exclamation-triangle"></i> Data Inválida</span>';
              }
          }
          // -----------------------------------------------------

          taskCard.innerHTML = `
              <div class="task-header">
                  <strong class="task-title">${escapeHtml(task.name)}</strong>
                  <code class="task-full-id" title="ID Completo da Tarefa">${fullTaskId}</code>
              </div>
              <div class="task-body">
                  <div class="task-meta-left"> {# Badge e Ícone Desc #}
                      <span class="badge ${priorityBadgeClass} task-priority-badge" title="Prioridade: ${priorityText}">
                          <i class="bi ${priorityIconClass}"></i> {# Ícone de Prioridade #}
                          <span>${priorityText}</span>
                      </span>
                      ${task.description ? `<i class="bi bi-text-paragraph task-desc-icon" title="Descrição: ${escapeHtml(task.description)}"></i>` : ''}
                  </div>
                  <div class="task-details"> {# Detalhes de Tempo #}
                      <span title="Estimado"><i class="bi bi-clock-history"></i>${task.estimated_hours != null ? task.estimated_hours.toFixed(1) + 'h' : '-'}</span>
                      <span title="Restante"><i class="bi bi-hourglass-split"></i>${task.remaining_hours != null ? task.remaining_hours.toFixed(1) + 'h' : '-'}</span>
                      ${task.sprint_name ? 
                        `<span class="task-sprint-info" title="Sprint Alocada"><i class="bi bi-calendar3-week"></i> ${escapeHtml(task.sprint_name)}</span>` 
                        : ''
                      }
                      {# <<< INÍCIO: Exibir Especialista no Card >>> #}
                      ${task.specialist_name ? 
                        `<span class="task-specialist-info text-muted" title="Especialista">
                           <i class="bi bi-person"></i> ${escapeHtml(task.specialist_name)}
                         </span>` 
                        : ''
                      }
                      {# <<< FIM: Exibir Especialista no Card >>> #}
                      {# Span da data de conclusão é adicionado/removido dinamicamente pelo JS agora #}
                      <span class="task-completion-date" title="Concluído em" style="display: none;"></span> {# Removido ms-auto daqui #}
                  </div>
              </div>
          `;
          column.appendChild(taskCard);
      } else {
          console.warn(`[Add Task To Board] Coluna ID ${task.column_id} não encontrada para a tarefa ID ${task.id}`);
      }
  }

  // (Re)Inicializa o SortableJS para todas as colunas
  function initializeSortable() {
      sortableInstances.forEach(instance => instance.destroy());
      sortableInstances.length = 0;
      const taskLists = document.querySelectorAll('.kanban-tasks');
      taskLists.forEach(list => {
          const instance = new Sortable(list, {
              group: 'kanban',
              animation: 150,
              ghostClass: 'sortable-ghost',
              chosenClass: 'sortable-chosen',
              draggable: '.kanban-task-card',
              onEnd: async function (evt) {
                  const taskId = evt.item.dataset.taskId;
                  const newColumnId = evt.to.dataset.columnId;
                  const newIndex = evt.newIndex; // Índice baseado em 0 na nova lista

                  console.log(`[Task Moved] Tarefa ID: ${taskId}, Nova Coluna ID: ${newColumnId}, Nova Posição (Índice): ${newIndex}`);

                  // Prepara dados para a API
                  const moveData = {
                      column_id: newColumnId,
                      position: newIndex // API espera a posição (índice) na nova coluna
                  };

                  // Adiciona um feedback visual temporário (opcional)
                  evt.item.style.opacity = '0.5'; 

                  let updatedTask = null; // << DECLARA FORA DO TRY
                  try {
                      const response = await fetch(`/backlog/api/tasks/${taskId}/move`, {
                          method: 'PUT',
                          headers: {'Content-Type': 'application/json'},
                          body: JSON.stringify(moveData)
                      });

                      console.log(`[Task Moved] Resposta API (${response.status}):`, response);
                      if (!response.ok) {
                          let errorMsg = `Erro ${response.status}`;
                          try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                          throw new Error(errorMsg);
                      }

                      updatedTask = await response.json(); // << ATRIBUI AQUI
                      console.log("[Task Moved] Tarefa atualizada pela API:", updatedTask);

                      // Atualiza o currentTasksData localmente (IMPORTANTE!)
                      const taskIndex = currentTasksData.findIndex(t => t.id == updatedTask.id);
                      if (taskIndex > -1) {
                          currentTasksData[taskIndex] = updatedTask;
                      } else {
                          currentTasksData.push(updatedTask);
                      }
                      
                      // --- ATUALIZAÇÃO VISUAL DO CARD MOVIDO --- 
                      // 1. Atualiza a classe de cor (borda superior)
                      const newColumnIdentifier = updatedTask.column_identifier || 'default';
                      const newColorClass = `task-col-${newColumnIdentifier}`;
                      // Remove classes de cor antigas (ex: task-col-afazer, task-col-andamento, etc.)
                      evt.item.classList.forEach(className => {
                          if (className.startsWith('task-col-')) {
                              evt.item.classList.remove(className);
                          }
                      });
                      evt.item.classList.add(newColorClass); // Adiciona a nova classe
                      console.log(`[Task Moved UI] Classe de cor (borda) atualizada para ${newColorClass} no item ${updatedTask.id}`);

                      // 2. Atualiza o ID completo exibido (se necessário)
                      const taskIdElement = evt.item.querySelector('.task-full-id');
                      if (taskIdElement) {
                          const projPart = initialProjectId || 'PROJ';
                          const colPart = (updatedTask.column_name || newColumnIdentifier).substring(0, 3).toUpperCase();
                          const newFullId = `${projPart}-${colPart}-${updatedTask.id}`;
                          if (taskIdElement.textContent !== newFullId) {
                                taskIdElement.textContent = newFullId;
                                console.log(`[Task Moved UI] ID completo atualizado para ${newFullId} no item ${updatedTask.id}`);
                          }
                      }
                      // ---------------------------------------------

                      // Atualiza a timeline sempre que uma tarefa for movida
                      console.log(`[Task Moved] Atualizando timeline após movimentação da tarefa ${taskId}`);
                      setTimeout(updateTimelineTasks, 500);

                      // Recalcula totais
                      updateColumnTotals();
                      
                  } catch (error) {
                      console.error('[Task Moved] Erro ao salvar nova posição:', error);
                      alert(`Erro ao mover tarefa: ${error.message}. A interface pode estar dessincronizada. Recarregue a página.`);
                      // TODO: Reverter a mudança visual do SortableJS em caso de erro?
                      // Sortable.active.sort(originalOrder); // Requer guardar a ordem original
                  } finally {
                       // Restaura a opacidade normal
                       evt.item.style.opacity = '1';
                  }
                  
                  // --- Atualização da UI para Mensagem "Nenhuma Tarefa" ---
                  // Verifica coluna de DESTINO
                  const destinationColumnTasks = evt.to.querySelectorAll('.kanban-task-card');
                  const destNoTasksMsg = evt.to.querySelector('.no-tasks');
                  if (destinationColumnTasks.length > 0 && destNoTasksMsg) {
                      destNoTasksMsg.remove(); // Remove se há tarefas e a msg existe
                      console.log(`[Task Moved UI] Removida msg 'no-tasks' da coluna destino ID: ${evt.to.dataset.columnId}`);
                  }
                  
                  // Verifica coluna de ORIGEM (se diferente da destino)
                  if (evt.from !== evt.to) {
                      const sourceColumnTasks = evt.from.querySelectorAll('.kanban-task-card');
                      const sourceNoTasksMsg = evt.from.querySelector('.no-tasks');
                      if (sourceColumnTasks.length === 0 && !sourceNoTasksMsg) {
                          const noTasksDiv = document.createElement('div');
                          noTasksDiv.className = 'no-tasks';
                          noTasksDiv.textContent = 'Nenhuma tarefa nesta coluna.';
                          evt.from.appendChild(noTasksDiv);
                          console.log(`[Task Moved UI] Adicionada msg 'no-tasks' �  coluna origem ID: ${evt.from.dataset.columnId}`);
                      }
                  }
                  // ----------------------------------------------------------

                  // --- ATUALIZAÇÃO VISUAL: Data de Conclusão ---
                  const completionDateSpan = evt.item.querySelector('.task-completion-date');
                  let newCompletionHtml = ''; // HTML a ser inserido
                  if (updatedTask && updatedTask.column_identifier === 'concluido' && updatedTask.completed_at) { // Verifica se updatedTask existe
                      try {
                          const completedDate = new Date(updatedTask.completed_at);
                          const formattedDate = completedDate.toLocaleDateString('pt-BR', {
                              day: '2-digit', month: '2-digit', year: 'numeric'
                          });
                          newCompletionHtml = `
                              <i class="bi bi-calendar-check-fill"></i>
                              ${formattedDate}
                          `; // Gera apenas o conteúdo interno do span
                      } catch (e) {
                          console.error("Erro ao formatar data de conclusão (onEnd):", e, updatedTask.completed_at);
                          newCompletionHtml = '<i class="bi bi-exclamation-triangle text-danger"></i> Data Inválida';
                      }
                  }

                  // Atualiza ou cria o span da data de conclusão
                  if (completionDateSpan) {
                       // Se o span já existe, apenas atualiza o conteúdo ou remove se não for mais necessário
                       if (newCompletionHtml) {
                           completionDateSpan.innerHTML = newCompletionHtml;
                           completionDateSpan.style.display = 'inline-flex'; // Garante visibilidade
                       } else {
                           completionDateSpan.style.display = 'none'; // Esconde se não aplicável
                           completionDateSpan.innerHTML = ''; // Limpa conteúdo
                       }
                  } else if (newCompletionHtml) {
                       // Se o span não existe E deveria existir (tarefa movida para concluído)
                       // Cria o span e adiciona na div de detalhes
                       const detailsDiv = evt.item.querySelector('.task-details');
                       if (detailsDiv) {
                           const newSpan = document.createElement('span');
                           newSpan.className = 'task-completion-date'; // Removido ms-auto
                           newSpan.title = 'Concluído em';
                           newSpan.innerHTML = newCompletionHtml;
                           newSpan.style.display = 'inline-flex'; // Garante display
                           detailsDiv.appendChild(newSpan);
                           console.log(`[Task Moved UI] Span de data de conclusão criado para ${updatedTask.id}`);
                       }
                  }
                  // ---------------------------------------------------
              }
          });
          sortableInstances.push(instance);
      });
      console.log(`[Sortable Init] ${sortableInstances.length} instâncias criadas/recriadas.`);
  }

  // Calcula e exibe os totais de horas por coluna e o total Kanban
  function updateColumnTotals() {
      console.log("[Column Totals] Iniciando cálculo de totais...");
      let grandTotalRemainingKanban = 0;
      const columns = document.querySelectorAll('.kanban-column');
      const kanbanTotalRemainingHoursEl = document.getElementById('kanbanTotalRemainingHours');
      columns.forEach(column => {
          const columnId = column.dataset.columnId; // Pega o ID da coluna
          const tasksInColumn = column.querySelectorAll('.kanban-task-card');
          const taskCount = tasksInColumn.length; // Conta os cards na coluna
          
          let totalEstimated = 0;
          let totalRemaining = 0;

          // Itera sobre currentTasksData FILTRANDO pela coluna atual
          // Isso garante que estamos usando os dados mais recentes, não o DOM
          currentTasksData.filter(task => task.column_id == columnId).forEach(taskData => {
               totalEstimated += taskData.estimated_hours || 0;
               totalRemaining += taskData.remaining_hours || 0;
          });
          
          // Atualiza os elementos no DOM
          const countEl = column.querySelector('.task-count .count-value');
          const estimatedEl = column.querySelector('.total-estimated');
          const remainingEl = column.querySelector('.total-remaining');
          
          if (countEl) countEl.textContent = taskCount; // Usa a contagem do DOM
          else console.warn(`Count element not found in column ID ${columnId}`);
          
          if (estimatedEl) estimatedEl.textContent = totalEstimated.toFixed(1);
          else console.warn(`Estimated element not found in column ID ${columnId}`);
          
          if (remainingEl) remainingEl.textContent = totalRemaining.toFixed(1);
           else console.warn(`Remaining element not found in column ID ${columnId}`);

          grandTotalRemainingKanban += totalRemaining; // Soma para o total geral
      });
      
      // Atualiza o total geral no cabeçalho da página
      if (kanbanTotalRemainingHoursEl) {
          kanbanTotalRemainingHoursEl.textContent = grandTotalRemainingKanban.toFixed(1);
      } else {
          console.warn("[Column Totals] Elemento #kanbanTotalRemainingHours não encontrado.");
      }
      console.log("[Column Totals] Cálculo de totais concluído. Total Kanban Restante:", grandTotalRemainingKanban.toFixed(1));
  }

  // !!! DEFINIÇÃO DE RENDER TASKS !!!
  function renderTasks(tasks) {
      console.log("[Render Tasks] Iniciando renderização. Tarefas recebidas (tipo inicial):", typeof tasks, tasks);
      let parsedTasks = [];
      if (typeof tasks === 'string' && tasks !== '[]') {
          try {
              parsedTasks = JSON.parse(tasks);
          } catch (e) {
              console.error("Erro ao fazer parse das tarefas JSON:", e);
              parsedTasks = [];
          }
      } else if (Array.isArray(tasks)) {
          parsedTasks = tasks;
      } else {
           console.warn("Tipo inesperado ou string vazia para initialTasks, usando array vazio.");
           parsedTasks = [];
      }
      currentTasksData = parsedTasks;
      const boardStatus = document.getElementById('boardStatus');
      const kanbanBoard = document.getElementById('kanbanBoard');
      const addTaskBtn = document.getElementById('addTaskBtn');
      clearBoard();
      if (currentTasksData.length > 0) {
          // Ordena por posição ANTES de renderizar
          currentTasksData.sort((a, b) => (a.position != null ? a.position : Infinity) - (b.position != null ? b.position : Infinity));
          
          currentTasksData.forEach(task => addTaskToBoard(task)); // Adiciona cada card ao DOM
          
          // Esconde mensagem de status, mostra quadro, habilita botão Add
          if (boardStatus && boardStatus.style.display !== 'none') {
              boardStatus.style.display = 'none'; 
          }
          if (kanbanBoard) kanbanBoard.style.display = 'flex'; 
          if (addTaskBtn) addTaskBtn.disabled = !initialBacklogId; 
      } else {
           // Quadro está vazio
           if (initialBacklogId) { // Se temos um backlog, mostra msg "nenhuma tarefa"
               if(boardStatus && boardStatus.style.display === 'none') { // Só mostra se já não estiver visível
                   showBoardStatus('Nenhuma tarefa neste backlog. Adicione uma nova tarefa!', 'info', true); // True para mostrar o board vazio
               }
               if (kanbanBoard) kanbanBoard.style.display = 'flex'; // Mostra o board mesmo vazio
           } else {
               // Sem backlog ID, a mensagem de "Criar Backlog" já deve estar visível (controlado pelo Jinja/JS inicial)
               if (kanbanBoard) kanbanBoard.style.display = 'none'; // Esconde o board se não há backlog
           }
           if (addTaskBtn) addTaskBtn.disabled = !initialBacklogId; // Desabilita Add se não há backlog
      }
      
      // Sempre (re)inicializa sortable e atualiza totais depois de renderizar
      initializeSortable(); 
      updateColumnTotals(); 
      console.log("[Render Tasks] Renderização concluída. Tarefas no quadro:", currentTasksData.length);
  }
  // !!! FIM DA DEFINIÇÃO DE RENDER TASKS !!!

  // --- Fim Funções Essenciais ---

  // Listener para quando o modal é fechado (Mantido)
  const addTaskModalElGlobal = document.getElementById('addTaskModal');
  if (addTaskModalElGlobal) {
      addTaskModalElGlobal.addEventListener('hidden.bs.modal', function (event) {
          console.log("[Modal Hidden] Resetando formulário e estado de edição.");
          const form = document.getElementById('addTaskForm');
          const label = document.getElementById('addTaskModalLabel');
          const deleteBtn = document.getElementById('deleteTaskBtn');
          const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
          if (form) form.reset();
          editingTaskId = null;
          if (label) label.textContent = 'Adicionar Nova Tarefa';
          if (deleteBtn) deleteBtn.style.display = 'none';
          if (remainingHoursGroup) remainingHoursGroup.style.display = 'none'; // *** ESCONDE HORAS RESTANTES NA CRIAÇÃO ***
          showLoadingFeedback(false); // Garante que o loading overlay seja escondido
      });
  } else {
      console.error("Elemento do Modal #addTaskModal não encontrado para adicionar listener hidden.bs.modal");
  }

  // Listener para submissão do formulário (Criar/Editar Tarefa) - RESTAURADO E AJUSTADO
  const addTaskFormGlobal = document.getElementById('addTaskForm');
  if (addTaskFormGlobal) {
      addTaskFormGlobal.addEventListener('submit', async function(event) {
          event.preventDefault();
          const form = event.target; // Referência ao formulário

          // --- Coleta Manual de Dados --- 
          const taskData = {};
          taskData.taskId = form.querySelector('#taskId')?.value; // Pode ser vazio na criação
          taskData.name = form.querySelector('#taskName')?.value.trim();
          taskData.description = form.querySelector('#taskDescription')?.value || '';
          taskData.priority = form.querySelector('#taskPriority')?.value || 'Média';
          
          // Leitura explícita e parse das horas
          const estimatedStr = form.querySelector('#taskEstimatedHours')?.value;
          const remainingStr = form.querySelector('#taskRemainingHours')?.value;
          taskData.estimated_hours = estimatedStr ? parseFloat(estimatedStr) : null;
          taskData.remaining_hours = remainingStr ? parseFloat(remainingStr) : taskData.estimated_hours;

          // Leitura explícita das datas
          taskData.start_date = form.querySelector('#taskStartDate')?.value || null;
          taskData.due_date = form.querySelector('#taskDueDate')?.value || null;

          // <<< INÍCIO: Ler campo Especialista (agora um select) >>>
          const selectedSpecialist = form.querySelector('#taskSpecialist')?.value;
          taskData.specialist_name = selectedSpecialist || null; // Se for string vazia (opção padrão), envia null
          // <<< FIM: Ler campo Especialista (agora um select) >>>

          // DEBUG: Logar o valor RAW das datas para verificar formato YYYY-MM-DD
          console.log("[Form Submit] Raw Date Values - Start:", form.querySelector('#taskStartDate')?.value, "Due:", form.querySelector('#taskDueDate')?.value);

          console.log("[Form Submit] Dados coletados MANUALMENTE:", taskData);

          // Validação básica
          if (!taskData.name) {
              alert("O nome da tarefa é obrigatório.");
              return;
          }
          const isEditing = !!editingTaskId; 
          if (!isEditing && !initialBacklogId) {
              alert("Erro: ID do backlog não definido. Não é possível criar a tarefa.");
              return;
          }
          
          // Ajuste URLs e Método
          const url = isEditing ? `/backlog/api/tasks/${editingTaskId}` : `/backlog/api/backlogs/${initialBacklogId}/tasks`;
          const method = isEditing ? 'PUT' : 'POST';

          console.log(`[Form Submit] ${isEditing ? 'Editando' : 'Criando'} Tarefa ID: ${editingTaskId || '(novo)'}. URL: ${url}, Method: ${method}`);

          // Ajusta payload para Criação vs Edição
          let payload = { ...taskData }; // Cria cópia para modificar
          delete payload.taskId; // Remove o campo taskId do payload final em ambos os casos

          if (!isEditing) {
              payload.backlog_id = initialBacklogId ? parseInt(initialBacklogId, 10) : null; // Converte para Inteiro
              // Define a coluna inicial como a primeira coluna visível
              const firstColumnEl = document.querySelector('.kanban-column[data-column-id]');
              const firstColumnIdStr = firstColumnEl ? firstColumnEl.dataset.columnId : null;
              payload.column_id = firstColumnIdStr ? parseInt(firstColumnIdStr, 10) : null; // Converte para Inteiro
              if (!payload.column_id) {
                  alert("Erro crítico: Não foi possível determinar a coluna inicial para a nova tarefa.");
                  showLoadingFeedback(false); // Esconder loading
                  return;
              }
               // Define posição inicial como 0 (topo da coluna)
               payload.position = 0; 
          } else {
               // Para edição (PUT /tasks/{id}), não precisamos enviar backlog_id, column_id ou position no payload principal.
               // A API /move é usada para isso.
               delete payload.backlog_id;
               delete payload.column_id;
               delete payload.position;
          } 

          console.log("[Form Submit] Payload FINAL a enviar:", payload);

          showLoadingFeedback(true);
          try {
              const response = await fetch(url, {
                  method: method,
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
              });

              console.log(`[Form Submit] Resposta API (${response.status}):`, response);
              if (!response.ok) {
                  let errorMsg = `Erro ${response.status}`;
                  try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                  throw new Error(errorMsg);
              }

              const savedTask = await response.json();
              console.log("[Form Submit] Tarefa salva/atualizada:", savedTask);

              // Atualiza a UI e os dados locais
              const taskIndex = currentTasksData.findIndex(t => t.id == savedTask.id);
              if (taskIndex > -1) {
                  currentTasksData[taskIndex] = savedTask; // Atualiza
              } else {
                  currentTasksData.push(savedTask); // Adiciona se for nova
              }
              
              // Re-renderiza tudo para garantir consistência
              renderTasks(currentTasksData);

              const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal);
              if (modalInstance) modalInstance.hide();

              // Limpar formulário e esconder modal
              // modal.hide(); // ERRO: modal não está definido, removido
              
              // Atualiza totais e inicializa Sortable
              updateColumnTotals();
              
              // Atualizar linha do tempo ao criar uma nova tarefa
              updateTimelineTasks();
              
              console.log("[Task Created] Tarefa criada com sucesso");
          } catch (error) {
              console.error('[Form Submit] Erro:', error);
              alert(`Erro ao ${isEditing ? 'salvar' : 'criar'} tarefa: ${error.message}`);
          } finally {
              showLoadingFeedback(false);
          }
      });
  } else {
       console.error("Elemento #addTaskForm não encontrado para adicionar listener submit");
  }

  // Listener para o botão Excluir Tarefa - RESTAURADO
  const deleteTaskBtnGlobal = document.getElementById('deleteTaskBtn');
  if (deleteTaskBtnGlobal) {
      deleteTaskBtnGlobal.addEventListener('click', async function() {
          if (!editingTaskId) return;

          if (confirm('Tem certeza que deseja excluir esta tarefa?')) {
              console.log(`[Delete Task] Solicitando exclusão da Tarefa ID: ${editingTaskId}`);
              showLoadingFeedback(true);
              try {
                  const response = await fetch(`/backlog/api/tasks/${editingTaskId}`, { method: 'DELETE' });
                  console.log(`[Delete Task] Resposta API (${response.status}):`, response);

                  if (!response.ok && response.status !== 204) { // 204 No Content também é sucesso
                      let errorMsg = `Erro ${response.status}`;
                      try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                      throw new Error(errorMsg);
                  }

                  console.log("[Delete Task] Tarefa excluída com sucesso da API.");
                  
                  // Encontra o card no DOM para remover ANTES de re-renderizar tudo
                  const taskCardElement = document.querySelector(`.kanban-task-card[data-task-id="${editingTaskId}"]`);
                  if (taskCardElement) {
                       const parentColumn = taskCardElement.closest('.kanban-tasks');
                       taskCardElement.remove();
                       console.log("[Delete Task] Card removido do DOM.");
                       // Verifica se a coluna ficou vazia após remover
                       if (parentColumn && !parentColumn.querySelector('.kanban-task-card')) {
                           const noTasksDiv = document.createElement('div');
                           noTasksDiv.className = 'no-tasks';
                           noTasksDiv.textContent = 'Nenhuma tarefa nesta coluna.';
                           parentColumn.appendChild(noTasksDiv);
                           console.log(`[Delete Task] Coluna ID ${parentColumn.dataset.columnId} ficou vazia, adicionada msg.`);
                       }
                  } else {
                       console.warn(`[Delete Task] Card com ID ${editingTaskId} não encontrado no DOM para remoção visual imediata.`);
                  }

                  // Remove a tarefa dos dados locais
                  currentTasksData = currentTasksData.filter(t => t.id != editingTaskId);
                  console.log("[Delete Task] Tarefa removida do array currentTasksData.");
                  
                  // Atualiza os totais das colunas e o total geral (sem re-renderizar tudo)
                  updateColumnTotals(); 

                  const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal);
                  if (modalInstance) modalInstance.hide();

                  // Atualizar linha do tempo ao excluir uma tarefa
                  updateTimelineTasks();

                  console.log("[Task Deleted] Tarefa excluída com sucesso");

              } catch (error) {
                  console.error('[Delete Task] Erro:', error);
                  alert(`Erro ao excluir tarefa: ${error.message}`);
              } finally {
                  showLoadingFeedback(false);
                  editingTaskId = null; // Limpa ID de edição após tentativa
              }
          }
      });
  } else {
       console.error("Elemento #deleteTaskBtn não encontrado para adicionar listener click");
  }
  
  // --- Listener para o botão "Adicionar Tarefa" (estático) - RESTAURADO ---
  const addTaskBtnGlobal = document.getElementById('addTaskBtn');
  if (addTaskBtnGlobal) {
      addTaskBtnGlobal.addEventListener('click', () => {
          if (!initialBacklogId) {
              alert("Não é possível adicionar tarefas sem um backlog ativo.");
              return;
          }
          console.log("[Add Task Button] Clicked. Opening modal.");
          // Reseta o formulário E o estado de edição
          editingTaskId = null; // Garante que está no modo CRIAR
          const form = document.getElementById('addTaskForm');
          const label = document.getElementById('addTaskModalLabel');
          const deleteBtn = document.getElementById('deleteTaskBtn');
          const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
          if(form) form.reset();
          // Define título e ícone para CRIAÇÃO
          if(label) label.innerHTML = '<i class="bi bi-plus-square-dotted me-2"></i>Adicionar Nova Tarefa'; 
          if(deleteBtn) deleteBtn.style.display = 'none';
          if(remainingHoursGroup) remainingHoursGroup.style.display = 'none'; // *** ESCONDE HORAS RESTANTES NA CRIAÇÃO ***
          showLoadingFeedback(false);
          
          // Foca no campo nome ao abrir para criação
          const taskNameInput = addTaskModalElGlobal?.querySelector('#taskName');
          // Adiciona um pequeno delay para garantir que o modal esteja visível antes de focar
          addTaskModalElGlobal?.addEventListener('shown.bs.modal', () => {
                if (taskNameInput) {
                     taskNameInput.focus();
                }
          }, { once: true }); // Listener é removido após ser acionado uma vez

          const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal) || new bootstrap.Modal(addTaskModalElGlobal);
          modalInstance.show();
      });
  } else { console.error("Botão #addTaskBtn não encontrado."); }

  document.addEventListener('DOMContentLoaded', function () {
    console.log("[Board Init] Inicialização do quadro concluída (JS simplificado).");
    console.log("[Board Init] Tarefas iniciais recebidas:", initialTasks);
    console.log(`[Board Init] Projeto: ${projectNameForLogs} (ID: ${initialProjectId}), Backlog ID: ${initialBacklogId || 'Nenhum'}`);

    // *** CONTROLE DE VISIBILIDADE INICIAL DO QUADRO ***
    const kanbanBoardElement = document.getElementById('kanbanBoard');
    if (kanbanBoardElement) {
        kanbanBoardElement.style.display = initialBacklogId ? 'flex' : 'none';
    } else {
        console.error("#kanbanBoard não encontrado durante inicialização.");
    }
    // ****************************************************

    // *** CHAMADA ESSENCIAL PARA RENDERIZAR AS TAREFAS ***
    renderTasks(initialTasks);
    // ****************************************************

    // <<< INÍCIO: Chamar carregamento de especialistas >>>
    loadSpecialistOptions();
    // <<< FIM: Chamar carregamento de especialistas >>>

    // *** CARREGAMENTO INICIAL DOS MARCOS ***
    loadMilestones();
    
    // Adicionar botão de teste no console para facilitar depuração
    console.log("Para testar a renderização de marcos diretamente, execute: testRenderMilestones()");
    // *** FIM CARREGAMENTO DOS MARCOS ***

    // Adicionar Event Listeners para Marcos
    if (addMilestoneBtn) {
        addMilestoneBtn.addEventListener('click', () => openMilestoneModal());
    }
    
    // IMPORTANTE: Registrar listener para o formulário de marcos
    if (milestoneForm) {
        milestoneForm.addEventListener('submit', handleMilestoneFormSubmit);
        console.log("[Milestone Form] Listener de submit registrado");
    } else {
        console.error("[Milestone Form] Elemento milestoneForm não encontrado para adicionar listener");
    }
    
    // Adicionar listener para o botão de recarregar marcos
    const reloadMilestonesBtn = document.getElementById('reloadMilestonesBtn');
    if (reloadMilestonesBtn) {
        reloadMilestonesBtn.addEventListener('click', () => {
            console.log("[Recarregar] Solicitando recarregamento manual de marcos...");
            loadMilestones(); // Sempre usa o método normal agora que corrigimos
        });
    }
    
    if (deleteMilestoneBtn) {
        deleteMilestoneBtn.addEventListener('click', () => {
            const milestoneId = milestoneIdInput.value;
            const milestoneName = document.getElementById('milestoneName').value; 
            if (milestoneId) {
                confirmDeleteMilestone(milestoneId, milestoneName);
            }
        });
    }

    // Inicializar a linha do tempo após um breve atraso
    setTimeout(updateTimelineTasks, 1500);
  }); // Fecha o DOMContentLoaded
  
  // Handle form submit para marcos
  async function handleMilestoneFormSubmit(event) {
      event.preventDefault();
      
      console.log("[Milestone Form] Processando envio do formulário");
      
      if (!milestoneForm) {
          console.error("[Milestone Form] Formulário não encontrado");
          return;
      }
      
      // Obter ID do backlog atual
      const currentBacklogIdFromDOM = document.getElementById('currentBacklogId')?.value;
      if (!currentBacklogIdFromDOM) {
          console.error("[Milestone Form] ID do backlog não encontrado");
          showToast("Erro: ID do backlog não encontrado", "error");
          return;
      }
      
      // Obter valor do ID (se estiver editando)
      const milestoneId = milestoneIdInput.value;
      const isEditing = !!milestoneId;
      
      // Mostrar loading
      showModalLoading(milestoneModalElement, true);
      
      try {
          // Preparar dados do formulário
          const formData = {
              name: document.getElementById('milestoneName').value,
              description: document.getElementById('milestoneDescription').value,
              planned_date: document.getElementById('milestonePlannedDate').value,
              actual_date: document.getElementById('milestoneActualDate').value || null,
              status: document.getElementById('milestoneStatus').value,
              criticality: document.getElementById('milestoneCriticality').value,
              is_checkpoint: document.getElementById('milestoneIsCheckpoint').checked,
              backlog_id: parseInt(currentBacklogIdFromDOM, 10)
          };
          
          console.log(`[Milestone Form] ${isEditing ? 'Editando' : 'Criando'} marco:`, formData);
          
          // Determinar URL e método com base em criação/edição
          const url = isEditing 
              ? `/backlog/api/milestones/${milestoneId}` 
              : `/backlog/api/milestones`;  // CORRIGIDO: URL para criação de marcos
          const method = isEditing ? 'PUT' : 'POST';
          
          // Enviar para a API
          const response = await fetch(url, {
              method: method,
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(formData)
          });
          
          // Verificar resposta
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
          }
          
          // Processar sucesso
          const savedMilestone = await response.json();
          console.log(`[Milestone Form] Marco ${isEditing ? 'atualizado' : 'criado'} com sucesso:`, savedMilestone);
          
          // Mostrar mensagem de sucesso
          showToast(`Marco ${isEditing ? 'atualizado' : 'criado'} com sucesso`, "success");
          
          // Fechar modal
          milestoneModal.hide();
          
          // Recarregar a lista de marcos
          loadMilestones();
          
      } catch (error) {
          console.error('[Milestone Form] Erro:', error);
          showToast(`Erro ao ${isEditing ? 'atualizar' : 'criar'} marco: ${error.message}`, 'error');
      } finally {
          // Esconder loading
          showModalLoading(milestoneModalElement, false);
      }
  }

  // Função de teste para renderizar marcos diretamente com dados fixos
  function testRenderMilestones() {
      console.log("[Test] Testando renderização direta de marcos...");
      
      // PASSO 1: Verificar a estrutura da tabela no DOM
      const tableElement = document.querySelector('table#milestonesTable');
      const tbodyElement = document.getElementById('milestonesTableBody');
      
      console.log("[DOM Inspection] Tabela encontrada:", tableElement);
      console.log("[DOM Inspection] TBODY encontrado:", tbodyElement);
      
      if (tableElement) {
          console.log("[DOM Inspection] Classes da tabela:", tableElement.className);
          console.log("[DOM Inspection] Estrutura da tabela:", tableElement.innerHTML.substring(0, 100) + "...");
      }
      
      if (tbodyElement) {
          console.log("[DOM Inspection] Classes do tbody:", tbodyElement.className);
          console.log("[DOM Inspection] Conteúdo atual do tbody:", tbodyElement.innerHTML);
      }
      
      // PASSO 2: Tentar inserir uma linha manualmente para teste
      if (tbodyElement) {
          const testRow = document.createElement('tr');
          testRow.innerHTML = `
              <td>TESTE MANUAL</td>
              <td>15/05/2025</td>
              <td>-</td>
              <td><span class="badge bg-primary">Pendente</span></td>
              <td><span class="badge bg-info text-dark">Média</span></td>
              <td>
                  <button class="btn btn-outline-primary btn-sm" title="Editar">
                      <i class="bi bi-pencil-fill"></i>
                  </button>
                  <button class="btn btn-outline-danger btn-sm" title="Excluir">
                      <i class="bi bi-trash-fill"></i>
                  </button>
              </td>
          `;
          console.log("[Test] Adicionando linha de teste manualmente");
          tbodyElement.appendChild(testRow);
          console.log("[Test] Adicionada linha de teste. Novo conteúdo:", tbodyElement.innerHTML);
      }
      
      // PASSO 3: Renderizar os dados de teste normalmente
      const mockMilestones = [
          {
              id: 999,
              name: "Marco de Teste",
              planned_date: "2025-05-15",
              actual_date: null,
              status: "Pendente",
              criticality: "Média",
              is_checkpoint: false,
              is_delayed: false,
              backlog_id: 4
          }
      ];
      
      console.log("[Test] Dados de teste:", mockMilestones);
      renderMilestones(mockMilestones);
      
      // PASSO 4: Verificar o resultado após a renderização normal
      console.log("[Test] Renderização direta concluída. Conteúdo do tbody:", document.getElementById('milestonesTableBody')?.innerHTML || "Não encontrado");
  }
  
  // Função para forçar o preenchimento direto da tabela (ignorando renderMilestones)
  function forceFillMilestonesTable() {
      console.log("[Force Fill] Tentando preencher diretamente a tabela...");
      
      // Encontra o tbody
      const tbody = document.getElementById('milestonesTableBody');
      if (!tbody) {
          console.error("[Force Fill] TBODY não encontrado!");
          return;
      }
      
      // Limpa o conteúdo atual
      tbody.innerHTML = '';
      
      // Cria uma linha de teste 
      const tr = document.createElement('tr');
      tr.innerHTML = `
          <td>Marco Teste Direto</td>
          <td>15/05/2025</td>
          <td>-</td>
          <td><span class="badge bg-warning text-dark">Em Andamento</span></td>
          <td><span class="badge bg-info text-dark">Média</span></td>
          <td>
              <button class="btn btn-outline-primary btn-sm" title="Editar Marco">
                  <i class="bi bi-pencil-fill"></i>
              </button>
              <button class="btn btn-outline-danger btn-sm" title="Excluir Marco">
                  <i class="bi bi-trash-fill"></i>
              </button>
          </td>
      `;
      
      // Adiciona a linha ao tbody
      tbody.appendChild(tr);
      
      console.log("[Force Fill] Linha adicionada diretamente:", tr.outerHTML);
      console.log("[Force Fill] Conteúdo atual do tbody:", tbody.innerHTML);
  }

  // <<< INÍCIO: Função para carregar opções de especialista >>>
  async function loadSpecialistOptions() {
      const specialistSelect = document.getElementById('taskSpecialist');
      if (!specialistSelect) {
          console.error("Elemento select #taskSpecialist não encontrado para carregar opções.");
          return;
      }
      
      try {
          const response = await fetch('/backlog/api/available-specialists');
          if (!response.ok) {
              throw new Error(`Erro ${response.status} ao buscar especialistas`);
          }
          const specialists = await response.json();
          console.log("[Specialists Load] Lista recebida:", specialists);
          
          // Limpa opções existentes (exceto a primeira "-- Padrão --")
          specialistSelect.options.length = 1; 
          
          // Adiciona novas opções
          specialists.forEach(name => {
              const option = document.createElement('option');
              option.value = name;
              option.textContent = name;
              specialistSelect.appendChild(option);
          });
           console.log(`[Specialists Load] ${specialists.length} opções adicionadas ao select.`);
      } catch (error) {
          console.error("[Specialists Load] Erro ao carregar opções de especialista:", error);
          // Poderia mostrar um alerta ou manter o select vazio/desabilitado
      }
  }
  // <<< FIM: Função para carregar opções de especialista >>>

  // *** INÍCIO: LÓGICA PARA MARCOS (Milestones) ***

  // Função para mostrar indicador de carregamento
  function showLoadingIndicator(container, isLoading, colspan = 3, message = 'Carregando...') {
      if (!container) return;
      if (isLoading) {
          container.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-muted small py-3"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"><span class="visually-hidden">Loading...</span></div>${message}</td></tr>`;
      } else {
          // Se a mensagem for de erro ou "sem itens", mostra a mensagem
          if (message && (message.startsWith('Erro') || message.startsWith('Nenhum'))) {
               container.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-muted small py-3">${message}</td></tr>`;
          } else {
               // Se não for loading e não for mensagem especial, limpa (a renderização cuidará do resto)
               container.innerHTML = ''; 
          }
      }
  }

  // Função para mostrar toast (mensagem flutuante)
  function showToast(message, type = 'info') {
      // Implementação básica por enquanto - apenas alerta
      console.log(`[Toast] ${type.toUpperCase()}: ${message}`);
      alert(`${type.toUpperCase()}: ${message}`);
  }

  // Função para mostrar/esconder overlay de loading em modais
  function showModalLoading(modalElem, isLoading) {
      if (!modalElem) return;
      const overlay = modalElem.querySelector('.loading-overlay');
      const formElements = modalElem.querySelectorAll('input, textarea, select, button');
      if (overlay) {
          overlay.style.display = isLoading ? 'flex' : 'none';
      }
      formElements.forEach(el => el.disabled = isLoading);
  }

  // Função para carregar marcos da API
  async function loadMilestones() {
      // Obter valor atualizado do backlog ID diretamente do DOM
      const currentBacklogIdFromDOM = document.getElementById('currentBacklogId')?.value;
      
      // Verifica se milestonesTableBody existe
      if (!milestonesTableBody) {
          console.error("[Milestones] Elemento milestonesTableBody não encontrado");
          return;
      }
      
      if (!currentBacklogIdFromDOM) {
          console.log("[Milestones] Backlog ID não encontrado, pulando carregamento.");
          milestonesTableBody.innerHTML = `
              <tr>
                  <td colspan="6" class="text-center text-muted small">
                      <i class="bi bi-info-circle me-1"></i> Nenhum backlog selecionado.
                  </td>
              </tr>
          `;
          return;
      }
      
      console.log(`[Milestones] Carregando marcos para Backlog ID: ${currentBacklogIdFromDOM}`);
      
      // Mostra indicador de carregamento
      milestonesTableBody.innerHTML = `
          <tr>
              <td colspan="6" class="text-center text-muted small py-3">
                  <div class="spinner-border spinner-border-sm text-primary me-2" role="status">
                      <span class="visually-hidden">Loading...</span>
                  </div>
                  Carregando marcos...
              </td>
          </tr>
      `;
      
      try {
          const response = await fetch(`/backlog/api/backlogs/${currentBacklogIdFromDOM}/milestones`);
          if (!response.ok) {
              throw new Error(`Erro HTTP: ${response.status}`);
          }
          
          const milestones = await response.json();
          console.log("[Milestones] Marcos recebidos da API:", milestones);
          
          // *** NOVA ABORDAGEM: Converter diretamente os dados da API para HTML ***
          // Limpa a tabela
          milestonesTableBody.innerHTML = '';
          
          // Verifica se há marcos para mostrar
          if (!milestones || milestones.length === 0) {
              milestonesTableBody.innerHTML = `
                  <tr>
                      <td colspan="6" class="text-center text-muted small">
                          <i class="bi bi-info-circle me-1"></i> Nenhum marco definido para este projeto.
                      </td>
                  </tr>
              `;
              console.log("[Milestones] Nenhum marco encontrado para exibir");
              return;
          }
          
          // Para cada marco, cria uma linha na tabela
          milestones.forEach(milestone => {
              try {
                  console.log("[Milestone Process Loop] Processando marco ID:", milestone.id, "Nome:", milestone.name); // Log adicional
                  console.log("[Milestone Process] Processando marco:", milestone);
                  // Define as classes corretas para badges
                  let statusClass = "bg-secondary"; // Default
                  if (milestone.status && milestone.status.toLowerCase() === "concluído") statusClass = "bg-success";
                  else if (milestone.status && milestone.status.toLowerCase() === "em andamento") statusClass = "bg-warning text-dark";
                  else if (milestone.status && milestone.status.toLowerCase() === "atrasado" || milestone.is_delayed) statusClass = "bg-danger";
                  
                  let criticalityClass = "bg-secondary"; // Default
                  if (milestone.criticality && milestone.criticality.toLowerCase() === "crítica") criticalityClass = "bg-danger";
                  else if (milestone.criticality && milestone.criticality.toLowerCase() === "alta") criticalityClass = "bg-warning text-dark";
                  else if (milestone.criticality && milestone.criticality.toLowerCase() === "média") criticalityClass = "bg-info text-dark";
                  
                  // Formata datas
                  const plannedDate = milestone.planned_date ? formatDateString(milestone.planned_date) : "-";
                  const actualDate = milestone.actual_date ? formatDateString(milestone.actual_date) : "-";
                  
                  // Cria uma nova linha
                  const tr = document.createElement('tr');
                  tr.dataset.milestoneId = milestone.id;
                  tr.style.cursor = 'pointer';
                  tr.innerHTML = `
                      <td>${escapeHtml(milestone.name || '')} ${milestone.is_checkpoint ? '<i class="bi bi-patch-check-fill text-primary" title="Checkpoint"></i>' : ''}</td>
                      <td>${plannedDate}</td>
                      <td>${actualDate}</td>
                      <td><span class="badge ${statusClass}">${escapeHtml(milestone.status || 'Pendente')}</span></td>
                      <td><span class="badge ${criticalityClass}">${escapeHtml(milestone.criticality || 'Média')}</span></td>
                      <td>
                          <button class="btn btn-outline-primary btn-sm edit-milestone-btn" title="Editar Marco">
                              <i class="bi bi-pencil-fill"></i>
                          </button>
                          <button class="btn btn-outline-danger btn-sm delete-milestone-btn-inline" title="Excluir Marco">
                              <i class="bi bi-trash-fill"></i>
                          </button>
                      </td>
                  `;
                  
                  // Adiciona a linha �  tabela
                  milestonesTableBody.appendChild(tr);
                  console.log("[Milestone Process] Linha adicionada para marco ID:", milestone.id);
                  
                  // Adiciona event listeners para os botões
                  const editBtn = tr.querySelector('.edit-milestone-btn');
                  if (editBtn) {
                      editBtn.addEventListener('click', (e) => {
                          e.stopPropagation();
                          openMilestoneModal(milestone.id);
                      });
                  }
                  
                  const deleteBtn = tr.querySelector('.delete-milestone-btn-inline');
                  if (deleteBtn) {
                      console.log('[Debug Delete Click] Botão de deletar clicado! Marco ID:', milestone.id, 'Nome:', milestone.name);
                      e.stopPropagation();
                      confirmDeleteMilestone(milestone.id, milestone.name);
                  } else {
                      console.warn("[Milestone Process Loop] Botão delete NÃO encontrado para marco ID:", milestone.id, "HTML da linha:", tr.innerHTML); // Log adicional
                  }
                  
                  // Evento para clicar na linha
                  tr.addEventListener('click', (e) => {
                      if (!e.target.closest('button')) {
                          openMilestoneModal(milestone.id);
                      }
                  });
                  
              } catch (error) {
                  console.error("[Milestone Process] Erro ao processar marco:", milestone, error);
              }
          });
          
          console.log(`[Milestones] Processamento direto concluído. ${milestones.length} marcos adicionados �  tabela.`);
          
      } catch (error) {
          console.error("[Milestones] Erro ao carregar marcos:", error);
          milestonesTableBody.innerHTML = `
              <tr>
                  <td colspan="6" class="text-center text-danger small">
                      <i class="bi bi-exclamation-triangle me-1"></i> Erro ao carregar marcos: ${error.message}
                  </td>
              </tr>
          `;
      }
  }

  // Função para renderizar os marcos na tabela
  function renderMilestones(milestones) {
      if (!milestonesTableBody) {
          console.error("[Milestones] Elemento milestonesTableBody não encontrado no DOM");
          return;
      }
      
      console.log("[Milestones] Renderizando", milestones.length, "marcos", milestones);
      
      // CORREÇÃO: Verificar e converter para array se necessário
      let milestonesArray = milestones;
      if (!Array.isArray(milestones)) {
          try {
              milestonesArray = JSON.parse(milestones);
              console.log("[Milestones] Convertido de string JSON para array:", milestonesArray);
          } catch (e) {
              console.error("[Milestones] Erro ao converter dados de marcos:", e);
              milestonesArray = [];
          }
      }
      
      // Limpa a tabela
      milestonesTableBody.innerHTML = ''; // Limpa a tabela
      
      // CORREÇÃO: Verificação de array vazio revisada
      if (!milestonesArray || milestonesArray.length === 0) {
          milestonesTableBody.innerHTML = `
              <tr>
                  <td colspan="6" class="text-center text-muted small">
                      <i class="bi bi-info-circle me-1"></i> Nenhum marco definido para este projeto.
                  </td>
              </tr>
          `;
          console.log("[Milestones] Nenhum marco encontrado para exibir");
          return;
      }

      // CORREÇÃO: Abordagem simplificada para garantir que funcione
      console.log("[Milestones] Tentando abordagem direta para renderização");
      
      // Cria uma string HTML com todas as linhas
      let rowsHtml = '';
      
      milestonesArray.forEach((milestone, index) => {
          try {
              // Status e criticidade
              let statusClass = "bg-secondary"; // Default
              if (milestone.status && milestone.status.toLowerCase() === "concluído") statusClass = "bg-success";
              else if (milestone.status && milestone.status.toLowerCase() === "em andamento") statusClass = "bg-primary";
              else if (milestone.status && milestone.status.toLowerCase() === "atrasado" || milestone.is_delayed) statusClass = "bg-danger";
              
              let criticalityClass = "bg-secondary"; // Default
              if (milestone.criticality && milestone.criticality.toLowerCase() === "crítica") criticalityClass = "bg-danger";
              else if (milestone.criticality && milestone.criticality.toLowerCase() === "alta") criticalityClass = "bg-warning text-dark";
              else if (milestone.criticality && milestone.criticality.toLowerCase() === "média") criticalityClass = "bg-info text-dark";
              
              // Formata datas
              const plannedDate = milestone.planned_date ? formatDateString(milestone.planned_date) : "-";
              const actualDate = milestone.actual_date ? formatDateString(milestone.actual_date) : "-";
              
              // Cria linha HTML
              rowsHtml += `
                  <tr data-milestone-id="${milestone.id}">
                      <td>${escapeHtml(milestone.name)} ${milestone.is_checkpoint ? '<i class="bi bi-patch-check-fill text-primary" title="Checkpoint"></i>' : ''}</td>
                      <td>${plannedDate}</td>
                      <td>${actualDate}</td>
                      <td><span class="badge ${statusClass}">${escapeHtml(milestone.status || 'Pendente')}</span></td>
                      <td><span class="badge ${criticalityClass}">${escapeHtml(milestone.criticality || 'Média')}</span></td>
                      <td>
                          <button class="btn btn-outline-primary btn-sm edit-milestone-btn" title="Editar Marco">
                              <i class="bi bi-pencil-fill"></i>
                          </button>
                          <button class="btn btn-outline-danger btn-sm delete-milestone-btn-inline" title="Excluir Marco">
                              <i class="bi bi-trash-fill"></i>
                          </button>
                      </td>
                  </tr>
              `;
          } catch (error) {
              console.error(`[Milestones] Erro ao processar marco ${index}:`, milestone, error);
              // Continua para o próximo marco em caso de erro
          }
      });
      
      // CORREÇÃO: Define o HTML completo de uma vez
      milestonesTableBody.innerHTML = rowsHtml;
      
      // CORREÇÃO: Adiciona eventos depois de inserir o HTML
      document.querySelectorAll('tr[data-milestone-id]').forEach(tr => {
          const milestoneId = tr.dataset.milestoneId;
          
          // Evento para editar ao clicar na linha (exceto nos botões)
          tr.addEventListener('click', (e) => {
              if (!e.target.closest('button')) {
                  openMilestoneModal(milestoneId);
              }
          });
          
          // Evento para botão editar
          const editBtn = tr.querySelector('.edit-milestone-btn');
          if (editBtn) {
              editBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  openMilestoneModal(milestoneId);
              });
          }
          
          // Evento para botão excluir
          const deleteBtn = tr.querySelector('.delete-milestone-btn-inline');
          if (deleteBtn) {
              console.log('[Debug Delete Click] Botão de deletar clicado! Marco ID:', milestone.id, 'Nome:', milestone.name);
              e.stopPropagation();
              confirmDeleteMilestone(milestone.id, milestone.name);
          }
      });
      
      console.log("[Milestones] Renderização concluída com sucesso. Marcos renderizados:", milestonesArray.length);
  }

  // Função para abrir o modal de marco (criar ou editar)
  function openMilestoneModal(milestoneId = null) {
      if (!milestoneModal || !milestoneForm) {
          console.error("[Modal Open] Elementos do modal não encontrados");
          return;
      }
      
      console.log("[Modal Open] Abrindo modal de marco para ID:", milestoneId);
      milestoneForm.reset(); // Limpa o formulário
      milestoneIdInput.value = milestoneId || ''; // Define ou limpa o ID
      showModalLoading(milestoneModalElement, false); // Esconde loading

      if (milestoneId) {
          // --- Modo Edição ---
          milestoneModalTitle.textContent = 'Editar Marco';
          deleteMilestoneBtn.style.display = 'block'; // Mostra botão excluir
          
          // CORREÇÃO: Busca os dados do marco na lista completa
          showModalLoading(milestoneModalElement, true);
          
          // Obter valor atualizado do backlog ID diretamente do DOM
          const currentBacklogIdFromDOM = document.getElementById('currentBacklogId')?.value;
          
          if (!currentBacklogIdFromDOM) {
              console.error("[Modal Open] Backlog ID não encontrado, não é possível buscar marcos");
              showModalLoading(milestoneModalElement, false);
              showToast('Erro: ID do backlog não encontrado', 'error');
              milestoneModal.hide();
              return;
          }
          
          console.log(`[Modal Open] Buscando todos os marcos do backlog ${currentBacklogIdFromDOM} para filtrar ID ${milestoneId}`);
          
          // Busca todos os marcos e filtra pelo ID desejado
          fetch(`/backlog/api/backlogs/${currentBacklogIdFromDOM}/milestones`)
              .then(response => {
                  if (!response.ok) {
                      console.error(`[Modal Open] Erro ${response.status} ao buscar marcos`);
                      throw new Error(`Erro ao buscar lista de marcos (${response.status})`);
                  }
                  return response.json();
              })
              .then(allMilestones => {
                  console.log(`[Modal Open] Recebidos ${allMilestones.length} marcos, buscando ID ${milestoneId}`, allMilestones);
                  
                  // Filtra pelo ID específico (garantindo conversão para número)
                  const milestone = allMilestones.find(m => Number(m.id) === Number(milestoneId));
                  
                  if (!milestone) {
                      console.error(`[Modal Open] Marco ID ${milestoneId} não encontrado na lista de ${allMilestones.length} marcos`);
                      throw new Error(`Marco ID ${milestoneId} não encontrado na lista`);
                  }
                  
                  console.log("[Modal Open] Marco encontrado para edição:", milestone);
                  
                  // Preenche o formulário com os dados do marco
                  document.getElementById('milestoneName').value = milestone.name || '';
                  document.getElementById('milestoneDescription').value = milestone.description || '';
                  document.getElementById('milestonePlannedDate').value = milestone.planned_date ? milestone.planned_date.substring(0, 10) : '';
                  document.getElementById('milestoneActualDate').value = milestone.actual_date ? milestone.actual_date.substring(0, 10) : '';
                  document.getElementById('milestoneStatus').value = milestone.status || 'Pendente';
                  document.getElementById('milestoneCriticality').value = milestone.criticality || 'Média';
                  document.getElementById('milestoneIsCheckpoint').checked = milestone.is_checkpoint || false;
                  
                  showModalLoading(milestoneModalElement, false);
              })
              .catch(error => {
                  console.error('[Modal Open] Erro ao buscar detalhes do marco:', error);
                  showModalLoading(milestoneModalElement, false);
                  showToast('Erro ao carregar detalhes do marco: ' + error.message, 'error');
                  milestoneModal.hide(); // Fecha o modal se não conseguir carregar
              });
              
      } else {
          // --- Modo Criação ---
          console.log("[Modal Open] Modo criação - formulário limpo");
          milestoneModalTitle.textContent = 'Adicionar Marco';
          deleteMilestoneBtn.style.display = 'none'; // Esconde botão excluir
          // Valores padrão (já definidos no reset ou no HTML)
      }
      
      milestoneModal.show();
  }

  // Adicionar a função formatDateString que estava faltando
  function formatDateString(dateStr) {
      if (!dateStr) return "-";
      try {
          // Se vier no formato 'YYYY-MM-DD', tratar como local
          if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
              const [year, month, day] = dateStr.split('-');
              // Mês no JS é 0-based!
              const date = new Date(Number(year), Number(month) - 1, Number(day));
              return date.toLocaleDateString('pt-BR', {day: '2-digit', month: '2-digit', year: 'numeric'});
          }
          // Caso contrário, tenta o padrão normal
          const date = new Date(dateStr);
          if (isNaN(date.getTime())) return dateStr;
          return date.toLocaleDateString('pt-BR', {day: '2-digit', month: '2-digit', year: 'numeric'});
      } catch (e) {
          console.error("Erro ao formatar data:", e, dateStr);
          return dateStr;
      }
  }

  // Função para confirmar e excluir um marco
  function confirmDeleteMilestone(milestoneId, milestoneName) {
      if (!milestoneId) {
          console.error("[Delete Milestone] ID do marco não fornecido");
          return;
      }
      
      const confirmMessage = `Tem certeza que deseja excluir o marco "${milestoneName || milestoneId}"?`;
      if (confirm(confirmMessage)) {
          console.log(`[Delete Milestone] Confirmado. Excluindo marco ID: ${milestoneId}`);
          deleteMilestone(milestoneId);
      } else {
          console.log(`[Delete Milestone] Exclusão cancelada pelo usuário para ID: ${milestoneId}`);
      }
  }

  // Função para excluir um marco via API
  async function deleteMilestone(milestoneId) {
      try {
          console.log(`[Delete Milestone] Enviando requisição DELETE para marco ID: ${milestoneId}`);
          const response = await fetch(`/backlog/api/milestones/${milestoneId}`, {
              method: 'DELETE',
              headers: {'Content-Type': 'application/json'}
          });
          
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
          }
          
          console.log('[Delete Milestone] Marco excluído com sucesso');
          showToast('Marco excluído com sucesso!', 'success');
          
          // Recarrega a lista de marcos
          loadMilestones();
          
          // Fecha o modal se estiver aberto
          if (milestoneModal) {
              milestoneModal.hide();
          }
      } catch (error) {
          console.error('[Delete Milestone] Erro:', error);
          showToast(`Erro ao excluir marco: ${error.message}`, 'error');
      }
  }

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  // Função para carregar e atualizar tarefas na linha do tempo
  function updateTimelineTasks() {
    console.log("[Timeline] Iniciando carregamento de tarefas da linha do tempo...");
    
    // Elementos DOM para as listas
    const completedTasksList = document.getElementById('completedTasksList');
    const upcomingTasksList = document.getElementById('upcomingTasksList');
    const startedTasksList = document.getElementById('startedTasksList');
    
    if (!completedTasksList || !upcomingTasksList || !startedTasksList) {
        console.error("[Timeline] Elementos de lista não encontrados no DOM");
        return;
    }
    
    // Indicar carregamento
    completedTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    upcomingTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    startedTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    
    // Obter ID do backlog atual
    const backlogId = document.getElementById('currentBacklogId')?.value;
    if (!backlogId) {
        console.warn("[Timeline] Nenhum backlog ID encontrado");
        const emptyMessage = '<li class="list-group-item text-center text-muted small">Nenhum backlog associado a este projeto</li>';
        completedTasksList.innerHTML = emptyMessage;
        upcomingTasksList.innerHTML = emptyMessage;
        startedTasksList.innerHTML = emptyMessage;
        return;
    }
    
    // Fazer a requisição à API
    fetch(`/backlog/api/backlogs/${backlogId}/timeline-tasks`)
        .then(response => {
            if (!response.ok) {
                return response.json().then(errorData => {
                    throw new Error(errorData.error || `Status: ${response.status}`);
                }).catch(e => {
                    throw new Error(`Erro HTTP ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("[Timeline] Dados recebidos:", data);
            
            // Verificar se há mensagem de erro na resposta
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Renderizar tarefas concluídas recentemente
            renderTasksList(completedTasksList, data.recently_completed, 'check-circle-fill', 'text-success', 'Nenhuma tarefa concluída recentemente');
            
            // Renderizar próximas tarefas
            renderTasksList(upcomingTasksList, data.upcoming_tasks, 'calendar-event-fill', 'text-warning', 'Nenhuma tarefa com prazo próximo');
            
            // Renderizar tarefas iniciadas recentemente
            renderTasksList(startedTasksList, data.recently_started, 'play-circle-fill', 'text-primary', 'Nenhuma tarefa iniciada recentemente');
        })
        .catch(error => {
            console.error("[Timeline] Erro ao carregar tarefas da linha do tempo:", error);
            
            // Usar o endpoint de diagnóstico em caso de erro
            fetch(`/backlog/api/debug/timeline-tasks/${backlogId}`)
                .then(diagResponse => diagResponse.json())
                .then(diagData => {
                    console.log("[Timeline] Diagnóstico:", diagData);
                    // Mostrar erro mais específico com base no diagnóstico
                    const errorDetail = diagData.error 
                        ? `<div class="mt-1">${diagData.error}</div>` 
                        : `<div class="mt-1 small">Diagnóstico concluído, verifique o console.</div>`;
                        
                    const errorMessage = `
                        <li class="list-group-item text-center text-danger">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>Erro ao carregar tarefas</strong>
                            <div class="small mt-1">${error.message}</div>
                            ${errorDetail}
                        </li>`;
                        
                    completedTasksList.innerHTML = errorMessage;
                    upcomingTasksList.innerHTML = errorMessage;
                    startedTasksList.innerHTML = errorMessage;
                })
                .catch(diagError => {
                    // Caso o diagnóstico também falhe
                    const errorMessage = `
                        <li class="list-group-item text-center text-danger">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>Erro ao carregar tarefas</strong>
                            <div class="mt-1 small">${error.message}</div>
                            <div class="mt-1 small">Diagnóstico falhou: ${diagError.message}</div>
                        </li>`;
                        
                    completedTasksList.innerHTML = errorMessage;
                    upcomingTasksList.innerHTML = errorMessage;
                    startedTasksList.innerHTML = errorMessage;
                });
        });
  }

  // Função auxiliar para renderizar uma lista de tarefas
  function renderTasksList(listElement, tasks, iconClass, iconColorClass, emptyMessage) {
    if (!tasks || tasks.length === 0) {
        listElement.innerHTML = `<li class="list-group-item text-center text-muted small"><i class="bi bi-info-circle me-2"></i>${emptyMessage}</li>`;
        return;
    }
    
    let html = '';
    tasks.forEach(task => {
        // Formatar data relevante (conclusão, prazo ou início)
        let dateStr = '';
        let dateLabel = '';
        let secondDateStr = '';
        
        if (task.completed_at) {
            dateStr = formatDateString(task.completed_at);
            dateLabel = 'Concluído em';
        } else if (listElement.id === 'upcomingTasksList') {
            // Para próximas tarefas, mostrar tanto início quanto prazo
            let startDateStr = task.start_date ? formatDateString(task.start_date) : '-';
            let dueDateStr = task.due_date ? formatDateString(task.due_date) : '-';
            dateStr = `<span class="small me-2" title="Data de início"><i class="bi bi-calendar-event"></i> ${startDateStr}</span>
                      <span class="small" title="Prazo final"><i class="bi bi-calendar-check"></i> ${dueDateStr}</span>`;
            dateLabel = ''; // Vazio pois já incluímos ícones explicativos
        } else if (task.due_date) {
            dateStr = formatDateString(task.due_date);
            dateLabel = 'Prazo';
        } else if (task.start_date) {
            dateStr = formatDateString(task.start_date);
            dateLabel = 'Iniciado em';
        }
        
        // Determinar ícone de prioridade
        let priorityBadge = '';
        if (task.priority) {
            let priorityClass = 'bg-secondary';
            if (task.priority === 'Alta') priorityClass = 'bg-warning text-dark';
            if (task.priority === 'Urgente') priorityClass = 'bg-danger';
            priorityBadge = `<span class="badge ${priorityClass} me-2">${task.priority}</span>`;
        }
        
        // Criar HTML do item da lista
        html += `
            <li class="list-group-item d-flex justify-content-between align-items-center p-2 task-item" 
                data-task-id="${task.id}" data-bs-toggle="tooltip" title="${escapeHtml(task.description || 'Sem descrição')}">
                <div>
                    <i class="bi bi-${iconClass} ${iconColorClass} me-2"></i>
                    ${priorityBadge}
                    <span class="task-title">${escapeHtml(task.title)}</span>
                </div>
                <div class="text-muted small">
                    ${dateLabel ? `<span class="date-label">${dateLabel}:</span> ` : ''}${dateStr}
                </div>
            </li>
        `;
    });
    
    listElement.innerHTML = html;
    
    // Adicionar evento de clique para editar a tarefa
    listElement.querySelectorAll('.task-item').forEach(item => {
        item.addEventListener('click', () => {
            const taskId = item.dataset.taskId;
            console.log(`[Timeline] Clique na tarefa ID: ${taskId}`);
            // Usar handleTaskClick em vez de editTask
            const taskCard = document.querySelector(`.kanban-task-card[data-task-id="${taskId}"]`);
            if (taskCard) {
                handleTaskClick({currentTarget: taskCard});
            } else {
                console.warn(`[Timeline] Não encontrou taskCard para ID: ${taskId}`);
            }
        });
    });
  }

  // --- Set up initial listeners and page state --- 
  document.addEventListener('DOMContentLoaded', function() {
      console.log("Board DOM loaded");
      
      // Todo o código DOMContentLoaded existente aqui...
      
      // Inicializar a linha do tempo após um breve atraso
      setTimeout(updateTimelineTasks, 1500);
  });

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  // --- Funções Essenciais de Renderização (Definidas fora do DOMContentLoaded) ---
  // (Inclui renderTasks, clearBoard, escapeHtml, etc.)

  // --- LÓGICA PARA RISCOS DO PROJETO ---
  let risksTableBody, addRiskBtn, riskModalElement, riskModal, riskForm, riskModalLabel, currentEditingRiskId = null; // Definir aqui, atribuir em DOMContentLoaded

  function formatDateForDisplay(dateStr) {
      if (!dateStr) return "-";
      try {
          const date = new Date(dateStr);
          // Adiciona verificação se a data é válida, pois new Date(null) ou new Date('') podem não dar erro mas resultar em datas inválidas.
          if (isNaN(date.getTime())) return dateStr; // Retorna a string original se a data for inválida
          return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
      } catch (e) {
          console.error("Erro ao formatar data para exibição:", e, dateStr);
          return dateStr; // Retorna string original em caso de erro
      }
  }

  function renderRisks(risks = []) {
      if (!risksTableBody) {
          console.error("[Riscos] Elemento risksTableBody não encontrado.");
          return;
      }
      risksTableBody.innerHTML = ''; // Limpa a tabela

      if (!risks || risks.length === 0) {
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Nenhum risco cadastrado para este backlog.</td></tr>`;
          return;
      }

      risks.forEach(risk => {
          const tr = document.createElement('tr');
          tr.dataset.riskId = risk.id;

          // Adaptação para severidade e status, pode precisar de badges como em milestones
          let severityBadge = risk.severity || 'N/A';
          if (risk.severity === 'Crítico') severityBadge = `<span class="badge bg-danger">${risk.severity}</span>`;
          else if (risk.severity === 'Alto') severityBadge = `<span class="badge bg-warning text-dark">${risk.severity}</span>`;
          else if (risk.severity === 'Médio') severityBadge = `<span class="badge bg-info text-dark">${risk.severity}</span>`;
          else if (risk.severity === 'Baixo') severityBadge = `<span class="badge bg-secondary">${risk.severity}</span>`;
          
          let statusBadge = risk.status || 'N/A';
          if (risk.status === 'Ativo') statusBadge = `<span class="badge bg-warning text-dark">${risk.status}</span>`;
          else if (risk.status === 'Mitigado') statusBadge = `<span class="badge bg-info text-dark">${risk.status}</span>`;
          else if (risk.status === 'Resolvido') statusBadge = `<span class="badge bg-success">${risk.status}</span>`;

          tr.innerHTML = `
              <td style="white-space: pre-wrap; word-break: break-word;">${escapeHtml(risk.description)}</td>
              <td class="text-center">${severityBadge}</td>
              <td class="text-center">${statusBadge}</td>
              <td class="text-center">
                  <button class="btn btn-outline-primary btn-sm edit-risk-btn" title="Editar Risco" data-risk-id="${risk.id}">
                      <i class="bi bi-pencil-fill"></i>
                  </button>
                  <button class="btn btn-outline-danger btn-sm delete-risk-btn-inline" title="Excluir Risco" data-risk-id="${risk.id}">
                      <i class="bi bi-trash-fill"></i>
                  </button>
              </td>
          `;
          risksTableBody.appendChild(tr);

          // Adicionar listeners para botões de editar/excluir (a serem implementados)
          const editButton = tr.querySelector('.edit-risk-btn');
          if (editButton) {
              editButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Previne que o clique na linha também dispare algo, se houver
                  openRiskModal(risk.id);
              });
          }
          const deleteButtonInline = tr.querySelector('.delete-risk-btn-inline');
          if (deleteButtonInline) {
              deleteButtonInline.addEventListener('click', (e) => {
                  console.log('[Debug Risk Delete Click] Botão Inline DELETAR RISCO clicado! Risco ID:', risk.id, 'Descrição:', risk.description);
                  e.stopPropagation();
                  confirmDeleteRisk(risk.id, risk.description); // CHAMADA CORRIGIDA
              });
          }
          // tr.querySelector('.delete-risk-btn-inline').addEventListener('click', () => confirmDeleteRisk(risk.id, risk.description));
      });
      console.log(`[Riscos] ${risks.length} riscos renderizados.`);
  }

  async function loadRisks() {
      if (!risksTableBody) {
          console.error("[Riscos] Tentando carregar riscos, mas risksTableBody não foi encontrado.");
          return;
      }
      const currentBacklogId = document.getElementById('currentBacklogId')?.value;
      if (!currentBacklogId) {
          console.log("[Riscos] ID do Backlog não encontrado, pulando carregamento de riscos.");
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Selecione um backlog para ver os riscos.</td></tr>`;
          return;
      }

      console.log(`[Riscos] Carregando riscos para Backlog ID: ${currentBacklogId}`);
      risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small py-3"><div class="spinner-border spinner-border-sm text-primary me-2"></div>Carregando riscos...</td></tr>`;

      try {
          const response = await fetch(`/backlog/api/backlogs/${currentBacklogId}/risks`); // <-- ADICIONAR /backlog AQUI
          if (!response.ok) {
              let errorMsg = `Erro HTTP: ${response.status}`;
              try {
                  const errorData = await response.json();
                  errorMsg = errorData.message || errorData.description || errorMsg;
              } catch (e) { /* Ignora erro no parse do JSON de erro */ }
              throw new Error(errorMsg);
          }
          const risks = await response.json();
          console.log("[Riscos] Riscos recebidos da API:", risks);
          renderRisks(risks);
      } catch (error) {
          console.error("[Riscos] Erro ao carregar riscos:", error);
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-danger small"><i class="bi bi-exclamation-triangle-fill me-1"></i>Erro ao carregar riscos: ${error.message}</td></tr>`;
      }
  }

  // Adicionar listener para o botão "Novo Risco" (a ser implementado)
  // if (addRiskBtn) {
  //     addRiskBtn.addEventListener('click', () => openRiskModal()); 
  // }
  
  // Função para abrir modal de risco (a ser implementada)
  async function openRiskModal(riskId = null) { // <-- ADICIONADO ASYNC AQUI
    if (!riskModal || !riskForm || !riskModalLabel) {
        console.error("[Risk Modal] Elementos do modal de risco não encontrados (modal, form ou label).");
        return;
    }
    riskForm.reset(); 
    // const riskIdInput = riskForm.querySelector('input[name="riskId"]'); // Exemplo se tivesse um input hidden para ID
    // if(riskIdInput) riskIdInput.value = riskId || '';

    if (riskId) {
        riskModalLabel.textContent = 'Editar Risco';
        currentEditingRiskId = riskId; // Guarda o ID do risco que está sendo editado
        // TODO: Mostrar botão de excluir (se houver um)

        // Busca dados do risco para popular o formulário
        // Adiciona feedback de loading no modal ANTES de buscar
        const formFields = riskForm.elements;
        for (let i = 0; i < formFields.length; i++) {
            formFields[i].disabled = true;
        }
        riskModalLabel.innerHTML = '<i class="spinner-border spinner-border-sm"></i> Carregando Risco...'; 

        try {
            const response = await fetch(`/backlog/api/risks/${riskId}`);
            if (!response.ok) {
                let errorMsg = `Erro ao carregar dados do risco: ${response.status}`;
                try { const errData = await response.json(); errorMsg = errData.message || errData.description || errorMsg; } catch(e){}
                throw new Error(errorMsg);
            }
            const riskData = await response.json();
            console.log("[Risk Modal] Dados do risco para edição:", riskData);

            // Popula o formulário
            if(riskForm.querySelector('#riskDescription')) riskForm.querySelector('#riskDescription').value = riskData.description || '';
            if(riskForm.querySelector('#riskImpact')) riskForm.querySelector('#riskImpact').value = riskData.impact || 'Médio';
            if(riskForm.querySelector('#riskProbability')) riskForm.querySelector('#riskProbability').value = riskData.probability || 'Média';
            if(riskForm.querySelector('#riskStatus')) riskForm.querySelector('#riskStatus').value = riskData.status || 'Ativo';
            if(riskForm.querySelector('#riskResponsible')) riskForm.querySelector('#riskResponsible').value = riskData.responsible || '';
            if(riskForm.querySelector('#riskMitigationPlan')) riskForm.querySelector('#riskMitigationPlan').value = riskData.mitigation_plan || '';
            if(riskForm.querySelector('#riskContingencyPlan')) riskForm.querySelector('#riskContingencyPlan').value = riskData.contingency_plan || '';
            if(riskForm.querySelector('#riskTrend')) riskForm.querySelector('#riskTrend').value = riskData.trend || 'Estável';
            
            riskModalLabel.textContent = 'Editar Risco'; // Restaura o título

        } catch (error) {
            console.error("[Risk Modal] Erro ao buscar dados do risco para edição:", error);
            alert(error.message); // Mostra erro
            riskModal.hide(); // Fecha o modal se não conseguir carregar
        } finally {
            // Reabilita os campos do formulário após carregar (ou falhar)
            for (let i = 0; i < formFields.length; i++) {
                formFields[i].disabled = false;
            }
            // Se o título ainda estiver como loading, restaura para Editar Risco
            if (riskModalLabel.textContent.includes('Carregando')) {
                 riskModalLabel.textContent = 'Editar Risco';
            }
        }
    } else { // Modo Criação
        riskModalLabel.textContent = 'Adicionar Novo Risco';
        currentEditingRiskId = null;
        // TODO: Garantir que o botão de excluir esteja escondido
    }
    riskModal.show();
  }
  
  if (riskForm) {
    riskForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("[Risk Form Submit ENTRY] currentEditingRiskId at start:", currentEditingRiskId); // NOVO LOG AQUI

        const currentBacklogId = document.getElementById('currentBacklogId')?.value;
        if (!currentBacklogId) {
            alert("Erro: ID do Backlog não encontrado. Não é possível adicionar o risco.");
            return;
        }
        // const hiddenRiskId = this.querySelector('input[name="riskId"]')?.value; // Para edição futura
        // const isEditing = !!hiddenRiskId;

        const isEditing = !!currentEditingRiskId; // Usa a variável global para verificar se está editando

        const riskData = {
            backlog_id: parseInt(currentBacklogId, 10),
            description: this.querySelector('#riskDescription')?.value,
            impact: this.querySelector('#riskImpact')?.value || 'Médio', 
            probability: this.querySelector('#riskProbability')?.value || 'Média',
            status: this.querySelector('#riskStatus')?.value || 'Ativo', // ID do select no modal de risco
            responsible: this.querySelector('#riskResponsible')?.value || null, 
            mitigation_plan: this.querySelector('#riskMitigationPlan')?.value || null,
            contingency_plan: this.querySelector('#riskContingencyPlan')?.value || null,
            trend: this.querySelector('#riskTrend')?.value || 'Estável'
        };

        // Remover backlog_id do payload se estiver editando, pois a API PUT não o espera no corpo.
        if (isEditing) {
            delete riskData.backlog_id;
        }

        console.log("[Risk Form Submit] currentEditingRiskId:", currentEditingRiskId);
        console.log("[Risk Form Submit] isEditing Flag:", isEditing);
        console.log("[Risk Form Submit] Dados do risco a enviar (payload):", JSON.parse(JSON.stringify(riskData))); // Log profundo da cópia

        const url = isEditing ? `/backlog/api/risks/${currentEditingRiskId}` : '/backlog/api/risks';
        const method = isEditing ? 'PUT' : 'POST';
        
        console.log(`[Risk Form Submit] URL: ${url}, METHOD: ${method}`);

        // Adiciona feedback de loading no modal
        const submitButton = riskForm.querySelector('button[type="submit"]');
        const originalButtonText = submitButton ? submitButton.innerHTML : 'Salvar Risco';
        if(submitButton) {
            submitButton.disabled = true;
            submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Salvando...';
        }

        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(riskData)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`;
                try {
                    const errorDetail = await response.json();
                    errorMsg = errorDetail.message || errorDetail.description || errorMsg;
                } catch (e) { /* Ignora se não conseguir parsear JSON do erro */ }
                throw new Error(errorMsg);
            }

            const savedRisk = await response.json();
            console.log("[Risk Form Submit] Risco salvo:", savedRisk);
            riskModal.hide();
            loadRisks(); // Recarrega a lista de riscos
            alert(isEditing ? 'Risco atualizado com sucesso!' : 'Risco adicionado com sucesso!'); // Placeholder para toast

        } catch (error) {
            console.error(`[Risk Form Submit] Erro ao ${isEditing ? 'atualizar' : 'salvar'} risco:`, error);
            alert(`Erro ao ${isEditing ? 'atualizar' : 'salvar'} risco: ${error.message}`); // Placeholder para erro no modal/toast
        } finally {
            if(submitButton) { // Restaura o botão
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonText;
            }
        }
    });
  }
  
  // Função para confirmar e excluir risco (a ser implementada)
  // function confirmDeleteRisk(riskId, riskDescription) { ... }

  // --- FIM DA LÓGICA PARA RISCOS DO PROJETO ---

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  document.addEventListener('DOMContentLoaded', function() {
      console.log("Board DOM loaded");
      
      // Atribuição dos elementos de Risco aqui
      risksTableBody = document.getElementById('risksTableBody');
      addRiskBtn = document.getElementById('addRiskBtn');
      riskModalElement = document.getElementById('riskModal');
      if (riskModalElement) { // Verifica se o modal existe antes de tentar usá-lo
          riskModal = new bootstrap.Modal(riskModalElement);
          riskForm = riskModalElement.querySelector('form#riskForm'); // Busca pelo ID do form
          riskModalLabel = riskModalElement.querySelector('.modal-title#riskModalLabel');

          if (addRiskBtn) {
              addRiskBtn.addEventListener('click', () => openRiskModal()); 
          }

          if (riskForm) {
            riskForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                console.log("[Risk Form Submit ENTRY] currentEditingRiskId at start:", currentEditingRiskId); // NOVO LOG AQUI

                const currentBacklogId = document.getElementById('currentBacklogId')?.value;
                if (!currentBacklogId) {
                    alert("Erro: ID do Backlog não encontrado. Não é possível adicionar o risco.");
                    return;
                }
                // const hiddenRiskId = this.querySelector('input[name="riskId"]')?.value; // Para edição futura
                // const isEditing = !!hiddenRiskId;

                const isEditing = !!currentEditingRiskId; // Usa a variável global para verificar se está editando

                const riskData = {
                    backlog_id: parseInt(currentBacklogId, 10),
                    description: this.querySelector('#riskDescription')?.value,
                    impact: this.querySelector('#riskImpact')?.value || 'Médio', 
                    probability: this.querySelector('#riskProbability')?.value || 'Média',
                    status: this.querySelector('#riskStatus')?.value || 'Ativo', // ID do select no modal de risco
                    responsible: this.querySelector('#riskResponsible')?.value || null, 
                    mitigation_plan: this.querySelector('#riskMitigationPlan')?.value || null,
                    contingency_plan: this.querySelector('#riskContingencyPlan')?.value || null,
                    trend: this.querySelector('#riskTrend')?.value || 'Estável'
                };

                // Remover backlog_id do payload se estiver editando, pois a API PUT não o espera no corpo.
                if (isEditing) {
                    delete riskData.backlog_id;
                }

                console.log("[Risk Form Submit] currentEditingRiskId:", currentEditingRiskId);
                console.log("[Risk Form Submit] isEditing Flag:", isEditing);
                console.log("[Risk Form Submit] Dados do risco a enviar (payload):", JSON.parse(JSON.stringify(riskData))); // Log profundo da cópia

                const url = isEditing ? `/backlog/api/risks/${currentEditingRiskId}` : '/backlog/api/risks';
                const method = isEditing ? 'PUT' : 'POST';
                
                console.log(`[Risk Form Submit] URL: ${url}, METHOD: ${method}`);

                // Adiciona feedback de loading no modal
                const submitButton = riskForm.querySelector('button[type="submit"]');
                const originalButtonText = submitButton ? submitButton.innerHTML : 'Salvar Risco';
                if(submitButton) {
                    submitButton.disabled = true;
                    submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Salvando...';
                }

                try {
                    const response = await fetch(url, {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(riskData)
                    });

                    if (!response.ok) {
                        let errorMsg = `Erro ${response.status}`;
                        try {
                            const errorDetail = await response.json();
                            errorMsg = errorDetail.message || errorDetail.description || errorMsg;
                        } catch (e) { /* Ignora se não conseguir parsear JSON do erro */ }
                        throw new Error(errorMsg);
                    }

                    const savedRisk = await response.json();
                    console.log("[Risk Form Submit] Risco salvo:", savedRisk);
                    if (riskModal) riskModal.hide(); // Verifica se riskModal está definido
                    loadRisks(); 
                    alert('Risco adicionado com sucesso!');

                } catch (error) {
                    console.error(`[Risk Form Submit] Erro ao salvar risco:`, error);
                    alert(`Erro ao salvar risco: ${error.message}`);
                } finally {
                    if(submitButton) {
                        submitButton.disabled = false;
                        submitButton.innerHTML = originalButtonText;
                    }
                }
            });
          } else {
              console.warn("[Riscos] Formulário #riskForm não encontrado no modal de risco.");
          }
      } else {
          console.warn("[Riscos] Modal #riskModal não encontrado no DOM.");
      }
      
      loadMilestones();
      loadRisks(); 
      
      setTimeout(updateTimelineTasks, 1500);
  });

  // Função para confirmar e excluir um RISCO
  function confirmDeleteRisk(riskId, riskDescription) {
      if (!riskId) {
          console.error("[Confirm Delete Risk] ID do risco não fornecido.");
          showToast("Erro: ID do risco não informado para exclusão.", "error");
          return;
      }
      const userConfirmed = confirm(`Tem certeza que deseja excluir o risco "${riskDescription || riskId}"? Esta ação não pode ser desfeita.`);
      if (userConfirmed) {
          console.log(`[Confirm Delete Risk] Usuário confirmou exclusão do Risco ID: ${riskId}`);
          deleteRisk(riskId);
      } else {
          console.log(`[Confirm Delete Risk] Usuário cancelou exclusão do Risco ID: ${riskId}`);
      }
  }

  // Função para excluir um RISCO via API
  async function deleteRisk(riskId) {
      if (!riskId) {
          console.error("[Delete Risk API] ID do risco não fornecido para a API.");
          showToast("Erro interno: ID do risco ausente para exclusão via API.", "error");
          return;
      }
      console.log(`[Delete Risk API] Enviando requisição DELETE para Risco ID: ${riskId}`);
      // Adicionar feedback de loading (ex: no modal se aplicável, ou um overlay geral)
      // showLoadingFeedback(true); // Exemplo, adaptar para o contexto de riscos

      try {
          const response = await fetch(`/backlog/api/risks/${riskId}`, {
              method: 'DELETE',
              headers: {'Content-Type': 'application/json'}
          });

          if (!response.ok) {
              let errorMsg = `Erro HTTP ${response.status} ao excluir risco.`;
              try {
                  const errorData = await response.json();
                  errorMsg = errorData.message || errorData.error || errorMsg;
              } catch (e) { /* Ignora erro no parse do JSON de erro */ }
              throw new Error(errorMsg);
          }

          console.log(`[Delete Risk API] Risco ID: ${riskId} excluído com sucesso da API.`);
          showToast("Risco excluído com sucesso!", "success");

          // Atualizar a UI: Remover a linha da tabela e recarregar a lista de riscos
          // Ou apenas remover a linha específica:
          const riskRow = risksTableBody.querySelector(`tr[data-risk-id="${riskId}"]`);
          if (riskRow) {
              riskRow.remove();
              console.log(`[Delete Risk API] Linha do Risco ID: ${riskId} removida da tabela.`);
              // Verificar se a tabela ficou vazia
              if (risksTableBody.querySelectorAll('tr').length === 0) {
                  risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Nenhum risco cadastrado para este backlog.</td></tr>`;
              }
          } else {
              console.warn(`[Delete Risk API] Não foi possível encontrar a linha do Risco ID: ${riskId} para remover. Recarregando toda a lista.`);
              loadRisks(); // Fallback para recarregar tudo se a linha não for encontrada
          }
          
          // Se o modal de edição de risco estiver aberto e for o risco excluído, feche-o.
          if (riskModal && currentEditingRiskId == riskId) {
             riskModal.hide();
             currentEditingRiskId = null;
          }

      } catch (error) {
          console.error('[Delete Risk API] Erro ao excluir risco:', error);
          showToast(`Erro ao excluir risco: ${error.message}`, "error");
      } finally {
          // Esconder feedback de loading
          // showLoadingFeedback(false); // Exemplo
      }
  }

</script>

{% endblock %}

