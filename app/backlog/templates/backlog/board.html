{% extends 'base.html' %} {# Ou o seu template base principal #}

{% block title %}Quadro de Backlog - {{ current_project.name if current_project else 'Projeto' }} {% endblock %}

{% block head %}
{{ super() }}
{# CSS movido para extra_css para maior especificidade #}
{% endblock %}

{# --- Bloco para CSS Específico da Página --- #}
{% block extra_css %}
<style>
  /* --- Ajustes Gerais --- */
  .kanban-board-wrapper .card {
      /* Remover sombra dupla se o wrapper já tiver sombra */
      box-shadow: none; 
  }
  .kanban-board-wrapper .card-body {
      padding: 1rem 1.25rem; /* Leve ajuste no padding */
      background-color: #f8f9fc; /* Fundo muito leve para área do board */
  }
  .kanban-board {
      display: flex;
      gap: 1rem; /* Reduz um pouco o espaço entre colunas */
      overflow-x: auto;
      padding-bottom: 1rem;
      /* Tenta calcular altura para preencher espaço vertical */
      /* Ajuste o valor (318px) se necessário, baseado na altura dos elementos acima */
      height: calc(100vh - 318px);
      min-height: 400px; /* Garante altura mínima ainda */
      justify-content: center; /* Centraliza as colunas se houver espaço */
  }
  .kanban-column {
      flex: 1 1 300px; /* Permite crescer/encolher, base 300px */
      max-width: 380px; /* Limite máximo para não esticar demais */
      background-color: #f1f3f5; /* Fundo da coluna um pouco mais escuro que o board */
      border-radius: 0.375rem; /* Raio padrão Bootstrap */
      /* Sombra sutil padrão Bootstrap */
      /* box-shadow: var(--bs-box-shadow-sm); */ 
      box-shadow: none; /* Remover sombra da coluna, deixar só no card? Testar */
      border: 1px solid #dee2e6; /* Borda leve para definir a coluna */
      display: flex;
      flex-direction: column;
  }
  .kanban-column-header {
      padding: 0.75rem 1rem; /* Ajuste padding */
      background-color: #fff; /* Cabeçalho branco */
      border-bottom: 1px solid #dee2e6; /* Borda padrão */
      font-weight: 500; /* Peso da fonte ligeiramente menor */
      color: #495057; /* Cor do texto mais escura */
      border-top-left-radius: calc(0.375rem - 1px); /* Corresponde à coluna */
      border-top-right-radius: calc(0.375rem - 1px); /* Corresponde à coluna */
      position: sticky;
      top: 0;
      z-index: 10; /* Garante que fique sobre os cards */
      display: flex;
      justify-content: space-between;
      align-items: center;
  }
  /* Nome da Coluna */
  .kanban-column-header .column-title {
      font-size: 0.9rem;
  }
  /* Container para contadores */
  .kanban-column-header .column-meta {
       display: flex;
       align-items: center;
       gap: 0.5rem;
  }
  /* Contagem de Tarefas - Estilo Badge sutil */
  .kanban-column-header .task-count {
      font-size: 0.7rem;
      font-weight: 500;
      color: #6c757d; /* Cor muted */
      background-color: #e9ecef; /* Fundo bem claro */
      padding: 0.2rem 0.45rem;
      border-radius: 0.25rem;
      display: inline-flex; /* Para alinhar ícone */
      align-items: center;
      gap: 0.2rem;
  }
  .kanban-column-header .task-count i {
       font-size: 0.8em; /* Ícone pequeno */
  }
  /* Totais de Horas */
  .kanban-column-header .column-totals {
     font-size: 0.7rem;
     color: #6c757d; /* Muted */
     display: flex;
     align-items: center;
     gap: 0.4rem; /* Espaço entre estimadas/restantes */
  }
  .kanban-column-header .column-totals span[title] { /* Target spans com title */
      display: inline-flex;
      align-items: center;
      gap: 0.15rem;
  }
  .kanban-column-header .column-totals i {
      font-size: 0.85em;
      vertical-align: baseline; /* Melhor alinhamento vertical */
  }

  .kanban-tasks {
      padding: 0.5rem 0.5rem 0.75rem 0.5rem; /* Padding: cima | dir/esq | baixo */
      overflow-y: auto;
      flex-grow: 1;
      min-height: 150px; /* Garante espaço mínimo mesmo vazio */
      /* Adiciona um background sutil para diferenciar da coluna */
      /* background-color: #f8f9fa; */ /* Ou manter o da coluna? Testar */
      border-bottom-left-radius: 0.375rem;
      border-bottom-right-radius: 0.375rem;
  }
  .kanban-task-card {
      background-color: #ffffff;
      border: 1px solid #e1e4e8; /* Borda bem sutil */
      border-radius: 0.375rem; /* Raio padrão */
      padding: 0.6rem 0.8rem; /* Padding interno do card */
      margin: 0.5rem 0.2rem; /* Margem vertical e leve horizontal */
      cursor: grab;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); /* Sombra bem leve */
      border-top: 3px solid transparent; /* BORDA SUPERIOR para cor status (inicialmente transparente) */
      transition: box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.15s ease-in-out;
  }
  .kanban-task-card:hover {
      box-shadow: 0 3px 6px rgba(0,0,0,0.08); /* Sombra hover sutilmente maior */
      border-color: #ced4da; /* Borda geral fica mais visível no hover */
      /* Mantém a borda superior colorida se existir */
      border-top-color: inherit; /* Ou recalcular a cor da coluna */
      transform: translateY(-1px); /* Leve elevação no hover */
  }
  .kanban-task-card .task-header {
       display: flex;
       justify-content: space-between;
       align-items: flex-start;
       margin-bottom: 0.3rem; /* Menos espaço após header */
  }

  .kanban-task-card .task-title {
      font-weight: 500; /* Menos bold */
      color: #343a40; /* Cor de texto principal */
      line-height: 1.35;
      font-size: 0.88rem; /* Tamanho título */
      flex-grow: 1;
      margin-right: 0.5rem;
      /* word-break: break-word; */ /* Evitar quebra feia */
  }
  .kanban-task-card .task-full-id {
      font-size: 0.65em; /* ID ainda menor */
      color: #adb5bd; /* ID bem claro */
      background-color: transparent; /* Sem fundo */
      padding: 0; /* Sem padding extra */
      border-radius: 0;
      align-self: flex-start;
      white-space: nowrap;
      flex-shrink: 0;
      margin-top: 0.1rem; /* Alinha um pouco melhor com o título */
  }

  /* NOVO: Garantir que o corpo do CARD DE TAREFA seja branco */
  .kanban-task-card .card-body { /* Seletor corrigido para o card-body DENTRO de um kanban-task-card */
      background-color: #ffffff !important; /* Força fundo branco */
      /* O padding .p-2 definido no HTML do card-body da tarefa ainda será aplicado */
  }

  /* Grupo Esquerdo: Badge de Prioridade e Ícone Descrição */
  .kanban-task-card .task-meta-left {
      display: flex;
      align-items: center;
      gap: 0.4rem; /* Espaço entre badge e ícone desc */
      margin-bottom: 0.4rem; /* <<< ADICIONADO: Espaço abaixo deste grupo */
  }

   /* Badge de Prioridade */
  .kanban-task-card .task-priority-badge {
      font-size: 0.7rem; /* Badge um pouco maior */
      font-weight: 600; /* Deixa o texto do badge mais forte */
      padding: 0.2em 0.5em; /* Mais padding */
      vertical-align: middle;
      display: inline-flex; /* Para alinhar o círculo interno */
      align-items: center;
      gap: 0.3em; /* Espaço entre círculo e texto */
      /* Cores definidas pelas classes text-bg-* */
  }

  /* Ícone de Descrição (se houver) */
  .kanban-task-card .task-desc-icon {
      color: #6c757d; /* Cor muted */
      font-size: 0.9rem; /* Tamanho do ícone */
      cursor: help; /* Indica que tem tooltip */
  }

  /* Grupo Direito: Detalhes de Tempo, Sprint, Especialista */
  .kanban-task-card .task-details {
      font-size: 0.7rem; /* Tamanho dos detalhes */
      color: #6c757d; /* Cor muted */
      display: flex; /* Ícones e texto na mesma linha AINDA ÚTIL para alinhar ícone/texto */
      align-items: center; /* Alinha itens verticalmente dentro do flex */
      /* gap: 0.5rem; */ /* <<< REMOVIDO: Gap principal entre grupos não necessário */
      /* white-space: nowrap; */ /* <<< REMOVIDO: Permite quebrar linha */
      flex-wrap: wrap; /* <<< ADICIONADO: Permite que itens quebrem linha */
      gap: 0.2rem 0.6rem; /* <<< ADICIONADO: Gap vertical pequeno, horizontal maior */
      margin-top: 0.2rem; /* <<< ADICIONADO: Pequeno espaço acima dos detalhes */
  }
  .kanban-task-card .task-details span[title] { /* Target spans com title */
       display: inline-flex;
       align-items: center;
       gap: 0.2rem; /* Espaço ícone-texto */
  }
  .kanban-task-card .task-details i {
      margin-right: 0; /* Removido, usando gap */
      vertical-align: text-bottom;
      font-size: 0.9em;
  }

  /* Estilo específico para data de conclusão */
  .task-completion-date {
      color: var(--bs-success); /* Verde sucesso */
      font-weight: 500; /* Leve destaque */
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
  }

  /* --- Cores da Borda Superior por Coluna --- */
  .kanban-task-card.task-col-afazer { border-top-color: var(--bs-primary, #0d6efd); }
  .kanban-task-card.task-col-andamento { border-top-color: var(--bs-orange, #fd7e14); }
  .kanban-task-card.task-col-revisao { border-top-color: var(--bs-purple, #6f42c1); }
  .kanban-task-card.task-col-concluido { border-top-color: var(--bs-success, #198754); }
  .kanban-task-card.task-col-bloqueado { border-top-color: var(--bs-danger, #dc3545); } /* Exemplo: Se tiver bloqueado */
  /* Default/Outro: Cinza sutil ou transparente (já definido) */
  .kanban-task-card.task-col-default { border-top-color: var(--bs-secondary, #6c757d); }

  /* --- Estilo para ID da Tarefa com Fundo --- */
  .task-id-display {
      background-color: #f0f0f0; /* Cinza claro */
      padding: 0.15rem 0.4rem;
      border-radius: 0.2rem;
      font-size: 0.7rem; /* Pequeno */
      font-weight: 500;
      color: #555; /* Cor do texto um pouco mais escura */
  }

  /* --- Estilos para Compactar Card --- */
  .task-card-detail-text {
      font-size: 0.72rem !important; /* Levemente menor que a classe 'small' padrão */
      line-height: 1.3;
  }
  .kanban-task-card .btn-sm.manage-segments-btn { /* Específico para o botão de segmentos no card */
      padding: 0.15rem 0.4rem;
      font-size: 0.72rem;
  }
  /* --- Fim Estilos para Compactar Card --- */

  /* Estilo para arrastar (SortableJS) */
  .sortable-ghost {
      opacity: 0.5;
      background-color: #cfe2ff; /* Azul claro */
      border: 1px dashed #0d6efd;
  }
  .sortable-chosen {
      cursor: grabbing;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
      transform: scale(1.02); /* Leve aumento ao pegar */
  }
  /* Mensagem quando coluna vazia */
  .no-tasks {
      text-align: center;
      color: #6c757d;
      padding: 1.5rem 1rem; /* Mais padding vertical */
      font-style: italic;
      font-size: 0.8rem;
  }
  /* Estilos para o modal (mantendo consistência) */
  #addTaskModal .modal-dialog {
      max-width: 750px; /* Aumenta um pouco a largura */
      margin-top: 3rem; /* Mais margem no topo */
  }
  #addTaskModal .modal-content {
      border: none; /* Remove borda padrão */
      border-radius: 0.375rem; /* Raio padrão Bootstrap */
      box-shadow: 0 0.5rem 1.5rem rgba(0, 0, 0, 0.15); /* Sombra mais pronunciada */
  }
  #addTaskModal .modal-header {
      background-color: #343a40; /* FUNDO ESCURO */
      color: #fff; /* Texto claro */
      border-bottom: none; /* Sem borda inferior */
      padding: 1rem 1.5rem; /* Mais padding */
      align-items: center; /* Alinha título e botão fechar */
      border-top-left-radius: calc(0.375rem - 1px); /* Ajusta raio */
      border-top-right-radius: calc(0.375rem - 1px);
  }
  #addTaskModal .modal-title {
      font-size: 1.15rem; /* Título maior */
      font-weight: 600; /* Mais peso */
      color: #fff; /* Cor do título clara */
      display: inline-flex; /* Para alinhar ícone */
      align-items: center;
      gap: 0.5rem; /* Espaço entre ícone e texto */
  }
  #addTaskModal .btn-close {
      padding: 0.5rem;
      margin: -0.5rem -0.5rem -0.5rem auto; /* Ajusta posição */
      filter: invert(1) grayscale(100%) brightness(200%); /* Deixa o X branco */
  }
  #addTaskModal .modal-body {
       padding: 1.5rem 1.5rem 0.5rem 1.5rem; /* Ajusta padding (menos embaixo antes do footer) */
  }
  #addTaskModal .modal-body .row {
       margin-bottom: 1.25rem; /* Aumenta espaço entre linhas */
  }
  /* Linha divisória sutil */
  #addTaskModal .modal-body hr {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
      border-color: #e9ecef; /* Cor bem clara */
  }
  /* Ajuste nos labels e inputs do modal para consistência */
  #addTaskModal .form-label {
      font-size: 0.78rem; /* Tamanho label */
      font-weight: 500; /* Leve bold */
      color: #495057; /* Cor label */
      margin-bottom: 0.3rem;
  }
  #addTaskModal .form-control-sm, #addTaskModal .form-select-sm {
      font-size: 0.9rem; /* Tamanho do texto interno */
      padding: 0.45rem 0.8rem; /* Padding interno levemente ajustado */
      border: 1px solid #ced4da; /* Borda padrão */
      border-radius: 0.25rem; /* Cantos levemente arredondados */
      background-color: #fff !important; /* Garante fundo branco */
  }
  #addTaskModal .form-control-sm:focus, #addTaskModal .form-select-sm:focus {
      border-color: #86b7fe; /* Cor de foco padrão Bootstrap */
      box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25); /* Sombra de foco padrão Bootstrap */
      background-color: #fff !important;
  }
  #addTaskModal textarea.form-control-sm {
      min-height: 80px; /* Altura mínima para descrição */
  }
  #addTaskModal .modal-footer {
      background-color: #343a40; /* FUNDO ESCURO */
      color: #fff; /* Texto claro padrão */
      border-top: none; /* Sem borda superior */
      padding: 1rem 1.5rem; /* Padding */
      display: flex; /* Habilita flexbox */
      justify-content: space-between; /* Separa botão excluir dos outros */
      border-bottom-left-radius: calc(0.375rem - 1px);
      border-bottom-right-radius: calc(0.375rem - 1px);
  }

  /* Estilo dos botões no Footer */
  #addTaskModal .modal-footer .btn {
      padding: 0.5rem 1rem; /* Padding botões */
      font-size: 0.9rem;
      font-weight: 500;
      border-radius: 0.25rem;
      /* Transição suave */
      transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, color 0.15s ease-in-out;
  }
  /* Botão Excluir específico */
  #addTaskModal #deleteTaskBtn {
      /* Já tem btn-danger, sem mudanças extras por enquanto */
  }
  #addTaskModal #deleteTaskBtn:hover {
      /* background-color: var(--bs-danger);
      color: #fff; */
  }
  /* Grupo Cancelar/Salvar */
  #addTaskModal .modal-footer div:last-child { /* Target a div que agrupa Cancelar/Salvar */
      display: flex;
      gap: 0.5rem; /* Espaço entre Cancelar e Salvar */
  }

  /* Estilos para loading (mantidos) */
  .loading-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background-color: rgba(255, 255, 255, 0.8); /* Fundo um pouco mais opaco */
      display: flex; justify-content: center; align-items: center;
      z-index: 1056; /* Acima do conteúdo do modal */
      border-radius: inherit; /* Herda raio do modal-content */
  }

  /* Ajuste na área de detalhes do projeto no topo */
  #projectDetailsHeader {
      font-size: 0.85rem; /* Tamanho da fonte para detalhes do projeto */
      gap: 0.5rem 1.5rem; /* Gap vertical e horizontal */
  }
   #projectDetailsHeader .col-md-auto {
      padding-left: 0; /* Remove padding padrão do col */
      padding-right: 0;
   }
  #projectDetailsHeader small {
      font-size: 0.7rem; /* Label menor */
      color: #6c757d; /* Muted */
      text-transform: uppercase;
      display: block;
      margin-bottom: 0.1rem;
  }
  #projectDetailsHeader span.fw-bold {
      font-weight: 500 !important; /* Menos bold */
      color: #343a40;
  }

  /* Estilos para Notas */
  .notes-list {
      max-height: 500px;
      overflow-y: auto;
  }

  .note-card {
      background-color: #fff;
      border: 1px solid #e3e6f0;
      border-radius: 0.25rem;
      margin-bottom: 0.5rem; /* Reduzido de 1rem para 0.5rem */
      padding: 0.5rem; /* Reduzido de 1rem para 0.5rem */
      transition: all 0.2s ease;
  }

  .note-card:hover {
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transform: translateY(-1px);
  }

  .note-card.priority-high {
      border-left: 3px solid var(--bs-danger);
  }

  .note-card.priority-medium {
      border-left: 3px solid var(--bs-warning);
  }

  .note-card.priority-low {
      border-left: 3px solid var(--bs-success);
  }

  .note-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.3rem; /* Reduzido de 0.5rem para 0.3rem */
      font-size: 0.85rem; /* Texto um pouco menor */
  }

  .note-content {
      white-space: pre-line;
      margin-bottom: 0.3rem; /* Reduzido de 0.5rem para 0.3rem */
      font-size: 0.9rem; /* Texto um pouco menor */
  }

  .note-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.8rem; /* Reduzido de 0.875rem para 0.8rem */
  }

  .note-tags .badge {
      font-size: 0.7rem; /* Reduzido de 0.75rem para 0.7rem */
      margin-right: 0.2rem; /* Reduzido de 0.25rem para 0.2rem */
  }

  .note-actions {
      opacity: 0.5;
      transition: opacity 0.2s ease;
  }

  .note-card:hover .note-actions {
      opacity: 1;
  }

  /* Ajuste nos badges */
  .note-card .badge {
      padding: 0.2em 0.5em;
      font-size: 0.7rem;
  }

  /* Estilos para o Modal */
  #noteModal .modal-body {
      max-height: calc(100vh - 200px);
      overflow-y: auto;
  }

  #noteContent {
      resize: vertical;
      min-height: 100px;
  }

  /* Estilos para os Filtros */
  .note-filters {
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 0.375rem;
      margin-bottom: 1rem;
  }

  /* Ajustes para o layout responsivo */
  .kanban-board {
      height: calc(100vh - 250px); /* Ajustado para considerar o header com informações */
      transition: height 0.3s ease;
  }

  #projectDetailsContainer {
      transition: all 0.3s ease;
  }

  /* Ajuste nas cores dos cards internos */
  #projectDetailsContainer .card {
      border: 1px solid rgba(0,0,0,.125);
      margin-bottom: 1rem;
  }

  #projectDetailsContainer .card-header {
      background-color: #f8f9fa;
      border-bottom: 1px solid rgba(0,0,0,.125);
      padding: 0.5rem 1rem;
  }

  /* Compacta os headers internos */
  #projectDetailsContainer .card .card-header {
      padding: 0.5rem 1rem;
  }

  /* Reduz espaçamento entre seções */
  #projectDetailsContainer .row:not(:last-child) {
      margin-bottom: 1rem;
  }

  /* Ajusta altura das tabelas internas */
  #projectDetailsContainer .table-responsive {
      max-height: 300px;
      overflow-y: auto;
  }

  /* Estilo para o botão toggle quando ativo */
  #toggleDetailsBtn.btn-primary {
      background-color: #0d6efd;
      border-color: #0d6efd;
      color: white;
  }

  /* Ajuste no espaçamento do quadro Kanban */
  .card-body.pb-0 {
      padding-bottom: 1rem !important;
  }

  /* Responsividade para informações do projeto */
  @media (max-width: 768px) {
      #projectDetailsHeader .col-md-auto {
          border-right: none;
          border-bottom: 1px solid rgba(0,0,0,.1);
          padding: 0.5rem 0;
      }
      
      #projectDetailsHeader .col-md-auto:last-child {
          border-bottom: none;
      }
      
      #projectDetailsHeader .d-flex.gap-3 {
          flex-wrap: wrap;
          gap: 1rem !important;
      }
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    {# Card Principal do Quadro Kanban #}
    <div class="card kanban-board-wrapper shadow-sm mb-4"> 
        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between bg-light border-bottom">
            <div class="d-flex align-items-center">
                <a href="{{ url_for('backlog.project_selection') }}" class="btn btn-sm btn-outline-secondary me-3" title="Voltar para Seleção de Projetos">
                    <i class="bi bi-arrow-left"></i>
                    <span class="d-none d-sm-inline"> Projetos</span>
                </a>
                <h6 class="m-0 font-weight-bold text-primary">
                    <i class="bi bi-kanban me-1"></i>
                    Quadro: {{ current_project.name if current_project else 'Projeto Inválido' }} (#{{ current_project.id if current_project else '-' }})
                </h6>
            </div>
            <div class="d-flex align-items-center gap-2">
                <button class="btn btn-sm btn-outline-secondary" id="toggleDetailsBtn" title="Mostrar/Ocultar Detalhes do Projeto">
                    <i class="bi bi-info-circle me-1"></i>Detalhes
                </button>
                 <button class="btn btn-sm btn-primary" id="addTaskBtn" {% if not current_backlog_id %}disabled{% endif %}>
                    <i class="bi bi-plus-lg me-1"></i>Nova Tarefa
                </button>
                </div>
            </div>

        {# Informações do Projeto (sempre visíveis) #}
        <div class="card-body pb-0">
            {# IDs importantes do projeto - NUNCA REMOVER #}
            <input type="hidden" id="currentBacklogId" value="{{ current_backlog_id if current_backlog_id else '' }}">
            <input type="hidden" id="currentProjectId" value="{{ current_project.id if current_project else '' }}">

            {# Mensagem de Status #}
            <div id="boardStatus" class="alert d-flex align-items-center mb-3" role="alert" style="display: none;">
              <i class="bi flex-shrink-0 me-2"></i>
              <div>{# Mensagem será definida pelo JS #}</div>
            </div>

            {# Placeholder para o botão Criar Backlog #}
            <div id="createBacklogPlaceholder" class="mb-3"></div>

            {# Define estado inicial se não houver backlog #}
            {% if not current_backlog_id %}
            <script>
                document.addEventListener('DOMContentLoaded', function() {
                    if (typeof showBoardStatus === 'function') {
                        showBoardStatus('Nenhum backlog encontrado para este projeto.', 'warning', false);
                    }
                    const placeholder = document.getElementById('createBacklogPlaceholder');
                    if (placeholder && typeof addCreateBacklogListener === 'function') {
                        const createBtn = document.createElement('button');
                        createBtn.id = 'createBacklogBtn';
                        createBtn.className = 'btn btn-sm btn-outline-secondary';
                        createBtn.innerHTML = '<i class="bi bi-plus-lg me-1"></i>Criar Backlog';
                        placeholder.appendChild(createBtn);
                        addCreateBacklogListener(createBtn);
                    }
                });
            </script>
            {% endif %}

            {# Informações do Projeto #}
            <div id="projectDetailsHeader" class="row border-bottom pb-2 mb-3 align-items-center">
                <div class="col-md-auto">
                    <small class="text-muted d-block">Status</small>
                    <span id="projectStatus" class="fw-bold">{{ current_project.status if current_project else '-' }}</span>
                </div>
                <div class="col-md-auto">
                    <small class="text-muted d-block">Squad</small>
                    <span id="projectSquad" class="fw-bold">{{ current_project.squad if current_project else '-' }}</span>
                </div>
                <div class="col-md-auto">
                    <small class="text-muted d-block">Especialista</small>
                    <span id="projectSpecialist" class="fw-bold">{{ current_project.specialist if current_project else '-' }}</span>
                </div>
                <div class="col-md-auto ms-md-auto d-flex gap-3">
                    <div>
                        <small class="text-muted d-block">Estimadas</small>
                        <span id="projectOverallEstimatedHours" class="fw-bold">{{ "%.1f"|format(current_project.estimated_hours) if current_project and current_project.estimated_hours is not none else '-' }}</span>h
                    </div>
                    <div>
                        <small class="text-muted d-block">Trabalhadas</small>
                        <span id="projectOverallLoggedHours" class="fw-bold">{{ "%.1f"|format(current_project.logged_hours) if current_project and current_project.logged_hours is not none else '-' }}</span>h
                    </div>
                    <div>
                        <small class="text-muted d-block">Restantes</small>
                        <span id="projectOverallRemainingHours" class="fw-bold">{{ "%.1f"|format(current_project.remaining_hours) if current_project and current_project.remaining_hours is not none else '-' }}</span>h
                    </div>
                    <div>
                        <small class="text-muted d-block">Kanban (Rest.)</small>
                        <span id="kanbanTotalRemainingHours" class="fw-bold">-</span>h
                    </div>
                </div>
            </div>

            {# Quadro Kanban #}
            <div id="kanbanBoard" class="kanban-board">
                {% for column in columns %}
                <div class="kanban-column" data-column-id="{{ column.id }}">
                    <div class="kanban-column-header">
                        <span class="column-title">{{ column.name }}</span>
                        {# NOVO: Container para contagem e totais #}
                        <div class="column-meta">
                            <span class="task-count" title="Número de Tarefas">
                                <i class="bi bi-list-task"></i> {# Ícone diferente #}
                                <span class="count-value">0</span>
                            </span>
                            <span class="column-totals text-muted small">
                                <span title="Total Horas Estimadas"><i class="bi bi-clock-history"></i> <span class="total-estimated">0</span>h</span>
                                {# <span class="mx-1">|</span> Separador removido, usando gap CSS #}
                                <span title="Total Horas Restantes"><i class="bi bi-hourglass-split"></i> <span class="total-remaining">0</span>h</span>
                            </span>
                        </div>
                    </div>
                    <div class="kanban-tasks sortable-list" data-column-id="{{ column.id }}">
                         <div class="no-tasks">Carregando...</div> {# Mensagem ajustada no CSS #}
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
            </div>
            
    {# Container de Detalhes do Projeto (inicialmente oculto) #}
    <div id="projectDetailsContainer" class="card shadow-sm mb-4" style="display: none;">
        <div class="card-header py-3 d-flex justify-content-between align-items-center bg-light border-bottom">
                            <h6 class="m-0 font-weight-bold text-primary">
                <i class="bi bi-info-circle me-1"></i>Detalhes do Projeto
                            </h6>
            <button type="button" class="btn-close" aria-label="Fechar" onclick="toggleProjectDetails()"></button>
        </div>
        <div class="card-body">
            {# Marcos do Projeto #}
            <div class="row mb-4">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header py-2 d-flex justify-content-between align-items-center">
                            <h6 class="m-0"><i class="bi bi-flag-fill me-1"></i>Marcos do Projeto</h6>
                            <div>
                                <button class="btn btn-sm btn-outline-primary" id="addMilestoneBtn">
                                    <i class="bi bi-plus-lg"></i> Novo Marco
                                </button>
                            </div>
                        </div>
                        <div class="card-body p-0">
                            <div class="table-responsive">
                                <table class="table table-sm table-hover" id="milestonesTable">
                                    <thead>
                                        <tr>
                                            <th scope="col">Marco</th>
                                            <th scope="col">Data Planejada</th>
                                            <th scope="col">Data Real</th>
                                            <th scope="col">Status</th>
                                            <th scope="col">Criticidade</th>
                                            <th scope="col">Ações</th>
                                        </tr>
                                    </thead>
                                    <tbody id="milestonesTableBody"> {# Adicionado ID ao tbody #}
                                        <tr>
                                            <td colspan="6" class="text-center text-muted small">
                                                <i class="bi bi-hourglass me-1"></i> Carregando marcos...
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {# Linha do Tempo e Riscos #}
            <div class="row mb-4">
                <!-- Seção de Linha do Tempo (Tarefas) -->
                <div class="col-md-6">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-calendar-range me-1"></i> Linha do Tempo (Tarefas)
                            </h6>
                        </div>
                        <div class="card-body" style="max-height: 350px; overflow-y: auto;">
                            <div id="timelineContainer">
                                <div class="timeline-section mb-3">
                                    <h6 class="text-muted"><i class="bi bi-check-circle-fill text-success me-2"></i>Recentemente Concluídas</h6>
                                    <ul class="list-group list-group-flush" id="completedTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                                <div class="timeline-section mb-3">
                                    <h6 class="text-muted"><i class="bi bi-alarm-fill text-warning me-2"></i>Próximas Tarefas (7 dias)</h6>
                                    <ul class="list-group list-group-flush" id="upcomingTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                                <div class="timeline-section">
                                    <h6 class="text-muted"><i class="bi bi-play-circle-fill text-primary me-2"></i>Iniciadas Recentemente</h6>
                                    <ul class="list-group list-group-flush" id="startedTasksList">
                                        <li class="list-group-item text-center text-muted small">
                                            <i class="bi bi-hourglass me-1"></i> Carregando...
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Seção de Riscos e Impedimentos -->
                <div class="col-md-6">
                    <div class="card shadow-sm mb-4">
                        <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-exclamation-triangle-fill me-1"></i> Riscos e Impedimentos
                            </h6>
                            <button class="btn btn-sm btn-outline-primary" id="addRiskBtn">
                                <i class="bi bi-plus-lg"></i> Novo Risco
                            </button>
                        </div>
                        <div class="card-body" style="max-height: 350px; overflow-y: auto;">
                            <div class="table-responsive">
                                <table class="table table-sm table-hover" id="risksTable">
                                    <thead>
                                        <tr>
                                            <th scope="col">Descrição</th>
                                            <th scope="col">Severidade</th>
                                            <th scope="col">Status</th>
                                            <th scope="col">Ações</th> {# Coluna Ações #}
                                        </tr>
                                    </thead>
                                    <tbody id="risksTableBody"> {# Adicionado ID para tbody #}
                                        <tr>
                                            <td colspan="4" class="text-center text-muted">
                                                <i class="bi bi-hourglass me-1"></i> Carregando riscos...
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            {# Notas e Observações #}
            <div class="row">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h6 class="m-0 font-weight-bold text-primary">
                                <i class="bi bi-journal-text me-1"></i> Notas e Observações
                            </h6>
                            <div class="btn-group">
                                <button class="btn btn-sm btn-primary" id="addNoteBtn">
                                    <i class="bi bi-plus-lg me-1"></i>Nova Nota
                                </button>
                                <button class="btn btn-sm btn-outline-secondary ms-2" id="filterNotesBtn">
                                    <i class="bi bi-funnel me-1"></i>Filtros
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <!-- Filtros (inicialmente ocultos) -->
                            <div id="notesFilters" class="row mb-3" style="display: none;">
                                <div class="col-md-3">
                                    <select class="form-select form-select-sm" id="noteTypeFilter">
                                        <option value="">Todos os Tipos</option>
                                        <option value="project">Notas do Projeto</option>
                                        <option value="task">Notas de Tarefas</option>
                                    </select>
                                </div>
                                <div class="col-md-3">
                                    <select class="form-select form-select-sm" id="noteCategoryFilter">
                                        <option value="">Todas as Categorias</option>
                                        <option value="decision">Decisões</option>
                                        <option value="risk">Riscos</option>
                                        <option value="impediment">Impedimentos</option>
                                        <option value="status_update">Atualizações de Status</option>
                                        <option value="general">Geral</option>
                                    </select>
                                </div>
                                <div class="col-md-3">
                                    <select class="form-select form-select-sm" id="notePriorityFilter">
                                        <option value="">Todas as Prioridades</option>
                                        <option value="high">Alta</option>
                                        <option value="medium">Média</option>
                                        <option value="low">Baixa</option>
                                    </select>
                                </div>
                                <div class="col-md-3">
                                    <div class="input-group input-group-sm">
                                        <input type="text" class="form-control" id="noteSearchInput" placeholder="Buscar notas...">
                                        <button class="btn btn-outline-secondary" type="button" id="noteSearchBtn">
                                            <i class="bi bi-search"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <!-- Lista de Notas -->
                            <div id="notesList" class="notes-list">
                                <div class="text-center text-muted py-3">
                                    <i class="bi bi-hourglass me-1"></i> Carregando notas...
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{# Modal Adicionar/Editar Tarefa (estrutura mantida) #}
<div class="modal fade" id="addTaskModal" tabindex="-1" aria-labelledby="addTaskModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="addTaskForm">
        <div class="modal-header">
          <h5 class="modal-title" id="addTaskModalLabel">Adicionar Nova Tarefa</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="taskId" name="taskId">
          
          {# Seção 1: Nome e Descrição #}
          <div class="row">
            <div class="col-12">
              <label for="taskName" class="form-label">Nome da Tarefa <span class="text-danger">*</span></label>
              <input type="text" class="form-control form-control-sm" id="taskName" name="name" required>
            </div>
          </div>
          <div class="row">
            <div class="col-12">
              <label for="taskDescription" class="form-label">Descrição</label>
              <textarea class="form-control form-control-sm" id="taskDescription" name="description" rows="3"></textarea>
            </div>
          </div>

          <hr> {# Divisor #}

          {# Seção 2: Prioridade e Status #}
          <div class="row">
            <div class="col-md-6">
                <label for="taskPriority" class="form-label">Prioridade</label>
                <select class="form-select form-select-sm" id="taskPriority" name="priority">
                    <option value="Baixa">Baixa</option>
                    <option value="Média" selected>Média</option>
                    <option value="Alta">Alta</option>
                    <option value="Urgente">Urgente</option>
                </select>
            </div>
             <!-- <div class="col-md-6">
                 {# Espaço reservado para Status - Exemplo:
                 <label for="taskStatusColumn" class="form-label">Status (Coluna)</label>
                 <select class="form-select form-select-sm" id="taskStatusColumn" name="column_id" disabled title="O status é definido ao mover o card no quadro.">
                     {# Opções seriam carregadas dinamicamente ou estáticas #}
                 </select>
                 #}
             </div> -->
          </div>

          <hr> {# Divisor #}

          {# Linha 3: Horas Estimadas e Restantes #}
          <div class="row">
             <div class="col-md-6">
              <label for="taskEstimatedHours" class="form-label">Horas Estimadas</label>
              <input type="number" step="0.1" min="0" class="form-control form-control-sm" id="taskEstimatedHours" name="estimated_hours" placeholder="ex: 8.0">
            </div>
            <div class="col-md-6" id="remainingHoursGroup">
                <label for="taskRemainingHours" class="form-label">Horas Restantes</label>
                <input type="number" step="0.1" min="0" class="form-control form-control-sm" id="taskRemainingHours" name="remaining_hours" placeholder="Igual Estimadas" title="Pode ser recalculado. Deixe em branco para usar Estimadas.">
            </div>
           </div>

           {# Seção 4: Datas Início e Fim #}
           <div class="row">
            <div class="col-md-6">
              <label for="taskStartDate" class="form-label">Data Início</label>
              <input type="date" class="form-control form-control-sm" id="taskStartDate" name="start_date">
            </div>
            <div class="col-md-6">
              <label for="taskDueDate" class="form-label">Data Fim (Prazo)</label>
              <input type="date" class="form-control form-control-sm" id="taskDueDate" name="due_date">
            </div>
           </div>

           {# NOVO CAMPO: Data de Conclusão #}
           <div class="row" id="completedDateGroup" style="display: none;"> {# Inicialmente oculto #}
            <div class="col-md-6">
              <label for="taskCompletedDate" class="form-label">Data de Conclusão</label>
              <input type="date" class="form-control form-control-sm" id="taskCompletedDate" name="completed_at">
            </div>
           </div>

           {# <<< INÍCIO: Ler campo Especialista (agora um select) >>> #}
           <hr> {# Divisor #}
           <div class="row">
                <div class="col-md-6">
                     <label for="taskSpecialist" class="form-label">Especialista</label>
                     {# <<< INÍCIO: Substituir input por select >>> #}
                     <select class="form-select form-select-sm" id="taskSpecialist" name="specialist_name" title="Selecione o especialista ou deixe em branco para usar o padrão do projeto.">
                        <option value="" selected>-- Padrão do Projeto --</option>
                        {# Opções serão carregadas pelo JavaScript #}
                     </select>
                     {# <<< FIM: Substituir input por select >>> #}
                     {# TODO: Transformar em <select> futuramente? #}
                </div>
           </div>
           {# <<< FIM: Campo Especialista >>> #}

          {# --- INÍCIO: Nova Seção para Resumo dos Segmentos --- #}
          <hr> 
          <div class="row mb-3">
            <div class="col-12">
              <h6 class="mb-2 text-muted"><i class="fas fa-calendar-alt me-1"></i> Segmentos da Tarefa</h6>
              <div id="taskSegmentsSummaryDisplay" class="list-group list-group-flush small" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: .25rem; padding: 0.5rem;">
                <p class="text-muted m-0">Carregando informações dos segmentos...</p>
              </div>
            </div>
          </div>
          {# --- FIM: Nova Seção para Resumo dos Segmentos --- #}

        </div>
        <div class="modal-footer justify-content-between">
            {# Botão Excluir (visível apenas na edição) #}
            <button type="button" class="btn btn-danger" id="deleteTaskBtn" style="display: none;">Excluir Tarefa</button>
            <div>
                 {# Botão Cancelar #}
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                 {# Botão Salvar/Criar #}
                <button type="submit" class="btn btn-primary">Salvar Tarefa</button>
            </div>
        </div>
        {# Loading Feedback #}
        <div class="loading-overlay" style="display: none;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- *** NOVO MODAL PARA MARCOS DO PROJETO *** -->
<div class="modal fade" id="milestoneModal" tabindex="-1" aria-labelledby="milestoneModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered"> {# Modal um pouco maior #}
        <div class="modal-content">
            <form id="milestoneForm">
                <div class="modal-header bg-primary text-white"> {# Header com cor #}
                    <h5 class="modal-title" id="milestoneModalLabel">
                        <i class="bi bi-flag-fill me-2"></i> <span id="milestoneModalTitle">Adicionar Marco</span>
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="milestoneId" name="milestoneId">
                    
                    {# Linha 1: Nome #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <label for="milestoneName" class="form-label">Nome do Marco <span class="text-danger">*</span></label>
                            <input type="text" class="form-control form-control-sm" id="milestoneName" name="name" required>
                        </div>
                    </div>
                    
                    {# Linha 2: Descrição #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <label for="milestoneDescription" class="form-label">Descrição</label>
                            <textarea class="form-control form-control-sm" id="milestoneDescription" name="description" rows="3"></textarea>
                        </div>
                    </div>
                    
                    {# Linha 3: Datas #}
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="milestonePlannedDate" class="form-label">Data Planejada <span class="text-danger">*</span></label>
                            <input type="date" class="form-control form-control-sm" id="milestonePlannedDate" name="planned_date" required>
                        </div>
                        <div class="col-md-6">
                            <label for="milestoneActualDate" class="form-label">Data Real</label>
                            <input type="date" class="form-control form-control-sm" id="milestoneActualDate" name="actual_date">
                        </div>
                    </div>
                    
                    {# Linha 4: Status e Criticidade #}
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="milestoneStatus" class="form-label">Status</label>
                            <select class="form-select form-select-sm" id="milestoneStatus" name="status">
                                <option value="Pendente" selected>Pendente</option>
                                <option value="Em Andamento">Em Andamento</option>
                                <option value="Concluído">Concluído</option>
                                <option value="Atrasado">Atrasado</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="milestoneCriticality" class="form-label">Criticidade</label>
                            <select class="form-select form-select-sm" id="milestoneCriticality" name="criticality">
                                <option value="Baixa">Baixa</option>
                                <option value="Média" selected>Média</option>
                                <option value="Alta">Alta</option>
                                <option value="Crítica">Crítica</option>
                            </select>
                        </div>
                    </div>
                    
                    {# Linha 5: Checkpoint #}
                    <div class="row mb-3">
                        <div class="col-12">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="milestoneIsCheckpoint" name="is_checkpoint">
                                <label class="form-check-label" for="milestoneIsCheckpoint">
                                    É um marco crítico (checkpoint)?
                                </label>
                            </div>
                        </div>
                    </div>
                    
                </div> {# Fim modal-body #}
                <div class="modal-footer justify-content-between">
                    {# Botão Excluir (visível apenas na edição) #}
                    <button type="button" class="btn btn-danger btn-sm" id="deleteMilestoneBtn" style="display: none;">
                        <i class="bi bi-trash me-1"></i> Excluir
                    </button>
                    {# Grupo Cancelar/Salvar #}
                    <div>
                        <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Cancelar</button>
                        <button type="submit" class="btn btn-primary btn-sm" id="saveMilestoneBtn">
                            <i class="bi bi-check-lg me-1"></i> Salvar Marco
                        </button>
                    </div>
                </div>
                {# Loading Feedback #}
                <div class="loading-overlay" style="display: none;">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Carregando...</span>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>
<!-- *** FIM NOVO MODAL PARA MARCOS *** -->

<!-- Modal para Adicionar/Editar Risco do Projeto -->
<div class="modal fade" id="riskModal" tabindex="-1" aria-labelledby="riskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="riskForm"> <!-- ADICIONADO ID AQUI -->
                <div class="modal-header">
                    <h5 class="modal-title" id="riskModalLabel">Adicionar Risco</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="riskDescription" class="form-label">Descrição do Risco</label>
                        <textarea class="form-control" id="riskDescription" rows="3"></textarea>
                    </div>
                    <div class="mb-3">
                        <label for="riskSeverity" class="form-label">Severidade</label>
                        <input type="number" class="form-control" id="riskSeverity" min="1" max="10" placeholder="1-10">
                    </div>
                    <div class="mb-3">
                        <label for="riskStatus" class="form-label">Status</label>
                        <select class="form-select" id="riskStatus">
                            <option value="Ativo" selected>Ativo</option>
                            <option value="Mitigado">Mitigado</option>
                            <option value="Resolvido">Resolvido</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="submit" class="btn btn-primary">Salvar Risco</button>
                </div>
            </form>
        </div>
    </div>
</div>

{# Script dedicado para armazenar os dados JSON das tarefas iniciais #}
<script id="initial-tasks-data" type="application/json">
{{ tasks_json|safe if tasks_json else '[]' }}
</script>

{# SortableJS (link mantido, mas JS removido) #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

{# JavaScript Específico da Página #}
<script>
  // Obtém IDs do Flask
  const initialBacklogId = document.getElementById('currentBacklogId')?.value || '';
  const initialProjectId = document.getElementById('currentProjectId')?.value || '';
  const projectNameForLogs = "{{ current_project.name if current_project else 'Projeto Desconhecido' }}";

  // Elementos do DOM para Marcos (definindo globalmente no topo)
  const addMilestoneBtn = document.getElementById('addMilestoneBtn');
  const milestonesTableBody = document.getElementById('milestonesTableBody');
  const milestoneModalElement = document.getElementById('milestoneModal');
  const milestoneModal = milestoneModalElement ? new bootstrap.Modal(milestoneModalElement) : null;
  const milestoneForm = document.getElementById('milestoneForm');
  const milestoneModalTitle = document.getElementById('milestoneModalTitle');
  const milestoneIdInput = document.getElementById('milestoneId');
  const deleteMilestoneBtn = document.getElementById('deleteMilestoneBtn');
  const saveMilestoneBtn = document.getElementById('saveMilestoneBtn');

  // Verifica se os elementos essenciais existem
  if (!milestonesTableBody) {
      console.error("[CRITICAL] Elemento #milestonesTableBody não encontrado no DOM. Marcos não poderão ser exibidos.");
  } else {
      console.log("[Init] Elemento #milestonesTableBody encontrado com sucesso.");
  }

  // Lê e parseia as tarefas iniciais do script JSON dedicado
  let initialTasks = []; // Default para array vazio
  try {
      const tasksDataElement = document.getElementById('initial-tasks-data');
      if (tasksDataElement) {
          initialTasks = JSON.parse(tasksDataElement.textContent || '[]');
      } else {
          console.warn("Elemento #initial-tasks-data não encontrado. Usando array vazio para tarefas.");
      }
  } catch (error) {
      console.error("Erro ao parsear JSON das tarefas iniciais:", error, "Conteúdo:", document.getElementById('initial-tasks-data')?.textContent);
      // Mantém initialTasks como [] em caso de erro
      showBoardStatus("Erro ao carregar dados das tarefas iniciais. Verifique o console.", "danger");
  }

  // Define funções aqui fora se necessário para o script do 'if not current_backlog_id'
  function showBoardStatus(message, type = 'info', showBoard = false) {
      const boardStatus = document.getElementById('boardStatus');
      const kanbanBoard = document.getElementById('kanbanBoard');
      if (!boardStatus) { console.error("Elemento #boardStatus não encontrado."); return; }
      const boardStatusDiv = boardStatus.querySelector('div');
      const boardStatusIcon = boardStatus.querySelector('i');
      if (!boardStatusDiv || !boardStatusIcon) { console.error("Elementos internos de #boardStatus não encontrados."); return; }

      console.log(`[Status Update] Type: ${type}, Message: ${message}, ShowBoard: ${showBoard}`);
      boardStatusDiv.textContent = message;
      let iconClass = 'bi-info-circle-fill';
      if (type === 'warning') iconClass = 'bi-exclamation-triangle-fill';
      else if (type === 'danger') iconClass = 'bi-x-octagon-fill';
      else if (type === 'success') iconClass = 'bi-check-circle-fill';
      boardStatusIcon.className = `bi ${iconClass} flex-shrink-0 me-2`;
      boardStatus.className = `alert alert-${type} d-flex align-items-center mb-3`;
      boardStatus.innerHTML = `
        <i class="bi ${iconClass} flex-shrink-0 me-2"></i>
        <div>${message}</div>
      `;
      boardStatus.style.display = 'flex';
      if (kanbanBoard) {
           kanbanBoard.style.display = showBoard ? 'flex' : 'none';
      } else { console.error('#kanbanBoard não encontrado ao tentar definir display em showBoardStatus'); }
  }

  function addCreateBacklogListener(buttonElement) {
       if (!buttonElement) return;
       buttonElement.addEventListener('click', async function() {
          if (!initialProjectId) {
              alert("Erro crítico: ID do projeto atual não definido.");
              return;
          }
          console.log(`[Create Backlog Button] Clicado para Projeto ID: ${initialProjectId}`);
          this.disabled = true; this.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Criando...';
          try {
              const response = await fetch(`/backlog/api/projects/${initialProjectId}/backlog`, {
                  method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({})
              });
              console.log(`[Create Backlog Button] Resposta API (${response.status}):`, response);
              if (!response.ok) {
                  let errorMsg = `Erro ${response.status}`;
                  try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                  throw new Error(errorMsg);
              }
              const newBacklog = await response.json();
              console.log("[Create Backlog Button] Backlog criado:", newBacklog);
              alert(`Backlog para ${projectNameForLogs} criado com sucesso! A página será recarregada.`);
              window.location.reload();
          } catch (error) {
              console.error('[Create Backlog Button] Erro:', error);
              alert(`Erro ao criar backlog: ${error.message}`);
              this.disabled = false; this.innerHTML = '<i class="bi bi-plus-lg me-1"></i>Criar Backlog';
          }
      });
  }

  // --- Funções Essenciais de Renderização (Definidas fora do DOMContentLoaded) ---
  let currentTasksData = []; // Precisa estar no escopo global
  let editingTaskId = null;  // Precisa estar no escopo global
  const sortableInstances = []; // Precisa estar no escopo global

  // Limpa as tarefas de todas as colunas
  function clearBoard() {
      console.log("[Clear Board] Limpando tarefas das colunas.");
      const taskLists = document.querySelectorAll('.kanban-tasks');
      taskLists.forEach(list => {
          list.innerHTML = '<div class="no-tasks">Nenhuma tarefa nesta coluna.</div>';
      });
      // updateColumnTotals() é chamado por renderTasks
  }

  // Escapa HTML para tooltips seguros
  function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
          .toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
  }

  // Mostra/esconde o overlay de loading no modal
  function showLoadingFeedback(isLoading) {
      const form = document.getElementById('addTaskForm');
      if (!form) return;
      const overlay = form.querySelector('.loading-overlay');
      const submitButton = form.querySelector('button[type="submit"]');
      const cancelButton = form.querySelector('button[data-bs-dismiss="modal"]');
      const deleteButton = document.getElementById('deleteTaskBtn');
      if (overlay) {
          overlay.style.display = isLoading ? 'flex' : 'none';
      } else {
           console.warn('Elemento .loading-overlay não encontrado no modal.');
      }
      if(submitButton) submitButton.disabled = isLoading;
      if (cancelButton) cancelButton.disabled = isLoading;
      if (deleteButton) deleteButton.disabled = isLoading;
  }

  // Lida com o clique em um card de tarefa para edição
  async function handleTaskClick(event) {
      const taskCard = event.currentTarget;
      const taskId = taskCard.dataset.taskId;
      if (!taskId) {
          console.error("Não foi possível obter o ID da tarefa do card.");
          return;
      }
      editingTaskId = taskId; // Atualiza global
      console.log(`[Task Click] Tarefa ID ${editingTaskId} clicada para edição.`);
      
      // Seleciona elementos do modal
      const addTaskModalEl = document.getElementById('addTaskModal');
      if (!addTaskModalEl) { console.error("Modal #addTaskModal não encontrado."); return; }
      const addTaskModalInstance = bootstrap.Modal.getInstance(addTaskModalEl) || new bootstrap.Modal(addTaskModalEl);
      const addTaskForm = document.getElementById('addTaskForm');
      const addTaskModalLabel = document.getElementById('addTaskModalLabel');
      const deleteTaskBtn = document.getElementById('deleteTaskBtn');
      const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
      const segmentsSummaryDisplay = document.getElementById('taskSegmentsSummaryDisplay'); // <<< MOVIDO PARA CÁ
      const completedDateGroup = document.getElementById('completedDateGroup'); // <<< NOVO: Campo Data Conclusão

      if (!addTaskForm || !addTaskModalLabel || !deleteTaskBtn || !remainingHoursGroup || !segmentsSummaryDisplay || !completedDateGroup) { // <<< ADICIONADO completedDateGroup À VERIFICAÇÃO
           console.error("Elementos do modal (form, label, deleteBtn, remainingHoursGroup, segmentsSummaryDisplay, completedDateGroup) não encontrados!");
           return;
      }
      
      // Reset e mostra loading ANTES da chamada API
      addTaskForm.reset(); 
      if (segmentsSummaryDisplay) { // <<< ADICIONADO: Limpa e mostra carregando ANTES do try
        segmentsSummaryDisplay.innerHTML = '<p class="text-muted m-0">Carregando informações dos segmentos...</p>';
      }
      // Define título e ícone para EDIÇÃO
      addTaskModalLabel.innerHTML = '<i class="bi bi-pencil-square me-2"></i>Editar Tarefa';
      deleteTaskBtn.style.display = 'none'; // Esconde botão excluir enquanto carrega
      if(remainingHoursGroup) remainingHoursGroup.style.display = 'block'; // *** MOSTRA HORAS RESTANTES NA EDIÇÃO ***
      showLoadingFeedback(true);
      addTaskModalInstance.show(); // Mostra o modal com loading
      
      try {
          const response = await fetch(`/backlog/api/tasks/${editingTaskId}`);
          if (!response.ok) {
               let errorMsg = `Erro ${response.status}`;
               try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
               throw new Error(errorMsg);
          }
          const taskData = await response.json();
          console.log("[Task Click] Dados da tarefa recebidos:", taskData);
          
          // Popula o formulário com os dados recebidos
          addTaskForm.querySelector('#taskId').value = taskData.id;
          addTaskForm.querySelector('#taskName').value = taskData.name;
          addTaskForm.querySelector('#taskDescription').value = taskData.description || '';
          addTaskForm.querySelector('#taskPriority').value = taskData.priority || 'Média';
          addTaskForm.querySelector('#taskEstimatedHours').value = taskData.estimated_hours != null ? taskData.estimated_hours : '';
          // Exibe 0.0 se for zero, senão vazio
          addTaskForm.querySelector('#taskRemainingHours').value = taskData.remaining_hours != null ? taskData.remaining_hours : ''; 
          addTaskForm.querySelector('#taskStartDate').value = taskData.start_date ? taskData.start_date.substring(0, 10) : '';
          addTaskForm.querySelector('#taskDueDate').value = taskData.due_date ? taskData.due_date.substring(0, 10) : '';
          addTaskForm.querySelector('#taskCompletedDate').value = taskData.completed_at ? taskData.completed_at.substring(0, 10) : ''; // <<< NOVO
          
          // Controlar visibilidade do campo Data de Conclusão
          const columnIdentifier = taskCard.classList.value.match(/task-col-([^\s]+)/);
          const isInCompletedColumn = columnIdentifier && columnIdentifier[1] === 'concluido';
          if (taskData.completed_at || isInCompletedColumn) {
            completedDateGroup.style.display = 'block';
          } else {
            completedDateGroup.style.display = 'none';
          }
          
          // Atualiza título final (se necessário, embora já setado como Editar)
          // addTaskModalLabel.textContent = 'Editar Tarefa'; // Removido, já feito com innerHTML e ícone
          deleteTaskBtn.style.display = 'inline-block'; 
          
          // <<< INÍCIO: Popular campo Especialista (agora um select) >>>
          const specialistSelect = addTaskForm.querySelector('#taskSpecialist');
          if (specialistSelect) {
              // Define o valor do select. Se taskData.specialist_name for null/undefined/vazio, selecionará a opção padrão com value=""
              specialistSelect.value = taskData.specialist_name || ''; 
          } else {
              console.error("Elemento select #taskSpecialist não encontrado no modal.");
          }
          // <<< FIM: Popular campo Especialista (agora um select) >>>
          
          // --- INÍCIO: Popular resumo dos segmentos ---
          // const segmentsSummaryDisplay = document.getElementById('taskSegmentsSummaryDisplay'); // <<< REMOVIDO DAQUI
          if (segmentsSummaryDisplay) { // A verificação continua útil aqui
            try {
                console.log("[Task Click] Iniciando renderização do resumo dos segmentos. Dados:", taskData.task_segments_summary);
                // segmentsSummaryDisplay.innerHTML = '<p class="text-muted m-0">Carregando informações dos segmentos...</p>'; // <<< REMOVIDO DAQUI

                if (taskData.task_segments_summary && taskData.task_segments_summary.length > 0) {
                    let segmentsHtml = `<p class="mb-1"><strong>Total de Segmentos: ${taskData.task_segments_summary.length}</strong></p><ul class="list-unstyled mb-0">`;
                    taskData.task_segments_summary.forEach((segment, index) => {
                        console.log(`[Task Click] Processando segmento ${index}:`, segment);
                        const startDisplay = segment.start ? formatDisplayDateTime(segment.start.substring(0,10), segment.start.substring(11,16)) : 'N/A';
                        const endDisplay = segment.end ? formatDisplayDateTime(segment.end.substring(0,10), segment.end.substring(11,16)) : 'N/A';
                        const descriptionSnippet = segment.description || 'Sem descrição adicional';
                        console.log(`[Task Click] Segmento ${index} - Start: ${startDisplay}, End: ${endDisplay}, Desc: ${descriptionSnippet}`);
                        segmentsHtml += `
                            <li class="mb-1 p-1 border-bottom">
                                <i class="bi bi-calendar-check text-success me-1"></i> ${startDisplay} - ${endDisplay}<br>
                                <small class="text-muted ms-3"><i class="bi bi-info-circle me-1"></i> ${escapeHtml(descriptionSnippet)}</small>
                            </li>`;
                    });
                    segmentsHtml += `</ul>`;
                    segmentsSummaryDisplay.innerHTML = segmentsHtml;
                    console.log("[Task Click] Resumo dos segmentos renderizado com HTML:", segmentsHtml);
                } else {
                    segmentsSummaryDisplay.innerHTML = '<p class="text-muted m-0"><i class="bi bi-info-circle me-1"></i>Nenhum segmento cadastrado para esta tarefa.</p>';
                    console.log("[Task Click] Nenhum segmento para exibir.");
                }
            } catch (segRenderError) {
                console.error("[Task Click] Erro ao renderizar resumo dos segmentos:", segRenderError);
                if (segmentsSummaryDisplay) { // Verifica novamente para segurança
                    segmentsSummaryDisplay.innerHTML = '<p class="text-danger m-0"><i class="bi bi-exclamation-triangle-fill me-1"></i>Erro ao carregar informações dos segmentos.</p>';
                }
            }
          } else {
              console.warn("[Task Click] Elemento #taskSegmentsSummaryDisplay não encontrado para exibir segmentos.");
          }
          // --- FIM: Popular resumo dos segmentos ---
      } catch (error) {
          console.error('[Task Click] Erro ao carregar dados da tarefa:', error);
          addTaskModalLabel.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>Erro ao Carregar'; // Indica erro no título com ícone
          alert(`Erro ao carregar dados da tarefa: ${error.message}`);
          // Considerar fechar o modal ou manter aberto com erro? Manter aberto por enquanto.
      } finally {
          // Esconde o loading DEPOIS de popular ou dar erro
          showLoadingFeedback(false); 
      }
  }

  // Adiciona um único card de tarefa �  coluna correta
  function addTaskToBoard(task) {
      const column = document.querySelector(`.kanban-tasks[data-column-id="${task.column_id}"]`);
      if (column) {
          // Remove 'no-tasks' message if it exists and we're adding a task
          const noTasksDiv = column.querySelector('.no-tasks');
          if (noTasksDiv) {
              noTasksDiv.remove();
          }

          // --- INÍCIO: Definições para o Card da Tarefa (Restaurado/Verificado) ---
          let priorityBadgeClass = 'bg-secondary'; // Default para prioridade Média/não definida
          let priorityIcon = 'bi-dash-circle'; // Ícone para Média/não definida
          const priorityLower = (task.priority || '').toLowerCase();

          if (priorityLower === 'urgente') {
              priorityBadgeClass = 'bg-danger';
              priorityIcon = 'bi-exclamation-octagon-fill';
          } else if (priorityLower === 'alta') {
              priorityBadgeClass = 'bg-warning text-dark'; // Amarelo com texto escuro
              priorityIcon = 'bi-chevron-double-up';
          } else if (priorityLower === 'baixa') {
              priorityBadgeClass = 'bg-info text-dark'; // Azul claro com texto escuro para Baixa
              priorityIcon = 'bi-chevron-double-down';
          }
          const priorityText = task.priority || 'Média';
          // Badge de Prioridade (será posicionado no topo esquerdo)
          const priorityBadgeHTML = `<span class="badge ${priorityBadgeClass}" title="Prioridade: ${escapeHtml(priorityText)}"><i class="bi ${priorityIcon} me-1"></i>${escapeHtml(priorityText)}</span>`;

          // ID da Tarefa (será posicionado no topo direito)
          const abbreviatedStatus = getAbbreviatedColumnIdentifier(task.column_identifier);
          const taskIdDisplayHTML = `<span class="task-id-display" title="ID da Tarefa">${initialProjectId || 'PROJ'}-${abbreviatedStatus}-${task.id}</span>`;

          const specialistHTML = task.specialist_name
              ? `<div class="small text-muted task-card-detail-text"><i class="bi bi-person-circle me-1"></i>${escapeHtml(task.specialist_name)}</div>`
              : '';

          // Resumo dos Segmentos (se houver)
          let segmentsSummaryHTML = '';
          if (task.task_segments_summary && task.task_segments_summary.length > 0) {
              segmentsSummaryHTML = `<div class="small text-muted task-card-detail-text"><i class="bi bi-diagram-3 me-1"></i>${task.task_segments_summary.length} segmento(s)</div>`;
          }

          // Botão de Gerenciar Segmentos
          const manageSegmentsButtonHTML = `
            <div class="mt-1 text-end">
                <button type="button"
                        class="btn btn-outline-secondary btn-sm manage-segments-btn"
                        data-task-id="${task.id}"
                        title="Gerenciar Segmentos da Tarefa">
                    <i class="fas fa-calendar-alt me-1"></i>Segmentos
                </button>
            </div>`;

          // Rodapé do Card: Horas e Data de Início
          const footerHoursHTML = `<small class="text-muted task-card-detail-text" title="Horas Estimadas"><i class="bi bi-clock-history me-1"></i>${task.estimated_hours != null ? task.estimated_hours.toFixed(1) : '0.0'}h</small>`;
          
          // NOVO: Lógica condicional para a data no rodapé
          let footerDateHTML = '';
          if (task.column_identifier === 'concluido' && task.completed_at) {
              footerDateHTML = `<small class="text-muted task-card-detail-text task-completion-date" title="Concluído em"><i class="bi bi-calendar-check-fill me-1"></i>${formatDateString(task.completed_at, true)}</small>`;
          } else {
              footerDateHTML = `<small class="text-muted task-card-detail-text" title="Data de Início Previsto"><i class="bi bi-calendar-event me-1"></i>${task.start_date ? formatDateString(task.start_date, false) : 'N/A'}</small>`;
          }


          const taskCardHTML = `
              <div class="kanban-task-card card mb-2 shadow-sm ${task.column_identifier === 'concluido' ? 'task-completed-card' : ''} task-col-${task.column_identifier || 'default'}" data-task-id="${task.id}" data-task-title="${escapeHtml(task.title)}" draggable="true">
                  <div class="card-body py-1 px-2">
                      <!-- Linha 1: Prioridade (Esquerda) e ID (Direita) -->
                      <div class="d-flex justify-content-between align-items-start mb-1">
                          <div>${priorityBadgeHTML}</div>
                          <div>${taskIdDisplayHTML}</div>
                      </div>

                      <!-- Linha 2: Título -->
                      <h6 class="card-title mb-1 task-main-title">${escapeHtml(task.title)}</h6>

                      <!-- Meio: Especialista e Segmentos -->
                      <div class="task-middle-details mb-1">
                          ${specialistHTML}
                          ${segmentsSummaryHTML}
                      </div>
                  </div>

                  <div class="card-footer bg-transparent border-top-0 px-2 py-1">
                      <!-- Linha 1 Footer: Horas e Data Início -->
                      <div class="d-flex justify-content-between align-items-center mb-1">
                          ${footerHoursHTML}
                          ${footerDateHTML} {# <<< MODIFICADO DE footerStartDateHTML PARA footerDateHTML #}
                      </div>
                      <!-- Linha 2 Footer: Botão Segmentos -->
                      ${manageSegmentsButtonHTML}
                  </div>
              </div>
          `;

          const taskCardWrapper = document.createElement('div');
          taskCardWrapper.innerHTML = taskCardHTML;
          const actualCardElement = taskCardWrapper.firstElementChild; // <<< ALTERADO DE firstChild para firstElementChild

          if (actualCardElement) {
              column.appendChild(actualCardElement); 

              actualCardElement.addEventListener('click', handleTaskClick);
              
              const manageSegmentsBtn = actualCardElement.querySelector('.manage-segments-btn');
              if (manageSegmentsBtn) {
                  manageSegmentsBtn.addEventListener('click', function(event) {
                      event.stopPropagation(); 
                      const taskName = task.title || 'Tarefa Desconhecida'; 
                      openManageSegmentsModal(task.id, taskName);
                  });
              }
          } else {
              console.error("[AddTaskToBoard] taskCardElement.firstChild é nulo após definir innerHTML. HTML:", taskCardHTML);
          }

      } else {
          console.warn(`[Add Task To Board] Coluna ID ${task.column_id} não encontrada para a tarefa ID ${task.id}`);
      }
  }

  // (Re)Inicializa o SortableJS para todas as colunas
  function initializeSortable() {
      sortableInstances.forEach(instance => instance.destroy());
      sortableInstances.length = 0;
      const taskLists = document.querySelectorAll('.kanban-tasks');
      taskLists.forEach(list => {
          const instance = new Sortable(list, {
              group: 'kanban',
              animation: 150,
              ghostClass: 'sortable-ghost',
              chosenClass: 'sortable-chosen',
              draggable: '.kanban-task-card',
              onEnd: async function (evt) {
                  const taskId = evt.item.dataset.taskId;
                  const newColumnId = evt.to.dataset.columnId;
                  const newIndex = evt.newIndex; // Índice baseado em 0 na nova lista

                  console.log(`[Task Moved] Tarefa ID: ${taskId}, Nova Coluna ID: ${newColumnId}, Nova Posição (Índice): ${newIndex}`);

                  // Prepara dados para a API
                  const moveData = {
                      column_id: newColumnId,
                      position: newIndex // API espera a posição (índice) na nova coluna
                  };

                  // Adiciona um feedback visual temporário (opcional)
                  // evt.item.style.opacity = '0.5'; // Comentado pois vamos remover e recriar o item

                  let updatedTask = null; // << DECLARA FORA DO TRY
                  try {
                      const response = await fetch(`/backlog/api/tasks/${taskId}/move`, {
                          method: 'PUT',
                          headers: {'Content-Type': 'application/json'},
                          body: JSON.stringify(moveData)
                      });

                      console.log(`[Task Moved] Resposta API (${response.status}):`, response);
                      if (!response.ok) {
                          let errorMsg = `Erro ${response.status}`;
                          try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                          throw new Error(errorMsg);
                      }

                      updatedTask = await response.json(); // << ATRIBUI AQUI
                      console.log("[Task Moved] Tarefa atualizada pela API:", updatedTask);

                      // Atualiza o currentTasksData localmente (IMPORTANTE!)
                      const taskIndex = currentTasksData.findIndex(t => t.id == updatedTask.id);
                      if (taskIndex > -1) {
                          currentTasksData[taskIndex] = updatedTask;
                      } else {
                          // Se não encontrou, pode ser uma tarefa que foi criada e movida rapidamente
                          // ou algum estado inconsistente. Adicionar é uma forma de tentar corrigir.
                          currentTasksData.push(updatedTask);
                          console.warn(`[Task Moved] Tarefa ID ${updatedTask.id} não encontrada em currentTasksData. Adicionando.`);
                      }
                      
                      // --- NOVA ABORDAGEM: Remover o item antigo e re-renderizar com addTaskToBoard ---
                      if (evt.item && evt.item.parentNode) {
                          evt.item.parentNode.removeChild(evt.item);
                          console.log(`[Task Moved UI] Item DOM original (ID: ${taskId}) removido.`);
                      }
                      addTaskToBoard(updatedTask); // Re-renderiza o card com os dados atualizados
                      console.log(`[Task Moved UI] Card (ID: ${updatedTask.id}) re-renderizado por addTaskToBoard.`);
                      // ---------------------------------------------------------------------------------
                      
                      // Atualiza a timeline sempre que uma tarefa for movida
                      console.log(`[Task Moved] Atualizando timeline após movimentação da tarefa ${taskId}`);
                      setTimeout(updateTimelineTasks, 500); // Pequeno delay para garantir que o DOM esteja estável

                      // Recalcula totais
                      updateColumnTotals();
                      
                  } catch (error) {
                      console.error('[Task Moved] Erro ao salvar nova posição:', error);
                      alert(`Erro ao mover tarefa: ${error.message}. A interface pode estar dessincronizada. Recarregue a página.`);
                      // Em caso de erro, o item original (evt.item) ainda estará no DOM,
                      // mas pode estar na posição errada visualmente devido ao SortableJS.
                      // Uma recarga da página pode ser a melhor saída ou tentar reverter a ação do sortable.
                      // Por ora, a renderização completa via renderTasks() pode ser uma opção de fallback.
                      renderTasks(currentTasksData); // Tenta re-renderizar tudo para corrigir estado visual.
                  } finally {
                       // Não precisamos mais restaurar opacidade do evt.item, pois ele foi removido/recriado.
                  }
                  
                  // --- Atualização da UI para Mensagem "Nenhuma Tarefa" ---
                  // Verifica coluna de DESTINO
                  const destinationColumnTasks = evt.to.querySelectorAll('.kanban-task-card');
                  const destNoTasksMsg = evt.to.querySelector('.no-tasks');
                  if (destinationColumnTasks.length > 0 && destNoTasksMsg) {
                      destNoTasksMsg.remove(); // Remove se há tarefas e a msg existe
                      console.log(`[Task Moved UI] Removida msg 'no-tasks' da coluna destino ID: ${evt.to.dataset.columnId}`);
                  }
                  
                  // Verifica coluna de ORIGEM (se diferente da destino)
                  if (evt.from !== evt.to) {
                      const sourceColumnTasks = evt.from.querySelectorAll('.kanban-task-card');
                      const sourceNoTasksMsg = evt.from.querySelector('.no-tasks');
                      if (sourceColumnTasks.length === 0 && !sourceNoTasksMsg) {
                          const noTasksDiv = document.createElement('div');
                          noTasksDiv.className = 'no-tasks';
                          noTasksDiv.textContent = 'Nenhuma tarefa nesta coluna.';
                          evt.from.appendChild(noTasksDiv);
                          console.log(`[Task Moved UI] Adicionada msg 'no-tasks' �  coluna origem ID: ${evt.from.dataset.columnId}`);
                      }
                  }
                  // ----------------------------------------------------------

                  // --- ATUALIZAÇÃO VISUAL: Data de Conclusão ---
                  // ESTA SEÇÃO FOI REMOVIDA POIS addTaskToBoard AGORA CUIDA DISSO
                  // const completionDateSpan = evt.item.querySelector('.task-completion-date');
                  // let newCompletionHtml = ''; 
                  // if (updatedTask && updatedTask.column_identifier === 'concluido' && updatedTask.completed_at) { 
                  //    // ... lógica de formatação ...
                  // }
                  // if (completionDateSpan) {
                  //    // ...
                  // } else if (newCompletionHtml) {
                  //    // ...
                  // }
                  // ---------------------------------------------------
              }
          });
          sortableInstances.push(instance);
      });
      console.log(`[Sortable Init] ${sortableInstances.length} instâncias criadas/recriadas.`);
  }

  // Calcula e exibe os totais de horas por coluna e o total Kanban
  function updateColumnTotals() {
      console.log("[Column Totals] Iniciando cálculo de totais...");
      let grandTotalRemainingKanban = 0;
      const columns = document.querySelectorAll('.kanban-column');
      const kanbanTotalRemainingHoursEl = document.getElementById('kanbanTotalRemainingHours');
      columns.forEach(column => {
          const columnId = column.dataset.columnId; // Pega o ID da coluna
          const tasksInColumn = column.querySelectorAll('.kanban-task-card');
          const taskCount = tasksInColumn.length; // Conta os cards na coluna
          
          let totalEstimated = 0;
          let totalRemaining = 0;

          // Itera sobre currentTasksData FILTRANDO pela coluna atual
          // Isso garante que estamos usando os dados mais recentes, não o DOM
          currentTasksData.filter(task => task.column_id == columnId).forEach(taskData => {
               totalEstimated += taskData.estimated_hours || 0;
               totalRemaining += taskData.remaining_hours || 0;
          });
          
          // Atualiza os elementos no DOM
          const countEl = column.querySelector('.task-count .count-value');
          const estimatedEl = column.querySelector('.total-estimated');
          const remainingEl = column.querySelector('.total-remaining');
          
          if (countEl) countEl.textContent = taskCount; // Usa a contagem do DOM
          else console.warn(`Count element not found in column ID ${columnId}`);
          
          if (estimatedEl) estimatedEl.textContent = totalEstimated.toFixed(1);
          else console.warn(`Estimated element not found in column ID ${columnId}`);
          
          if (remainingEl) remainingEl.textContent = totalRemaining.toFixed(1);
           else console.warn(`Remaining element not found in column ID ${columnId}`);

          grandTotalRemainingKanban += totalRemaining; // Soma para o total geral
      });
      
      // Atualiza o total geral no cabeçalho da página
      if (kanbanTotalRemainingHoursEl) {
          kanbanTotalRemainingHoursEl.textContent = grandTotalRemainingKanban.toFixed(1);
      } else {
          console.warn("[Column Totals] Elemento #kanbanTotalRemainingHours não encontrado.");
      }
      console.log("[Column Totals] Cálculo de totais concluído. Total Kanban Restante:", grandTotalRemainingKanban.toFixed(1));
  }

  // !!! DEFINIÇÃO DE RENDER TASKS !!!
  function renderTasks(tasks) {
      console.log("[Render Tasks] Iniciando renderização. Tarefas recebidas (tipo inicial):", typeof tasks, tasks);
      let parsedTasks = [];
      if (typeof tasks === 'string' && tasks !== '[]') {
          try {
              parsedTasks = JSON.parse(tasks);
          } catch (e) {
              console.error("Erro ao fazer parse das tarefas JSON:", e);
              parsedTasks = [];
          }
      } else if (Array.isArray(tasks)) {
          parsedTasks = tasks;
      } else {
           console.warn("Tipo inesperado ou string vazia para initialTasks, usando array vazio.");
           parsedTasks = [];
      }
      currentTasksData = parsedTasks;
      const boardStatus = document.getElementById('boardStatus');
      const kanbanBoard = document.getElementById('kanbanBoard');
      const addTaskBtn = document.getElementById('addTaskBtn');
      clearBoard();
      if (currentTasksData.length > 0) {
          // Ordena por posição ANTES de renderizar
          currentTasksData.sort((a, b) => (a.position != null ? a.position : Infinity) - (b.position != null ? b.position : Infinity));
          
          currentTasksData.forEach(task => addTaskToBoard(task)); // Adiciona cada card ao DOM
          
          // Esconde mensagem de status, mostra quadro, habilita botão Add
          if (boardStatus && boardStatus.style.display !== 'none') {
              boardStatus.style.display = 'none'; 
          }
          if (kanbanBoard) kanbanBoard.style.display = 'flex'; 
          if (addTaskBtn) addTaskBtn.disabled = !initialBacklogId; 
      } else {
           // Quadro está vazio
           if (initialBacklogId) { // Se temos um backlog, mostra msg "nenhuma tarefa"
               if(boardStatus && boardStatus.style.display === 'none') { // Só mostra se já não estiver visível
                   showBoardStatus('Nenhuma tarefa neste backlog. Adicione uma nova tarefa!', 'info', true); // True para mostrar o board vazio
               }
               if (kanbanBoard) kanbanBoard.style.display = 'flex'; // Mostra o board mesmo vazio
           } else {
               // Sem backlog ID, a mensagem de "Criar Backlog" já deve estar visível (controlado pelo Jinja/JS inicial)
               if (kanbanBoard) kanbanBoard.style.display = 'none'; // Esconde o board se não há backlog
           }
           if (addTaskBtn) addTaskBtn.disabled = !initialBacklogId; // Desabilita Add se não há backlog
      }
      
      // Sempre (re)inicializa sortable e atualiza totais depois de renderizar
      initializeSortable(); 
      updateColumnTotals(); 
      console.log("[Render Tasks] Renderização concluída. Tarefas no quadro:", currentTasksData.length);
  }
  // !!! FIM DA DEFINIÇÃO DE RENDER TASKS !!!

  // --- Fim Funções Essenciais ---

  // Listener para quando o modal é fechado (Mantido)
  const addTaskModalElGlobal = document.getElementById('addTaskModal');
  if (addTaskModalElGlobal) {
      addTaskModalElGlobal.addEventListener('hidden.bs.modal', function (event) {
          console.log("[Modal Hidden] Resetando formulário e estado de edição.");
          const form = document.getElementById('addTaskForm');
          const label = document.getElementById('addTaskModalLabel');
          const deleteBtn = document.getElementById('deleteTaskBtn');
          const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
          const segmentsSummaryDisplay = document.getElementById('taskSegmentsSummaryDisplay'); // Novo
          const completedDateGroup = document.getElementById('completedDateGroup'); // <<< NOVO

          if (form) form.reset();
          editingTaskId = null;
          if (label) label.innerHTML = '<i class="bi bi-plus-square-dotted me-2"></i>Adicionar Nova Tarefa'; // Reset para Adicionar com ícone
          if (deleteBtn) deleteBtn.style.display = 'none';
          if (remainingHoursGroup) remainingHoursGroup.style.display = 'none';
          if (segmentsSummaryDisplay) { // Novo: Limpar resumo dos segmentos
              segmentsSummaryDisplay.innerHTML = '<p class="text-muted m-0">Carregando informações dos segmentos...</p>';
          }
          if (completedDateGroup) completedDateGroup.style.display = 'none'; // <<< NOVO: Ocultar ao fechar

          showLoadingFeedback(false); // Garante que o loading overlay seja escondido
      });
  } else {
      console.error("Elemento do Modal #addTaskModal não encontrado para adicionar listener hidden.bs.modal");
  }

  // Listener para submissão do formulário (Criar/Editar Tarefa) - RESTAURADO E AJUSTADO
  const addTaskFormGlobal = document.getElementById('addTaskForm');
  if (addTaskFormGlobal) {
      addTaskFormGlobal.addEventListener('submit', async function(event) {
          event.preventDefault();
          const form = event.target; // Referência ao formulário

          // --- Coleta Manual de Dados --- 
          const taskData = {};
          taskData.taskId = form.querySelector('#taskId')?.value; // Pode ser vazio na criação
          taskData.name = form.querySelector('#taskName')?.value.trim();
          taskData.description = form.querySelector('#taskDescription')?.value || '';
          taskData.priority = form.querySelector('#taskPriority')?.value || 'Média';
          
          // Leitura explícita e parse das horas
          const estimatedStr = form.querySelector('#taskEstimatedHours')?.value;
          const remainingStr = form.querySelector('#taskRemainingHours')?.value;
          taskData.estimated_hours = estimatedStr ? parseFloat(estimatedStr) : null;
          taskData.remaining_hours = remainingStr ? parseFloat(remainingStr) : taskData.estimated_hours;

          // Leitura explícita das datas
          taskData.start_date = form.querySelector('#taskStartDate')?.value || null;
          taskData.due_date = form.querySelector('#taskDueDate')?.value || null;
          taskData.completed_at = form.querySelector('#taskCompletedDate')?.value || null; // <<< NOVO

          // <<< INÍCIO: Ler campo Especialista (agora um select) >>>
          const selectedSpecialist = form.querySelector('#taskSpecialist')?.value;
          taskData.specialist_name = selectedSpecialist || null; // Se for string vazia (opção padrão), envia null
          // <<< FIM: Ler campo Especialista (agora um select) >>>

          // DEBUG: Logar o valor RAW das datas para verificar formato YYYY-MM-DD
          console.log("[Form Submit] Raw Date Values - Start:", form.querySelector('#taskStartDate')?.value, "Due:", form.querySelector('#taskDueDate')?.value);

          console.log("[Form Submit] Dados coletados MANUALMENTE:", taskData);

          // Validação básica
          if (!taskData.name) {
              alert("O nome da tarefa é obrigatório.");
              return;
          }
          const isEditing = !!editingTaskId; 
          if (!isEditing && !initialBacklogId) {
              alert("Erro: ID do backlog não definido. Não é possível criar a tarefa.");
              return;
          }
          
          // Ajuste URLs e Método
          const url = isEditing ? `/backlog/api/tasks/${editingTaskId}` : `/backlog/api/backlogs/${initialBacklogId}/tasks`;
          const method = isEditing ? 'PUT' : 'POST';

          console.log(`[Form Submit] ${isEditing ? 'Editando' : 'Criando'} Tarefa ID: ${editingTaskId || '(novo)'}. URL: ${url}, Method: ${method}`);

          // Ajusta payload para Criação vs Edição
          let payload = { ...taskData }; // Cria cópia para modificar
          delete payload.taskId; // Remove o campo taskId do payload final em ambos os casos

          if (!isEditing) {
              payload.backlog_id = initialBacklogId ? parseInt(initialBacklogId, 10) : null; // Converte para Inteiro
              // Define a coluna inicial como a primeira coluna visível
              const firstColumnEl = document.querySelector('.kanban-column[data-column-id]');
              const firstColumnIdStr = firstColumnEl ? firstColumnEl.dataset.columnId : null;
              payload.column_id = firstColumnIdStr ? parseInt(firstColumnIdStr, 10) : null; // Converte para Inteiro
              if (!payload.column_id) {
                  alert("Erro crítico: Não foi possível determinar a coluna inicial para a nova tarefa.");
                  showLoadingFeedback(false); // Esconder loading
                  return;
              }
               // Define posição inicial como 0 (topo da coluna)
               payload.position = 0; 
          } else {
               // Para edição (PUT /tasks/{id}), não precisamos enviar backlog_id, column_id ou position no payload principal.
               // A API /move é usada para isso.
               delete payload.backlog_id;
               delete payload.column_id;
               delete payload.position;
          } 

          console.log("[Form Submit] Payload FINAL a enviar:", payload);

          showLoadingFeedback(true);
          try {
              const response = await fetch(url, {
                  method: method,
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
              });

              console.log(`[Form Submit] Resposta API (${response.status}):`, response);
              if (!response.ok) {
                  let errorMsg = `Erro ${response.status}`;
                  try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                  throw new Error(errorMsg);
              }

              const savedTask = await response.json();
              console.log("[Form Submit] Tarefa salva/atualizada:", savedTask);

              // Atualiza a UI e os dados locais
              const taskIndex = currentTasksData.findIndex(t => t.id == savedTask.id);
              if (taskIndex > -1) {
                  currentTasksData[taskIndex] = savedTask; // Atualiza
              } else {
                  currentTasksData.push(savedTask); // Adiciona se for nova
              }
              
              // Re-renderiza tudo para garantir consistência
              renderTasks(currentTasksData);

              const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal);
              if (modalInstance) modalInstance.hide();

              // Limpar formulário e esconder modal
              // modal.hide(); // ERRO: modal não está definido, removido
              
              // Atualiza totais e inicializa Sortable
              updateColumnTotals();
              
              // Atualizar linha do tempo ao criar uma nova tarefa
              updateTimelineTasks();
              
              console.log("[Task Created] Tarefa criada com sucesso");
          } catch (error) {
              console.error('[Form Submit] Erro:', error);
              alert(`Erro ao ${isEditing ? 'salvar' : 'criar'} tarefa: ${error.message}`);
          } finally {
              showLoadingFeedback(false);
          }
      });
  } else {
       console.error("Elemento #addTaskForm não encontrado para adicionar listener submit");
  }

  // Listener para o botão Excluir Tarefa - RESTAURADO
  const deleteTaskBtnGlobal = document.getElementById('deleteTaskBtn');
  if (deleteTaskBtnGlobal) {
      deleteTaskBtnGlobal.addEventListener('click', async function() {
          if (!editingTaskId) return;

          if (confirm('Tem certeza que deseja excluir esta tarefa?')) {
              console.log(`[Delete Task] Solicitando exclusão da Tarefa ID: ${editingTaskId}`);
              showLoadingFeedback(true);
              try {
                  const response = await fetch(`/backlog/api/tasks/${editingTaskId}`, { method: 'DELETE' });
                  console.log(`[Delete Task] Resposta API (${response.status}):`, response);

                  if (!response.ok && response.status !== 204) { // 204 No Content também é sucesso
                      let errorMsg = `Erro ${response.status}`;
                      try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {} 
                      throw new Error(errorMsg);
                  }

                  console.log("[Delete Task] Tarefa excluída com sucesso da API.");
                  
                  // Encontra o card no DOM para remover ANTES de re-renderizar tudo
                  const taskCardElement = document.querySelector(`.kanban-task-card[data-task-id="${editingTaskId}"]`);
                  if (taskCardElement) {
                       const parentColumn = taskCardElement.closest('.kanban-tasks');
                       taskCardElement.remove();
                       console.log("[Delete Task] Card removido do DOM.");
                       // Verifica se a coluna ficou vazia após remover
                       if (parentColumn && !parentColumn.querySelector('.kanban-task-card')) {
                           const noTasksDiv = document.createElement('div');
                           noTasksDiv.className = 'no-tasks';
                           noTasksDiv.textContent = 'Nenhuma tarefa nesta coluna.';
                           parentColumn.appendChild(noTasksDiv);
                           console.log(`[Delete Task] Coluna ID ${parentColumn.dataset.columnId} ficou vazia, adicionada msg.`);
                       }
                  } else {
                       console.warn(`[Delete Task] Card com ID ${editingTaskId} não encontrado no DOM para remoção visual imediata.`);
                  }

                  // Remove a tarefa dos dados locais
                  currentTasksData = currentTasksData.filter(t => t.id != editingTaskId);
                  console.log("[Delete Task] Tarefa removida do array currentTasksData.");
                  
                  // Atualiza os totais das colunas e o total geral (sem re-renderizar tudo)
                  updateColumnTotals(); 

                  const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal);
                  if (modalInstance) modalInstance.hide();

                  // Atualizar linha do tempo ao excluir uma tarefa
                  updateTimelineTasks();

                  console.log("[Task Deleted] Tarefa excluída com sucesso");

              } catch (error) {
                  console.error('[Delete Task] Erro:', error);
                  alert(`Erro ao excluir tarefa: ${error.message}`);
              } finally {
                  showLoadingFeedback(false);
                  editingTaskId = null; // Limpa ID de edição após tentativa
              }
          }
      });
  } else {
       console.error("Elemento #deleteTaskBtn não encontrado para adicionar listener click");
  }
  
  // --- Listener para o botão "Adicionar Tarefa" (estático) - RESTAURADO ---
  const addTaskBtnGlobal = document.getElementById('addTaskBtn');
  if (addTaskBtnGlobal) {
      addTaskBtnGlobal.addEventListener('click', () => {
          if (!initialBacklogId) {
              alert("Não é possível adicionar tarefas sem um backlog ativo.");
              return;
          }
          console.log("[Add Task Button] Clicked. Opening modal.");
          // Reseta o formulário E o estado de edição
          editingTaskId = null; // Garante que está no modo CRIAR
          const form = document.getElementById('addTaskForm');
          const label = document.getElementById('addTaskModalLabel');
          const deleteBtn = document.getElementById('deleteTaskBtn');
          const remainingHoursGroup = document.getElementById('remainingHoursGroup'); // Seleciona o grupo
          if(form) form.reset();
          // Define título e ícone para CRIAÇÃO
          if(label) label.innerHTML = '<i class="bi bi-plus-square-dotted me-2"></i>Adicionar Nova Tarefa'; 
          if(deleteBtn) deleteBtn.style.display = 'none';
          if(remainingHoursGroup) remainingHoursGroup.style.display = 'none'; // *** ESCONDE HORAS RESTANTES NA CRIAÇÃO ***
          const completedDateGroup = document.getElementById('completedDateGroup'); // <<< NOVO
          if(completedDateGroup) completedDateGroup.style.display = 'none'; // <<< NOVO: Ocultar na criação
          showLoadingFeedback(false);
          
          // Foca no campo nome ao abrir para criação
          const taskNameInput = addTaskModalElGlobal?.querySelector('#taskName');
          // Adiciona um pequeno delay para garantir que o modal esteja visível antes de focar
          addTaskModalElGlobal?.addEventListener('shown.bs.modal', () => {
                if (taskNameInput) {
                     taskNameInput.focus();
                }
          }, { once: true }); // Listener é removido após ser acionado uma vez

          const modalInstance = bootstrap.Modal.getInstance(addTaskModalElGlobal) || new bootstrap.Modal(addTaskModalElGlobal);
          modalInstance.show();
      });
  } else { console.error("Botão #addTaskBtn não encontrado."); }

  document.addEventListener('DOMContentLoaded', function () {
    console.log("[Board Init] Inicialização do quadro concluída (JS simplificado).");
    console.log("[Board Init] Tarefas iniciais recebidas:", initialTasks);
    console.log(`[Board Init] Projeto: ${projectNameForLogs} (ID: ${initialProjectId}), Backlog ID: ${initialBacklogId || 'Nenhum'}`);

    // *** CONTROLE DE VISIBILIDADE INICIAL DO QUADRO ***
    const kanbanBoardElement = document.getElementById('kanbanBoard');
    if (kanbanBoardElement) {
        kanbanBoardElement.style.display = initialBacklogId ? 'flex' : 'none';
    } else {
        console.error("#kanbanBoard não encontrado durante inicialização.");
    }
    // ****************************************************

    // *** CHAMADA ESSENCIAL PARA RENDERIZAR AS TAREFAS ***
    renderTasks(initialTasks);
    // ****************************************************

    // <<< INÍCIO: Chamar carregamento de especialistas >>>
    loadSpecialistOptions();
    // <<< FIM: Chamar carregamento de especialistas >>>

    // *** CARREGAMENTO INICIAL DOS MARCOS ***
    loadMilestones();
    
    // Adicionar botão de teste no console para facilitar depuração
    console.log("Para testar a renderização de marcos diretamente, execute: testRenderMilestones()");
    // *** FIM CARREGAMENTO DOS MARCOS ***

    // Adicionar Event Listeners para Marcos
    if (addMilestoneBtn) {
        addMilestoneBtn.addEventListener('click', () => openMilestoneModal());
    }
    
    // IMPORTANTE: Registrar listener para o formulário de marcos
    if (milestoneForm) {
        milestoneForm.addEventListener('submit', handleMilestoneFormSubmit);
        console.log("[Milestone Form] Listener de submit registrado");
    } else {
        console.error("[Milestone Form] Elemento milestoneForm não encontrado para adicionar listener");
    }
    
    // Adicionar listener para o botão de recarregar marcos
    const reloadMilestonesBtn = document.getElementById('reloadMilestonesBtn');
    if (reloadMilestonesBtn) {
        reloadMilestonesBtn.addEventListener('click', () => {
            console.log("[Recarregar] Solicitando recarregamento manual de marcos...");
            loadMilestones(); // Sempre usa o método normal agora que corrigimos
        });
    }
    
    if (deleteMilestoneBtn) {
        deleteMilestoneBtn.addEventListener('click', () => {
            const milestoneId = milestoneIdInput.value;
            const milestoneName = document.getElementById('milestoneName').value; 
            if (milestoneId) {
                confirmDeleteMilestone(milestoneId, milestoneName);
            }
        });
    }

    // Inicializar a linha do tempo após um breve atraso
    setTimeout(updateTimelineTasks, 1500);
  }); // Fecha o DOMContentLoaded
  
  // Handle form submit para marcos
  async function handleMilestoneFormSubmit(event) {
      event.preventDefault();
      
      console.log("[Milestone Form] Processando envio do formulário");
      
      if (!milestoneForm) {
          console.error("[Milestone Form] Formulário não encontrado");
          return;
      }
      
      // Obter ID do backlog atual
      const currentBacklogIdFromDOM = document.getElementById('currentBacklogId')?.value;
      if (!currentBacklogIdFromDOM) {
          console.error("[Milestone Form] ID do backlog não encontrado");
          showToast("Erro: ID do backlog não encontrado", "error");
          return;
      }
      
      // Obter valor do ID (se estiver editando)
      const milestoneId = milestoneIdInput.value;
      const isEditing = !!milestoneId;
      
      // Mostrar loading
      showModalLoading(milestoneModalElement, true);
      
      try {
          // Preparar dados do formulário
          const formData = {
              name: document.getElementById('milestoneName').value,
              description: document.getElementById('milestoneDescription').value,
              planned_date: document.getElementById('milestonePlannedDate').value,
              actual_date: document.getElementById('milestoneActualDate').value || null,
              status: document.getElementById('milestoneStatus').value,
              criticality: document.getElementById('milestoneCriticality').value,
              is_checkpoint: document.getElementById('milestoneIsCheckpoint').checked,
              backlog_id: parseInt(currentBacklogIdFromDOM, 10)
          };
          
          console.log(`[Milestone Form] ${isEditing ? 'Editando' : 'Criando'} marco:`, formData);
          
          // Determinar URL e método com base em criação/edição
          const url = isEditing 
              ? `/backlog/api/milestones/${milestoneId}` 
              : `/backlog/api/milestones`;  // CORRIGIDO: URL para criação de marcos
          const method = isEditing ? 'PUT' : 'POST';
          
          // Enviar para a API
          const response = await fetch(url, {
              method: method,
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(formData)
          });
          
          // Verificar resposta
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
          }
          
          // Processar sucesso
          const savedMilestone = await response.json();
          console.log(`[Milestone Form] Marco ${isEditing ? 'atualizado' : 'criado'} com sucesso:`, savedMilestone);
          
          // Mostrar mensagem de sucesso
          showToast(`Marco ${isEditing ? 'atualizado' : 'criado'} com sucesso`, "success");
          
          // Fechar modal
          milestoneModal.hide();
          
          // Recarregar a lista de marcos
          loadMilestones();
          
      } catch (error) {
          console.error('[Milestone Form] Erro:', error);
          showToast(`Erro ao ${isEditing ? 'atualizar' : 'criar'} marco: ${error.message}`, 'error');
      } finally {
          // Esconder loading
          showModalLoading(milestoneModalElement, false);
      }
  }

  // Função de teste para renderizar marcos diretamente com dados fixos
  function testRenderMilestones() {
      console.log("[Test] Testando renderização direta de marcos...");
      
      // PASSO 1: Verificar a estrutura da tabela no DOM
      const tableElement = document.querySelector('table#milestonesTable');
      const tbodyElement = document.getElementById('milestonesTableBody');
      
      console.log("[DOM Inspection] Tabela encontrada:", tableElement);
      console.log("[DOM Inspection] TBODY encontrado:", tbodyElement);
      
      if (tableElement) {
          console.log("[DOM Inspection] Classes da tabela:", tableElement.className);
          console.log("[DOM Inspection] Estrutura da tabela:", tableElement.innerHTML.substring(0, 100) + "...");
      }
      
      if (tbodyElement) {
          console.log("[DOM Inspection] Classes do tbody:", tbodyElement.className);
          console.log("[DOM Inspection] Conteúdo atual do tbody:", tbodyElement.innerHTML);
      }
      
      // PASSO 2: Tentar inserir uma linha manualmente para teste
      if (tbodyElement) {
          const testRow = document.createElement('tr');
          testRow.innerHTML = `
              <td>TESTE MANUAL</td>
              <td>15/05/2025</td>
              <td>-</td>
              <td><span class="badge bg-primary">Pendente</span></td>
              <td><span class="badge bg-info text-dark">Média</span></td>
              <td>
                  <button class="btn btn-outline-primary btn-sm" title="Editar">
                      <i class="bi bi-pencil-fill"></i>
                  </button>
                  <button class="btn btn-outline-danger btn-sm" title="Excluir">
                      <i class="bi bi-trash-fill"></i>
                  </button>
              </td>
          `;
          console.log("[Test] Adicionando linha de teste manualmente");
          tbodyElement.appendChild(testRow);
          console.log("[Test] Adicionada linha de teste. Novo conteúdo:", tbodyElement.innerHTML);
      }
      
      // PASSO 3: Renderizar os dados de teste normalmente
      const mockMilestones = [
          {
              id: 999,
              name: "Marco de Teste",
              planned_date: "2025-05-15",
              actual_date: null,
              status: "Pendente",
              criticality: "Média",
              is_checkpoint: false,
              is_delayed: false,
              backlog_id: 4
          }
      ];
      
      console.log("[Test] Dados de teste:", mockMilestones);
      renderMilestones(mockMilestones);
      
      // PASSO 4: Verificar o resultado após a renderização normal
      console.log("[Test] Renderização direta concluída. Conteúdo do tbody:", document.getElementById('milestonesTableBody')?.innerHTML || "Não encontrado");
  }
  
  // Função para forçar o preenchimento direto da tabela (ignorando renderMilestones)
  function forceFillMilestonesTable() {
      console.log("[Force Fill] Tentando preencher diretamente a tabela...");
      
      // Encontra o tbody
      const tbody = document.getElementById('milestonesTableBody');
      if (!tbody) {
          console.error("[Force Fill] TBODY não encontrado!");
          return;
      }
      
      // Limpa o conteúdo atual
      tbody.innerHTML = '';
      
      // Cria uma linha de teste 
      const tr = document.createElement('tr');
      tr.innerHTML = `
          <td>Marco Teste Direto</td>
          <td>15/05/2025</td>
          <td>-</td>
          <td><span class="badge bg-warning text-dark">Em Andamento</span></td>
          <td><span class="badge bg-info text-dark">Média</span></td>
          <td>
              <button class="btn btn-outline-primary btn-sm" title="Editar Marco">
                  <i class="bi bi-pencil-fill"></i>
              </button>
              <button class="btn btn-outline-danger btn-sm" title="Excluir Marco">
                  <i class="bi bi-trash-fill"></i>
              </button>
          </td>
      `;
      
      // Adiciona a linha ao tbody
      tbody.appendChild(tr);
      
      console.log("[Force Fill] Linha adicionada diretamente:", tr.outerHTML);
      console.log("[Force Fill] Conteúdo atual do tbody:", tbody.innerHTML);
  }

  // <<< INÍCIO: Função para carregar opções de especialista >>>
  async function loadSpecialistOptions() {
      const specialistSelect = document.getElementById('taskSpecialist');
      if (!specialistSelect) {
          console.error("Elemento select #taskSpecialist não encontrado para carregar opções.");
          return;
      }
      
      try {
          const response = await fetch('/backlog/api/available-specialists');
          if (!response.ok) {
              throw new Error(`Erro ${response.status} ao buscar especialistas`);
          }
          const specialists = await response.json();
          console.log("[Specialists Load] Lista recebida:", specialists);
          
          // Limpa opções existentes (exceto a primeira "-- Padrão --")
          specialistSelect.options.length = 1; 
          
          // Adiciona novas opções
          specialists.forEach(name => {
              const option = document.createElement('option');
              option.value = name;
              option.textContent = name;
              specialistSelect.appendChild(option);
          });
           console.log(`[Specialists Load] ${specialists.length} opções adicionadas ao select.`);
      } catch (error) {
          console.error("[Specialists Load] Erro ao carregar opções de especialista:", error);
          // Poderia mostrar um alerta ou manter o select vazio/desabilitado
      }
  }
  // <<< FIM: Função para carregar opções de especialista >>>

  // *** INÍCIO: LÓGICA PARA MARCOS (Milestones) ***

  // Função para mostrar indicador de carregamento
  function showLoadingIndicator(container, isLoading, colspan = 3, message = 'Carregando...') {
      if (!container) return;
      if (isLoading) {
          container.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-muted small py-3"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"><span class="visually-hidden">Loading...</span></div>${message}</td></tr>`;
      } else {
          // Se a mensagem for de erro ou "sem itens", mostra a mensagem
          if (message && (message.startsWith('Erro') || message.startsWith('Nenhum'))) {
               container.innerHTML = `<tr><td colspan="${colspan}" class="text-center text-muted small py-3">${message}</td></tr>`;
          } else {
               // Se não for loading e não for mensagem especial, limpa (a renderização cuidará do resto)
               container.innerHTML = ''; 
          }
      }
  }

  // Função para mostrar toast (mensagem flutuante)
  function showToast(message, type = 'info') {
      // Implementação básica por enquanto - apenas alerta
      console.log(`[Toast] ${type.toUpperCase()}: ${message}`);
      alert(`${type.toUpperCase()}: ${message}`);
  }

  // Função para mostrar/esconder overlay de loading em modais
  function showModalLoading(modalElem, isLoading) {
      if (!modalElem) return;
      const overlay = modalElem.querySelector('.loading-overlay');
      const formElements = modalElem.querySelectorAll('input, textarea, select, button');
      if (overlay) {
          overlay.style.display = isLoading ? 'flex' : 'none';
      }
      formElements.forEach(el => el.disabled = isLoading);
  }

  // Função para carregar marcos da API
  async function loadMilestones() {
      console.log('[Milestones] Iniciando carregamento...');
      const milestonesTableBody = document.getElementById('milestonesTableBody');
      
      if (!milestonesTableBody) {
          console.error("[Milestones] Elemento milestonesTableBody não encontrado");
          return;
      }
      
      const backlogId = document.getElementById('currentBacklogId')?.value;
      if (!backlogId) {
          console.warn("[Milestones] ID do backlog não encontrado");
          showNoDataMessage(milestonesTableBody, 'Selecione um projeto para ver os marcos.');
          return;
      }
      
      showLoadingMessage(milestonesTableBody, 'Carregando marcos...');
      console.log(`[Milestones] Buscando marcos para backlog ${backlogId}`);

      try {
          const response = await fetch(`/backlog/api/backlogs/${backlogId}/milestones`);
          console.log(`[Milestones] Resposta da API: ${response.status}`);
          
          if (!response.ok) {
              throw new Error(`Erro ${response.status} ao carregar marcos`);
          }
          
          const milestones = await response.json();
          console.log(`[Milestones] Dados recebidos:`, milestones);
          
          if (!milestones || milestones.length === 0) {
              showNoDataMessage(milestonesTableBody, 'Nenhum marco cadastrado para este projeto.');
              return;
          }
          
          // Limpa a tabela
          milestonesTableBody.innerHTML = '';

          // Renderiza cada marco
          milestones.forEach(milestone => {
              const tr = document.createElement('tr');
              tr.dataset.milestoneId = milestone.id;

              // Define classes para badges
              let statusClass = milestone.status?.toLowerCase() === "concluído" ? "bg-success" :
                              milestone.status?.toLowerCase() === "em andamento" ? "bg-warning text-dark" :
                              milestone.status?.toLowerCase() === "atrasado" || milestone.is_delayed ? "bg-danger" :
                              "bg-secondary";

              let criticalityClass = milestone.criticality?.toLowerCase() === "crítica" ? "bg-danger" :
                                   milestone.criticality?.toLowerCase() === "alta" ? "bg-warning text-dark" :
                                   milestone.criticality?.toLowerCase() === "média" ? "bg-info text-dark" :
                                   "bg-secondary";
                  
                  // Formata datas
                  const plannedDate = milestone.planned_date ? formatDateString(milestone.planned_date) : "-";
                  const actualDate = milestone.actual_date ? formatDateString(milestone.actual_date) : "-";
                  
                  tr.innerHTML = `
                  <td>${escapeHtml(milestone.name)} ${milestone.is_checkpoint ? '<i class="bi bi-patch-check-fill text-primary" title="Checkpoint"></i>' : ''}</td>
                      <td>${plannedDate}</td>
                      <td>${actualDate}</td>
                      <td><span class="badge ${statusClass}">${escapeHtml(milestone.status || 'Pendente')}</span></td>
                      <td><span class="badge ${criticalityClass}">${escapeHtml(milestone.criticality || 'Média')}</span></td>
                      <td>
                          <button class="btn btn-outline-primary btn-sm edit-milestone-btn" title="Editar Marco">
                              <i class="bi bi-pencil-fill"></i>
                          </button>
                      <button class="btn btn-outline-danger btn-sm delete-milestone-btn" title="Excluir Marco">
                              <i class="bi bi-trash-fill"></i>
                          </button>
                      </td>
                  `;
                  
                  milestonesTableBody.appendChild(tr);
                  
              // Adiciona event listeners
                  const editBtn = tr.querySelector('.edit-milestone-btn');
              const deleteBtn = tr.querySelector('.delete-milestone-btn');

                  if (editBtn) {
                  editBtn.addEventListener('click', () => openMilestoneModal(milestone.id));
                  }
                  if (deleteBtn) {
                  deleteBtn.addEventListener('click', () => confirmDeleteMilestone(milestone.id, milestone.name));
              }
          });

          console.log('[Milestones] Renderização concluída com sucesso');
          
      } catch (error) {
          console.error("[Milestones] Erro:", error);
          showErrorMessage(milestonesTableBody, `Erro ao carregar marcos: ${error.message}`);
      }
  }

  // Função para renderizar os marcos na tabela
  function renderMilestones(milestones) {
      if (!milestonesTableBody) {
          console.error("[Milestones] Elemento milestonesTableBody não encontrado no DOM");
          return;
      }
      
      console.log("[Milestones] Renderizando", milestones.length, "marcos", milestones);
      
      // CORREÇÃO: Verificar e converter para array se necessário
      let milestonesArray = milestones;
      if (!Array.isArray(milestones)) {
          try {
              milestonesArray = JSON.parse(milestones);
              console.log("[Milestones] Convertido de string JSON para array:", milestonesArray);
          } catch (e) {
              console.error("[Milestones] Erro ao converter dados de marcos:", e);
              milestonesArray = [];
          }
      }
      
      // Limpa a tabela
      milestonesTableBody.innerHTML = ''; // Limpa a tabela
      
      // CORREÇÃO: Verificação de array vazio revisada
      if (!milestonesArray || milestonesArray.length === 0) {
          milestonesTableBody.innerHTML = `
              <tr>
                  <td colspan="6" class="text-center text-muted small">
                      <i class="bi bi-info-circle me-1"></i> Nenhum marco definido para este projeto.
                  </td>
              </tr>
          `;
          console.log("[Milestones] Nenhum marco encontrado para exibir");
          return;
      }

      // CORREÇÃO: Abordagem simplificada para garantir que funcione
      console.log("[Milestones] Tentando abordagem direta para renderização");
      
      // Cria uma string HTML com todas as linhas
      let rowsHtml = '';
      
      milestonesArray.forEach((milestone, index) => {
          try {
              // Status e criticidade
              let statusClass = "bg-secondary"; // Default
              if (milestone.status && milestone.status.toLowerCase() === "concluído") statusClass = "bg-success";
              else if (milestone.status && milestone.status.toLowerCase() === "em andamento") statusClass = "bg-primary";
              else if (milestone.status && milestone.status.toLowerCase() === "atrasado" || milestone.is_delayed) statusClass = "bg-danger";
              
              let criticalityClass = "bg-secondary"; // Default
              if (milestone.criticality && milestone.criticality.toLowerCase() === "crítica") criticalityClass = "bg-danger";
              else if (milestone.criticality && milestone.criticality.toLowerCase() === "alta") criticalityClass = "bg-warning text-dark";
              else if (milestone.criticality && milestone.criticality.toLowerCase() === "média") criticalityClass = "bg-info text-dark";
              
              // Formata datas
              const plannedDate = milestone.planned_date ? formatDateString(milestone.planned_date) : "-";
              const actualDate = milestone.actual_date ? formatDateString(milestone.actual_date) : "-";
              
              // Cria linha HTML
              rowsHtml += `
                  <tr data-milestone-id="${milestone.id}">
                      <td>${escapeHtml(milestone.name)} ${milestone.is_checkpoint ? '<i class="bi bi-patch-check-fill text-primary" title="Checkpoint"></i>' : ''}</td>
                      <td>${plannedDate}</td>
                      <td>${actualDate}</td>
                      <td><span class="badge ${statusClass}">${escapeHtml(milestone.status || 'Pendente')}</span></td>
                      <td><span class="badge ${criticalityClass}">${escapeHtml(milestone.criticality || 'Média')}</span></td>
                      <td>
                          <button class="btn btn-outline-primary btn-sm edit-milestone-btn" title="Editar Marco">
                              <i class="bi bi-pencil-fill"></i>
                          </button>
                          <button class="btn btn-outline-danger btn-sm delete-milestone-btn" title="Excluir Marco">
                              <i class="bi bi-trash-fill"></i>
                          </button>
                      </td>
                  </tr>
              `;
          } catch (error) {
              console.error(`[Milestones] Erro ao processar marco ${index}:`, milestone, error);
              // Continua para o próximo marco em caso de erro
          }
      });
      
      // CORREÇÃO: Define o HTML completo de uma vez
      milestonesTableBody.innerHTML = rowsHtml;
      
      // CORREÇÃO: Adiciona eventos depois de inserir o HTML
      document.querySelectorAll('tr[data-milestone-id]').forEach(tr => {
          const milestoneId = tr.dataset.milestoneId;
          
          // Evento para editar ao clicar na linha (exceto nos botões)
          tr.addEventListener('click', (e) => {
              if (!e.target.closest('button')) {
                  openMilestoneModal(milestoneId);
              }
          });
          
          // Evento para botão editar
          const editBtn = tr.querySelector('.edit-milestone-btn');
          if (editBtn) {
              editBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  openMilestoneModal(milestoneId);
              });
          }
          
          // Evento para botão excluir
          const deleteBtn = tr.querySelector('.delete-milestone-btn');
          if (deleteBtn) {
              console.log('[Debug Delete Click] Botão de deletar clicado! Marco ID:', milestone.id, 'Nome:', milestone.name);
              e.stopPropagation();
              confirmDeleteMilestone(milestone.id, milestone.name);
          }
      });
      
      console.log("[Milestones] Renderização concluída com sucesso. Marcos renderizados:", milestonesArray.length);
  }

  // Função para abrir o modal de marco (criar ou editar)
  function openMilestoneModal(milestoneId = null) {
      if (!milestoneModal || !milestoneForm) {
          console.error("[Modal Open] Elementos do modal não encontrados");
          return;
      }
      
      console.log("[Modal Open] Abrindo modal de marco para ID:", milestoneId);
      milestoneForm.reset(); // Limpa o formulário
      milestoneIdInput.value = milestoneId || ''; // Define ou limpa o ID
      showModalLoading(milestoneModalElement, false); // Esconde loading

      if (milestoneId) {
          // --- Modo Edição ---
          milestoneModalTitle.textContent = 'Editar Marco';
          deleteMilestoneBtn.style.display = 'block'; // Mostra botão excluir
          
          // CORREÇÃO: Busca os dados do marco na lista completa
          showModalLoading(milestoneModalElement, true);
          
          // Obter valor atualizado do backlog ID diretamente do DOM
          const currentBacklogIdFromDOM = document.getElementById('currentBacklogId')?.value;
          
          if (!currentBacklogIdFromDOM) {
              console.error("[Modal Open] Backlog ID não encontrado, não é possível buscar marcos");
              showModalLoading(milestoneModalElement, false);
              showToast('Erro: ID do backlog não encontrado', 'error');
              milestoneModal.hide();
              return;
          }
          
          console.log(`[Modal Open] Buscando todos os marcos do backlog ${currentBacklogIdFromDOM} para filtrar ID ${milestoneId}`);
          
          // Busca todos os marcos e filtra pelo ID desejado
          fetch(`/backlog/api/backlogs/${currentBacklogIdFromDOM}/milestones`)
              .then(response => {
                  if (!response.ok) {
                      console.error(`[Modal Open] Erro ${response.status} ao buscar marcos`);
                      throw new Error(`Erro ao buscar lista de marcos (${response.status})`);
                  }
                  return response.json();
              })
              .then(allMilestones => {
                  console.log(`[Modal Open] Recebidos ${allMilestones.length} marcos, buscando ID ${milestoneId}`, allMilestones);
                  
                  // Filtra pelo ID específico (garantindo conversão para número)
                  const milestone = allMilestones.find(m => Number(m.id) === Number(milestoneId));
                  
                  if (!milestone) {
                      console.error(`[Modal Open] Marco ID ${milestoneId} não encontrado na lista de ${allMilestones.length} marcos`);
                      throw new Error(`Marco ID ${milestoneId} não encontrado na lista`);
                  }
                  
                  console.log("[Modal Open] Marco encontrado para edição:", milestone);
                  
                  // Preenche o formulário com os dados do marco
                  document.getElementById('milestoneName').value = milestone.name || '';
                  document.getElementById('milestoneDescription').value = milestone.description || '';
                  document.getElementById('milestonePlannedDate').value = milestone.planned_date ? milestone.planned_date.substring(0, 10) : '';
                  document.getElementById('milestoneActualDate').value = milestone.actual_date ? milestone.actual_date.substring(0, 10) : '';
                  document.getElementById('milestoneStatus').value = milestone.status || 'Pendente';
                  document.getElementById('milestoneCriticality').value = milestone.criticality || 'Média';
                  document.getElementById('milestoneIsCheckpoint').checked = milestone.is_checkpoint || false;
                  
                  showModalLoading(milestoneModalElement, false);
              })
              .catch(error => {
                  console.error('[Modal Open] Erro ao buscar detalhes do marco:', error);
                  showModalLoading(milestoneModalElement, false);
                  showToast('Erro ao carregar detalhes do marco: ' + error.message, 'error');
                  milestoneModal.hide(); // Fecha o modal se não conseguir carregar
              });
              
      } else {
          // --- Modo Criação ---
          console.log("[Modal Open] Modo criação - formulário limpo");
          milestoneModalTitle.textContent = 'Adicionar Marco';
          deleteMilestoneBtn.style.display = 'none'; // Esconde botão excluir
          // Valores padrão (já definidos no reset ou no HTML)
      }
      
      milestoneModal.show();
  }

  // Adicionar a função formatDateString que estava faltando
  function formatDateString(dateStr, isDateTime = false) {
    if (!dateStr) return "-";
    try {
        // Se for apenas uma string de data no formato YYYY-MM-DD (para start_date, due_date)
        if (!isDateTime && /^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
            const parts = dateStr.split('-');
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10); // Mês é 1-12
            const day = parseInt(parts[2], 10);
            if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                return `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}/${year}`;
            }
            return dateStr; // Fallback
        }

        // Para strings de data e hora (ex: completed_at, ou outras que vêm como ISO UTC)
        const date = new Date(dateStr); // new Date() interpreta ISO strings (com Z ou offset) como UTC.
        if (isNaN(date.getTime())) {
            console.warn('[formatDateString] Data inválida recebida:', dateStr);
            return dateStr; // Retorna a string original se a data for inválida
        }

        if (isDateTime) {
            return date.toLocaleString('pt-BR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                timeZone: 'America/Sao_Paulo'
            });
        } else {
            // Se for uma data completa mas queremos exibir só a parte da data no fuso correto
            // (Ex: completed_at que é datetime, mas o card só mostra a data)
            // Para garantir que a DATA seja a correta em Sao_Paulo, mesmo que a hora UTC seja próxima da meia-noite.
            const options = {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                timeZone: 'America/Sao_Paulo'
            };
            return new Intl.DateTimeFormat('pt-BR', options).format(date);
        }
    } catch (e) {
        console.error("Erro ao formatar data:", e, dateStr);
        return dateStr;
    }
}

  // Função para confirmar e excluir um marco
  function confirmDeleteMilestone(milestoneId, milestoneName) {
      if (!milestoneId) {
          console.error("[Delete Milestone] ID do marco não fornecido");
          return;
      }
      
      const confirmMessage = `Tem certeza que deseja excluir o marco "${milestoneName || milestoneId}"?`;
      if (confirm(confirmMessage)) {
          console.log(`[Delete Milestone] Confirmado. Excluindo marco ID: ${milestoneId}`);
          deleteMilestone(milestoneId);
      } else {
          console.log(`[Delete Milestone] Exclusão cancelada pelo usuário para ID: ${milestoneId}`);
      }
  }

  // Função para excluir um marco via API
  async function deleteMilestone(milestoneId) {
      try {
          console.log(`[Delete Milestone] Enviando requisição DELETE para marco ID: ${milestoneId}`);
          const response = await fetch(`/backlog/api/milestones/${milestoneId}`, {
              method: 'DELETE',
              headers: {'Content-Type': 'application/json'}
          });
          
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));
              throw new Error(errorData.message || `Erro HTTP: ${response.status}`);
          }
          
          console.log('[Delete Milestone] Marco excluído com sucesso');
          showToast('Marco excluído com sucesso!', 'success');
          
          // Recarrega a lista de marcos
          loadMilestones();
          
          // Fecha o modal se estiver aberto
          if (milestoneModal) {
              milestoneModal.hide();
          }
      } catch (error) {
          console.error('[Delete Milestone] Erro:', error);
          showToast(`Erro ao excluir marco: ${error.message}`, 'error');
      }
  }

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  // Função para carregar e atualizar tarefas na linha do tempo
  function updateTimelineTasks() {
    console.log("[Timeline] Iniciando carregamento de tarefas da linha do tempo...");
    
    // Elementos DOM para as listas
    const completedTasksList = document.getElementById('completedTasksList');
    const upcomingTasksList = document.getElementById('upcomingTasksList');
    const startedTasksList = document.getElementById('startedTasksList');
    
    if (!completedTasksList || !upcomingTasksList || !startedTasksList) {
        console.error("[Timeline] Elementos de lista não encontrados no DOM");
        return;
    }
    
    // Indicar carregamento
    completedTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    upcomingTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    startedTasksList.innerHTML = '<li class="list-group-item text-center"><div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div> Carregando...</li>';
    
    // Obter ID do backlog atual
    const backlogId = document.getElementById('currentBacklogId')?.value;
    if (!backlogId) {
        console.warn("[Timeline] Nenhum backlog ID encontrado");
        const emptyMessage = '<li class="list-group-item text-center text-muted small">Nenhum backlog associado a este projeto</li>';
        completedTasksList.innerHTML = emptyMessage;
        upcomingTasksList.innerHTML = emptyMessage;
        startedTasksList.innerHTML = emptyMessage;
        return;
    }
    
    // Fazer a requisição à API
    fetch(`/backlog/api/backlogs/${backlogId}/timeline-tasks`)
        .then(response => {
            if (!response.ok) {
                return response.json().then(errorData => {
                    throw new Error(errorData.error || `Status: ${response.status}`);
                }).catch(e => {
                    throw new Error(`Erro HTTP ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log("[Timeline] Dados recebidos:", data);
            
            // Verificar se há mensagem de erro na resposta
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Renderizar tarefas concluídas recentemente
            renderTasksList(completedTasksList, data.recently_completed, 'check-circle-fill', 'text-success', 'Nenhuma tarefa concluída recentemente');
            
            // Renderizar próximas tarefas
            renderTasksList(upcomingTasksList, data.upcoming_tasks, 'calendar-event-fill', 'text-warning', 'Nenhuma tarefa com prazo próximo');
            
            // Renderizar tarefas iniciadas recentemente
            renderTasksList(startedTasksList, data.recently_started, 'play-circle-fill', 'text-primary', 'Nenhuma tarefa iniciada recentemente');
        })
        .catch(error => {
            console.error("[Timeline] Erro ao carregar tarefas da linha do tempo:", error);
            
            // Usar o endpoint de diagnóstico em caso de erro
            fetch(`/backlog/api/debug/timeline-tasks/${backlogId}`)
                .then(diagResponse => diagResponse.json())
                .then(diagData => {
                    console.log("[Timeline] Diagnóstico:", diagData);
                    // Mostrar erro mais específico com base no diagnóstico
                    const errorDetail = diagData.error 
                        ? `<div class="mt-1">${diagData.error}</div>` 
                        : `<div class="mt-1 small">Diagnóstico concluído, verifique o console.</div>`;
                        
                    const errorMessage = `
                        <li class="list-group-item text-center text-danger">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>Erro ao carregar tarefas</strong>
                            <div class="small mt-1">${error.message}</div>
                            ${errorDetail}
                        </li>`;
                        
                    completedTasksList.innerHTML = errorMessage;
                    upcomingTasksList.innerHTML = errorMessage;
                    startedTasksList.innerHTML = errorMessage;
                })
                .catch(diagError => {
                    // Caso o diagnóstico também falhe
                    const errorMessage = `
                        <li class="list-group-item text-center text-danger">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>Erro ao carregar tarefas</strong>
                            <div class="mt-1 small">${error.message}</div>
                            <div class="mt-1 small">Diagnóstico falhou: ${diagError.message}</div>
                        </li>`;
                        
                    completedTasksList.innerHTML = errorMessage;
                    upcomingTasksList.innerHTML = errorMessage;
                    startedTasksList.innerHTML = errorMessage;
                });
        });
  }

  // Função auxiliar para renderizar uma lista de tarefas
  function renderTasksList(listElement, tasks, iconClass, iconColorClass, emptyMessage) {
    if (!tasks || tasks.length === 0) {
        listElement.innerHTML = `<li class="list-group-item text-center text-muted small"><i class="bi bi-info-circle me-2"></i>${emptyMessage}</li>`;
        return;
    }
    
    let html = '';
    tasks.forEach(task => {
        // Formatar data relevante (conclusão, prazo ou início)
        let dateStr = '';
        let dateLabel = '';
        let secondDateStr = '';
        
        if (task.completed_at) {
            dateStr = formatDateString(task.completed_at);
            dateLabel = 'Concluído em';
        } else if (listElement.id === 'upcomingTasksList') {
            // Para próximas tarefas, mostrar tanto início quanto prazo
            let startDateStr = task.start_date ? formatDateString(task.start_date) : '-';
            let dueDateStr = task.due_date ? formatDateString(task.due_date) : '-';
            dateStr = `<span class="small me-2" title="Data de início"><i class="bi bi-calendar-event"></i> ${startDateStr}</span>
                      <span class="small" title="Prazo final"><i class="bi bi-calendar-check"></i> ${dueDateStr}</span>`;
            dateLabel = ''; // Vazio pois já incluímos ícones explicativos
        } else if (task.due_date) {
            dateStr = formatDateString(task.due_date);
            dateLabel = 'Prazo';
        } else if (task.start_date) {
            dateStr = formatDateString(task.start_date);
            dateLabel = 'Iniciado em';
        }
        
        // Determinar ícone de prioridade
        let priorityBadge = '';
        if (task.priority) {
            let priorityClass = 'bg-secondary';
            if (task.priority === 'Alta') priorityClass = 'bg-warning text-dark';
            if (task.priority === 'Urgente') priorityClass = 'bg-danger';
            priorityBadge = `<span class="badge ${priorityClass} me-2">${task.priority}</span>`;
        }
        
        // Criar HTML do item da lista
        html += `
            <li class="list-group-item d-flex justify-content-between align-items-center p-2 task-item" 
                data-task-id="${task.id}" data-bs-toggle="tooltip" title="${escapeHtml(task.description || 'Sem descrição')}">
                <div>
                    <i class="bi bi-${iconClass} ${iconColorClass} me-2"></i>
                    ${priorityBadge}
                    <span class="task-title">${escapeHtml(task.title)}</span>
                </div>
                <div class="text-muted small">
                    ${dateLabel ? `<span class="date-label">${dateLabel}:</span> ` : ''}${dateStr}
                </div>
            </li>
        `;
    });
    
    listElement.innerHTML = html;
    
    // Adicionar evento de clique para editar a tarefa
    listElement.querySelectorAll('.task-item').forEach(item => {
        item.addEventListener('click', () => {
            const taskId = item.dataset.taskId;
            console.log(`[Timeline] Clique na tarefa ID: ${taskId}`);
            // Usar handleTaskClick em vez de editTask
            const taskCard = document.querySelector(`.kanban-task-card[data-task-id="${taskId}"]`);
            if (taskCard) {
                handleTaskClick({currentTarget: taskCard});
            } else {
                console.warn(`[Timeline] Não encontrou taskCard para ID: ${taskId}`);
            }
        });
    });
  }

  // --- Set up initial listeners and page state --- 
  document.addEventListener('DOMContentLoaded', function() {
      console.log("Board DOM loaded");
      
      // Todo o código DOMContentLoaded existente aqui...
      
      // Inicializar a linha do tempo após um breve atraso
      setTimeout(updateTimelineTasks, 1500);
  });

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  // --- Funções Essenciais de Renderização (Definidas fora do DOMContentLoaded) ---
  // (Inclui renderTasks, clearBoard, escapeHtml, etc.)

  // --- LÓGICA PARA RISCOS DO PROJETO ---
  let risksTableBody, addRiskBtn, riskModalElement, riskModal, riskForm, riskModalLabel, currentEditingRiskId = null; // Definir aqui, atribuir em DOMContentLoaded

  function formatDateForDisplay(dateStr) {
      if (!dateStr) return "-";
      try {
          const date = new Date(dateStr);
          // Adiciona verificação se a data é válida, pois new Date(null) ou new Date('') podem não dar erro mas resultar em datas inválidas.
          if (isNaN(date.getTime())) return dateStr; // Retorna a string original se a data for inválida
          return date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
      } catch (e) {
          console.error("Erro ao formatar data para exibição:", e, dateStr);
          return dateStr; // Retorna string original em caso de erro
      }
  }

  function renderRisks(risks = []) {
      if (!risksTableBody) {
          console.error("[Riscos] Elemento risksTableBody não encontrado.");
          return;
      }
      risksTableBody.innerHTML = ''; // Limpa a tabela

      if (!risks || risks.length === 0) {
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Nenhum risco cadastrado para este backlog.</td></tr>`;
          return;
      }

      risks.forEach(risk => {
          const tr = document.createElement('tr');
          tr.dataset.riskId = risk.id;

          // Adaptação para severidade e status, pode precisar de badges como em milestones
          let severityBadge = risk.severity || 'N/A';
          if (risk.severity === 'Crítico') severityBadge = `<span class="badge bg-danger">${risk.severity}</span>`;
          else if (risk.severity === 'Alto') severityBadge = `<span class="badge bg-warning text-dark">${risk.severity}</span>`;
          else if (risk.severity === 'Médio') severityBadge = `<span class="badge bg-info text-dark">${risk.severity}</span>`;
          else if (risk.severity === 'Baixo') severityBadge = `<span class="badge bg-secondary">${risk.severity}</span>`;
          
          let statusBadge = risk.status || 'N/A';
          if (risk.status === 'Ativo') statusBadge = `<span class="badge bg-warning text-dark">${risk.status}</span>`;
          else if (risk.status === 'Mitigado') statusBadge = `<span class="badge bg-info text-dark">${risk.status}</span>`;
          else if (risk.status === 'Resolvido') statusBadge = `<span class="badge bg-success">${risk.status}</span>`;

          tr.innerHTML = `
              <td style="white-space: pre-wrap; word-break: break-word;">${escapeHtml(risk.description)}</td>
              <td class="text-center">${severityBadge}</td>
              <td class="text-center">${statusBadge}</td>
              <td class="text-center">
                  <button class="btn btn-outline-primary btn-sm edit-risk-btn" title="Editar Risco" data-risk-id="${risk.id}">
                      <i class="bi bi-pencil-fill"></i>
                  </button>
                  <button class="btn btn-outline-danger btn-sm delete-risk-btn-inline" title="Excluir Risco" data-risk-id="${risk.id}">
                      <i class="bi bi-trash-fill"></i>
                  </button>
              </td>
          `;
          risksTableBody.appendChild(tr);

          // Adicionar listeners para botões de editar/excluir (a serem implementados)
          const editButton = tr.querySelector('.edit-risk-btn');
          if (editButton) {
              editButton.addEventListener('click', (e) => {
                  e.stopPropagation(); // Previne que o clique na linha também dispare algo, se houver
                  openRiskModal(risk.id);
              });
          }
          const deleteButtonInline = tr.querySelector('.delete-risk-btn-inline');
          if (deleteButtonInline) {
              deleteButtonInline.addEventListener('click', (e) => {
                  console.log('[Debug Risk Delete Click] Botão Inline DELETAR RISCO clicado! Risco ID:', risk.id, 'Descrição:', risk.description);
                  e.stopPropagation();
                  confirmDeleteRisk(risk.id, risk.description); // CHAMADA CORRIGIDA
              });
          }
          // tr.querySelector('.delete-risk-btn-inline').addEventListener('click', () => confirmDeleteRisk(risk.id, risk.description));
      });
      console.log(`[Riscos] ${risks.length} riscos renderizados.`);
  }

  async function loadRisks() {
      if (!risksTableBody) {
          console.error("[Riscos] Tentando carregar riscos, mas risksTableBody não foi encontrado.");
          return;
      }
      const currentBacklogId = document.getElementById('currentBacklogId')?.value;
      if (!currentBacklogId) {
          console.log("[Riscos] ID do Backlog não encontrado, pulando carregamento de riscos.");
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Selecione um backlog para ver os riscos.</td></tr>`;
          return;
      }

      console.log(`[Riscos] Carregando riscos para Backlog ID: ${currentBacklogId}`);
      risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small py-3"><div class="spinner-border spinner-border-sm text-primary me-2"></div>Carregando riscos...</td></tr>`;

      try {
          const response = await fetch(`/backlog/api/backlogs/${currentBacklogId}/risks`); // <-- ADICIONAR /backlog AQUI
          if (!response.ok) {
              let errorMsg = `Erro HTTP: ${response.status}`;
              try {
                  const errorData = await response.json();
                  errorMsg = errorData.message || errorData.description || errorMsg;
              } catch (e) { /* Ignora erro no parse do JSON de erro */ }
              throw new Error(errorMsg);
          }
          const risks = await response.json();
          console.log("[Riscos] Riscos recebidos da API:", risks);
          renderRisks(risks);
      } catch (error) {
          console.error("[Riscos] Erro ao carregar riscos:", error);
          risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-danger small"><i class="bi bi-exclamation-triangle-fill me-1"></i>Erro ao carregar riscos: ${error.message}</td></tr>`;
      }
  }

  // Adicionar listener para o botão "Novo Risco" (a ser implementado)
  // if (addRiskBtn) {
  //     addRiskBtn.addEventListener('click', () => openRiskModal()); 
  // }
  
  // Função para abrir modal de risco (a ser implementada)
  async function openRiskModal(riskId = null) { // <-- ADICIONADO ASYNC AQUI
    if (!riskModal || !riskForm || !riskModalLabel) {
        console.error("[Risk Modal] Elementos do modal de risco não encontrados (modal, form ou label).");
        return;
    }
    riskForm.reset(); 
    // const riskIdInput = riskForm.querySelector('input[name="riskId"]'); // Exemplo se tivesse um input hidden para ID
    // if(riskIdInput) riskIdInput.value = riskId || '';

    if (riskId) {
        riskModalLabel.textContent = 'Editar Risco';
        currentEditingRiskId = riskId; // Guarda o ID do risco que está sendo editado
        // TODO: Mostrar botão de excluir (se houver um)

        // Busca dados do risco para popular o formulário
        // Adiciona feedback de loading no modal ANTES de buscar
        const formFields = riskForm.elements;
        for (let i = 0; i < formFields.length; i++) {
            formFields[i].disabled = true;
        }
        riskModalLabel.innerHTML = '<i class="spinner-border spinner-border-sm"></i> Carregando Risco...'; 

        try {
            const response = await fetch(`/backlog/api/risks/${riskId}`);
            if (!response.ok) {
                let errorMsg = `Erro ao carregar dados do risco: ${response.status}`;
                try { const errData = await response.json(); errorMsg = errData.message || errData.description || errorMsg; } catch(e){}
                throw new Error(errorMsg);
            }
            const riskData = await response.json();
            console.log("[Risk Modal] Dados do risco para edição:", riskData);

            // Popula o formulário
            if(riskForm.querySelector('#riskDescription')) riskForm.querySelector('#riskDescription').value = riskData.description || '';
            if(riskForm.querySelector('#riskImpact')) riskForm.querySelector('#riskImpact').value = riskData.impact || 'Médio';
            if(riskForm.querySelector('#riskProbability')) riskForm.querySelector('#riskProbability').value = riskData.probability || 'Média';
            if(riskForm.querySelector('#riskStatus')) riskForm.querySelector('#riskStatus').value = riskData.status || 'Ativo';
            if(riskForm.querySelector('#riskResponsible')) riskForm.querySelector('#riskResponsible').value = riskData.responsible || '';
            if(riskForm.querySelector('#riskMitigationPlan')) riskForm.querySelector('#riskMitigationPlan').value = riskData.mitigation_plan || '';
            if(riskForm.querySelector('#riskContingencyPlan')) riskForm.querySelector('#riskContingencyPlan').value = riskData.contingency_plan || '';
            if(riskForm.querySelector('#riskTrend')) riskForm.querySelector('#riskTrend').value = riskData.trend || 'Estável';
            
            riskModalLabel.textContent = 'Editar Risco'; // Restaura o título

        } catch (error) {
            console.error("[Risk Modal] Erro ao buscar dados do risco para edição:", error);
            alert(error.message); // Mostra erro
            riskModal.hide(); // Fecha o modal se não conseguir carregar
        } finally {
            // Reabilita os campos do formulário após carregar (ou falhar)
            for (let i = 0; i < formFields.length; i++) {
                formFields[i].disabled = false;
            }
            // Se o título ainda estiver como loading, restaura para Editar Risco
            if (riskModalLabel.textContent.includes('Carregando')) {
                 riskModalLabel.textContent = 'Editar Risco';
            }
        }
    } else { // Modo Criação
        riskModalLabel.textContent = 'Adicionar Novo Risco';
        currentEditingRiskId = null;
        // TODO: Garantir que o botão de excluir esteja escondido
    }
    riskModal.show();
  }
  
  if (riskForm) {
    riskForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("[Risk Form Submit ENTRY] currentEditingRiskId at start:", currentEditingRiskId); // NOVO LOG AQUI

        const currentBacklogId = document.getElementById('currentBacklogId')?.value;
        if (!currentBacklogId) {
            alert("Erro: ID do Backlog não encontrado. Não é possível adicionar o risco.");
            return;
        }
        // const hiddenRiskId = this.querySelector('input[name="riskId"]')?.value; // Para edição futura
        // const isEditing = !!hiddenRiskId;

        const isEditing = !!currentEditingRiskId; // Usa a variável global para verificar se está editando

        const riskData = {
            backlog_id: parseInt(currentBacklogId, 10),
            description: this.querySelector('#riskDescription')?.value,
            impact: this.querySelector('#riskImpact')?.value || 'Médio', 
            probability: this.querySelector('#riskProbability')?.value || 'Média',
            status: this.querySelector('#riskStatus')?.value || 'Ativo', // ID do select no modal de risco
            responsible: this.querySelector('#riskResponsible')?.value || null, 
            mitigation_plan: this.querySelector('#riskMitigationPlan')?.value || null,
            contingency_plan: this.querySelector('#riskContingencyPlan')?.value || null,
            trend: this.querySelector('#riskTrend')?.value || 'Estável'
        };

        // Remover backlog_id do payload se estiver editando, pois a API PUT não o espera no corpo.
        if (isEditing) {
            delete riskData.backlog_id;
        }

        console.log("[Risk Form Submit] currentEditingRiskId:", currentEditingRiskId);
        console.log("[Risk Form Submit] isEditing Flag:", isEditing);
        console.log("[Risk Form Submit] Dados do risco a enviar (payload):", JSON.parse(JSON.stringify(riskData))); // Log profundo da cópia

        const url = isEditing ? `/backlog/api/risks/${currentEditingRiskId}` : '/backlog/api/risks';
        const method = isEditing ? 'PUT' : 'POST';
        
        console.log(`[Risk Form Submit] URL: ${url}, METHOD: ${method}`);

        // Adiciona feedback de loading no modal
        const submitButton = riskForm.querySelector('button[type="submit"]');
        const originalButtonText = submitButton ? submitButton.innerHTML : 'Salvar Risco';
        if(submitButton) {
            submitButton.disabled = true;
            submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Salvando...';
        }

        try {
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(riskData)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`;
                try {
                    const errorDetail = await response.json();
                    errorMsg = errorDetail.message || errorDetail.description || errorMsg;
                } catch (e) { /* Ignora se não conseguir parsear JSON do erro */ }
                throw new Error(errorMsg);
            }

            const savedRisk = await response.json();
            console.log("[Risk Form Submit] Risco salvo:", savedRisk);
            riskModal.hide();
            loadRisks(); // Recarrega a lista de riscos
            alert(isEditing ? 'Risco atualizado com sucesso!' : 'Risco adicionado com sucesso!'); // Placeholder para toast

        } catch (error) {
            console.error(`[Risk Form Submit] Erro ao ${isEditing ? 'atualizar' : 'salvar'} risco:`, error);
            alert(`Erro ao ${isEditing ? 'atualizar' : 'salvar'} risco: ${error.message}`); // Placeholder para erro no modal/toast
        } finally {
            if(submitButton) { // Restaura o botão
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonText;
            }
        }
    });
  }
  
  // Função para confirmar e excluir risco (a ser implementada)
  // function confirmDeleteRisk(riskId, riskDescription) { ... }

  // --- FIM DA LÓGICA PARA RISCOS DO PROJETO ---

  // **************************
  // *** LINHA DO TEMPO DO PROJETO ***
  // **************************

  document.addEventListener('DOMContentLoaded', function() {
      console.log("Board DOM loaded");
      
      // Atribuição dos elementos de Risco aqui
      risksTableBody = document.getElementById('risksTableBody');
      addRiskBtn = document.getElementById('addRiskBtn');
      riskModalElement = document.getElementById('riskModal');
      if (riskModalElement) { // Verifica se o modal existe antes de tentar usá-lo
          riskModal = new bootstrap.Modal(riskModalElement);
          riskForm = riskModalElement.querySelector('form#riskForm'); // Busca pelo ID do form
          riskModalLabel = riskModalElement.querySelector('.modal-title#riskModalLabel');

          if (addRiskBtn) {
              addRiskBtn.addEventListener('click', () => openRiskModal()); 
          }

          if (riskForm) {
            riskForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                console.log("[Risk Form Submit ENTRY] currentEditingRiskId at start:", currentEditingRiskId); // NOVO LOG AQUI

                const currentBacklogId = document.getElementById('currentBacklogId')?.value;
                if (!currentBacklogId) {
                    alert("Erro: ID do Backlog não encontrado. Não é possível adicionar o risco.");
                    return;
                }
                // const hiddenRiskId = this.querySelector('input[name="riskId"]')?.value; // Para edição futura
                // const isEditing = !!hiddenRiskId;

                const isEditing = !!currentEditingRiskId; // Usa a variável global para verificar se está editando

                const riskData = {
                    backlog_id: parseInt(currentBacklogId, 10),
                    description: this.querySelector('#riskDescription')?.value,
                    impact: this.querySelector('#riskImpact')?.value || 'Médio', 
                    probability: this.querySelector('#riskProbability')?.value || 'Média',
                    status: this.querySelector('#riskStatus')?.value || 'Ativo', // ID do select no modal de risco
                    responsible: this.querySelector('#riskResponsible')?.value || null, 
                    mitigation_plan: this.querySelector('#riskMitigationPlan')?.value || null,
                    contingency_plan: this.querySelector('#riskContingencyPlan')?.value || null,
                    trend: this.querySelector('#riskTrend')?.value || 'Estável'
                };

                // Remover backlog_id do payload se estiver editando, pois a API PUT não o espera no corpo.
                if (isEditing) {
                    delete riskData.backlog_id;
                }

                console.log("[Risk Form Submit] currentEditingRiskId:", currentEditingRiskId);
                console.log("[Risk Form Submit] isEditing Flag:", isEditing);
                console.log("[Risk Form Submit] Dados do risco a enviar (payload):", JSON.parse(JSON.stringify(riskData))); // Log profundo da cópia

                const url = isEditing ? `/backlog/api/risks/${currentEditingRiskId}` : '/backlog/api/risks';
                const method = isEditing ? 'PUT' : 'POST';
                
                console.log(`[Risk Form Submit] URL: ${url}, METHOD: ${method}`);

                // Adiciona feedback de loading no modal
                const submitButton = riskForm.querySelector('button[type="submit"]');
                const originalButtonText = submitButton ? submitButton.innerHTML : 'Salvar Risco';
                if(submitButton) {
                    submitButton.disabled = true;
                    submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Salvando...';
                }

                try {
                    const response = await fetch(url, {
                        method: method,
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(riskData)
                    });

                    if (!response.ok) {
                        let errorMsg = `Erro ${response.status}`;
                        try {
                            const errorDetail = await response.json();
                            errorMsg = errorDetail.message || errorDetail.description || errorMsg;
                        } catch (e) { /* Ignora se não conseguir parsear JSON do erro */ }
                        throw new Error(errorMsg);
                    }

                    const savedRisk = await response.json();
                    console.log("[Risk Form Submit] Risco salvo:", savedRisk);
                    if (riskModal) riskModal.hide(); // Verifica se riskModal está definido
                    loadRisks(); 
                    alert('Risco adicionado com sucesso!');

                } catch (error) {
                    console.error(`[Risk Form Submit] Erro ao salvar risco:`, error);
                    alert(`Erro ao salvar risco: ${error.message}`);
                } finally {
                    if(submitButton) {
                        submitButton.disabled = false;
                        submitButton.innerHTML = originalButtonText;
                    }
                }
            });
          } else {
              console.warn("[Riscos] Formulário #riskForm não encontrado no modal de risco.");
          }
      } else {
          console.warn("[Riscos] Modal #riskModal não encontrado no DOM.");
      }
      
      loadMilestones();
      loadRisks(); 
      
      setTimeout(updateTimelineTasks, 1500);
  });

  // Função para confirmar e excluir um RISCO
  function confirmDeleteRisk(riskId, riskDescription) {
      if (!riskId) {
          console.error("[Confirm Delete Risk] ID do risco não fornecido.");
          showToast("Erro: ID do risco não informado para exclusão.", "error");
          return;
      }
      const userConfirmed = confirm(`Tem certeza que deseja excluir o risco "${riskDescription || riskId}"? Esta ação não pode ser desfeita.`);
      if (userConfirmed) {
          console.log(`[Confirm Delete Risk] Usuário confirmou exclusão do Risco ID: ${riskId}`);
          deleteRisk(riskId);
      } else {
          console.log(`[Confirm Delete Risk] Usuário cancelou exclusão do Risco ID: ${riskId}`);
      }
  }

  // Função para excluir um RISCO via API
  async function deleteRisk(riskId) {
      if (!riskId) {
          console.error("[Delete Risk API] ID do risco não fornecido para a API.");
          showToast("Erro interno: ID do risco ausente para exclusão via API.", "error");
          return;
      }
      console.log(`[Delete Risk API] Enviando requisição DELETE para Risco ID: ${riskId}`);
      // Adicionar feedback de loading (ex: no modal se aplicável, ou um overlay geral)
      // showLoadingFeedback(true); // Exemplo, adaptar para o contexto de riscos

      try {
          const response = await fetch(`/backlog/api/risks/${riskId}`, {
              method: 'DELETE',
              headers: {'Content-Type': 'application/json'}
          });

          if (!response.ok) {
              let errorMsg = `Erro HTTP ${response.status} ao excluir risco.`;
              try {
                  const errorData = await response.json();
                  errorMsg = errorData.message || errorData.error || errorMsg;
              } catch (e) { /* Ignora erro no parse do JSON de erro */ }
              throw new Error(errorMsg);
          }

          console.log(`[Delete Risk API] Risco ID: ${riskId} excluído com sucesso da API.`);
          showToast("Risco excluído com sucesso!", "success");

          // Atualizar a UI: Remover a linha da tabela e recarregar a lista de riscos
          // Ou apenas remover a linha específica:
          const riskRow = risksTableBody.querySelector(`tr[data-risk-id="${riskId}"]`);
          if (riskRow) {
              riskRow.remove();
              console.log(`[Delete Risk API] Linha do Risco ID: ${riskId} removida da tabela.`);
              // Verificar se a tabela ficou vazia
              if (risksTableBody.querySelectorAll('tr').length === 0) {
                  risksTableBody.innerHTML = `<tr><td colspan="4" class="text-center text-muted small"><i class="bi bi-info-circle me-1"></i>Nenhum risco cadastrado para este backlog.</td></tr>`;
              }
          } else {
              console.warn(`[Delete Risk API] Não foi possível encontrar a linha do Risco ID: ${riskId} para remover. Recarregando toda a lista.`);
              loadRisks(); // Fallback para recarregar tudo se a linha não for encontrada
          }
          
          // Se o modal de edição de risco estiver aberto e for o risco excluído, feche-o.
          if (riskModal && currentEditingRiskId == riskId) {
             riskModal.hide();
             currentEditingRiskId = null;
          }

      } catch (error) {
          console.error('[Delete Risk API] Erro ao excluir risco:', error);
          showToast(`Erro ao excluir risco: ${error.message}`, "error");
      } finally {
          // Esconder feedback de loading
          // showLoadingFeedback(false); // Exemplo
      }
  }

  // --- INÍCIO: Lógica para Modal de Segmentos de Tarefa ---
  let manageSegmentsModalInstance = null;
  let currentEditingSegmentTaskId = null;
  
  let segmentTaskNameEl = null; 
  let segmentManageTaskIdInput = null;
  let addSegmentForm = null;
  let currentSegmentsListEl = null;
  let noSegmentsMessageEl = null;
  let saveTaskSegmentsBtn = null;

  let isEditingSegment = false;
  let currentEditingSegmentId = null;

  function escapeHtml(unsafe) {
      if (unsafe === null || typeof unsafe === 'undefined') {
        return '';
      }
      return unsafe
          .toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
  }

  function formatDisplayDateTime(dateStr, timeStr) {
      if (!dateStr || !timeStr) return 'Data/Hora inválida';
      try {
          const dateObj = new Date(`${dateStr}T${timeStr}:00`);
          if (isNaN(dateObj)) return `${dateStr} ${timeStr} (Inválida)`;
          
          const day = String(dateObj.getDate()).padStart(2, '0');
          const month = String(dateObj.getMonth() + 1).padStart(2, '0');
          const year = dateObj.getFullYear();
          const hours = String(dateObj.getHours()).padStart(2, '0');
          const minutes = String(dateObj.getMinutes()).padStart(2, '0');
          return `${day}/${month}/${year} ${hours}:${minutes}`;
      } catch (e) {
          console.error("Erro formatando data/hora: ", dateStr, timeStr, e);
          return `${dateStr} ${timeStr}`;
      }
  }

  function updateNoSegmentsMessageVisibility() {
      if (currentSegmentsListEl && noSegmentsMessageEl) {
          const hasSegments = currentSegmentsListEl.querySelector('.list-group-item');
          console.log('[DEBUG UpdateNoSegments] hasSegments:', hasSegments ? 'true' : 'false');
          
          if (hasSegments) {
              if (noSegmentsMessageEl.style.display !== 'none') {
                  console.log('[DEBUG UpdateNoSegments] Has segments, hiding noSegmentsMessageEl.');
                  noSegmentsMessageEl.style.display = 'none';
              }
              if (currentSegmentsListEl.contains(noSegmentsMessageEl)) {
                  console.log('[DEBUG UpdateNoSegments] Has segments, removing noSegmentsMessageEl from DOM.');
                  currentSegmentsListEl.removeChild(noSegmentsMessageEl);
              }
          } else {
              if (noSegmentsMessageEl.style.display !== 'block') {
                  console.log('[DEBUG UpdateNoSegments] No segments, showing noSegmentsMessageEl.');
                  noSegmentsMessageEl.style.display = 'block';
              }
              if (!currentSegmentsListEl.contains(noSegmentsMessageEl)) {
                 console.log('[DEBUG UpdateNoSegments] No segments, appending noSegmentsMessageEl to DOM.');
                 currentSegmentsListEl.appendChild(noSegmentsMessageEl);
              }
          }
      } else {
          console.log('[DEBUG UpdateNoSegments] currentSegmentsListEl or noSegmentsMessageEl is null.');
      }
  }

  async function openManageSegmentsModal(taskId, taskName) {
      console.log(`[DEBUG] openManageSegmentsModal CALLED for taskId: ${taskId}, taskName: ${taskName}`);
      currentEditingSegmentTaskId = taskId;
      if (segmentTaskNameEl) segmentTaskNameEl.textContent = escapeHtml(taskName);
      if (segmentManageTaskIdInput) segmentManageTaskIdInput.value = taskId;

      console.log(`Abrindo modal de segmentos para Tarefa ID: ${taskId}, Nome: ${taskName}`);

      if (addSegmentForm) {
        addSegmentForm.reset();
        const descriptionTextarea = document.getElementById('segmentDescription');
        if(descriptionTextarea) descriptionTextarea.value = '';
        
        const submitButton = addSegmentForm.querySelector('button[type="submit"]');
        if (submitButton) {
            submitButton.innerHTML = 'Adicionar';
            submitButton.classList.remove('btn-info');
            submitButton.classList.add('btn-success');
        }
        isEditingSegment = false;
        currentEditingSegmentId = null;
      }
      if (currentSegmentsListEl) currentSegmentsListEl.innerHTML = '<div class="text-center p-3"><span class="spinner-border spinner-border-sm"></span> Carregando segmentos...</div>'; 
      
      try {
          console.log(`[DEBUG] Fetching segments from: /backlog/api/tasks/${taskId}/segments`);
          const response = await fetch(`/backlog/api/tasks/${taskId}/segments`);
          console.log(`[DEBUG] Fetch response status: ${response.status}`);
          
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: `Erro HTTP ${response.status}` }));
              console.error(`[DEBUG] Fetch error data:`, errorData);
              throw new Error(errorData.message || `Erro ao buscar segmentos: ${response.status}`);
          }
          const fetchedSegments = await response.json();
          console.log(`[DEBUG] Fetched segments:`, fetchedSegments);
          
          if (currentSegmentsListEl) currentSegmentsListEl.innerHTML = '';

          if (fetchedSegments && fetchedSegments.length > 0) {
             fetchedSegments.forEach(segment => {
                  const [startDate, startTime] = segment.segment_start_datetime ? segment.segment_start_datetime.split('T') : [null, null];
                  const [dueDate, dueTime] = segment.segment_end_datetime ? segment.segment_end_datetime.split('T') : [null, null];
                  
                  const displaySegmentData = {
                      id: segment.id,
                      start_date: startDate,
                      start_time: startTime ? startTime.substring(0,5) : null,
                      due_date: dueDate,
                      due_time: dueTime ? dueTime.substring(0,5) : null,
                      description: segment.description,
                      is_new: false 
                  };
                  renderSegmentItem(displaySegmentData);
             });
          } 
          updateNoSegmentsMessageVisibility();

      } catch (error) {
          console.error("[DEBUG] Erro CATCH ao carregar segmentos:", error);
          if (currentSegmentsListEl) currentSegmentsListEl.innerHTML = `<div class="list-group-item text-danger">Erro ao carregar segmentos: ${error.message}</div>`;
          if (noSegmentsMessageEl) noSegmentsMessageEl.style.display = 'none'; 
      }

      if (manageSegmentsModalInstance) {
          manageSegmentsModalInstance.show();
      }
  }

  function handleAddSegmentFormSubmit(event) {
      event.preventDefault();
      const startDate = document.getElementById('segmentStartDate').value;
      const startTime = document.getElementById('segmentStartTime').value;
      const dueDate = document.getElementById('segmentDueDate').value;
      const dueTime = document.getElementById('segmentDueTime').value;
      const description = document.getElementById('segmentDescription').value;

      if (!startDate || !startTime || !dueDate || !dueTime) {
          showToast('Por favor, preencha todas as datas e horas do segmento.', 'error', 5000);
          return;
      }
      
      const startDateTime = new Date(`${startDate}T${startTime}`);
      const dueDateTime = new Date(`${dueDate}T${dueTime}`);
      if (dueDateTime <= startDateTime) {
          showToast('A data/hora de fim deve ser posterior à data/hora de início.', 'error', 6000);
          return;
      }

      const segmentData = {
          id: isEditingSegment && currentEditingSegmentId ? currentEditingSegmentId : `temp_${Date.now()}`, 
          start_date: startDate,
          start_time: startTime,
          due_date: dueDate,
          due_time: dueTime,
          description: description,
          is_new: !isEditingSegment 
      };

      if (isEditingSegment) {
          const segmentItemToUpdate = currentSegmentsListEl.querySelector(`.list-group-item[data-segment-id="${currentEditingSegmentId}"]`);
          if (segmentItemToUpdate) {
              segmentItemToUpdate.dataset.segmentData = JSON.stringify(segmentData);
              const displayStart = formatDisplayDateTime(segmentData.start_date, segmentData.start_time);
              const displayDue = formatDisplayDateTime(segmentData.due_date, segmentData.due_time);
              segmentItemToUpdate.querySelector('.segment-info h6').textContent = `Segmento: ${displayStart} - ${displayDue}`;
              const descEl = segmentItemToUpdate.querySelector('.segment-info p.small');
              if (segmentData.description) {
                  if (descEl) descEl.textContent = escapeHtml(segmentData.description);
                  else {
                      const p = document.createElement('p');
                      p.className = 'mb-0 small text-muted';
                      p.textContent = escapeHtml(segmentData.description);
                      segmentItemToUpdate.querySelector('.segment-info').appendChild(p);
                  }
              } else {
                  if (descEl) descEl.remove();
              }
          }
          isEditingSegment = false; 
          currentEditingSegmentId = null;
          const submitButton = addSegmentForm.querySelector('button[type="submit"]');
          if(submitButton) {
            submitButton.innerHTML = 'Adicionar';
            submitButton.classList.remove('btn-info');
            submitButton.classList.add('btn-success');
          }
      } else {
          renderSegmentItem(segmentData);
      }

      addSegmentForm.reset(); 
      const descriptionTextarea = document.getElementById('segmentDescription');
      if(descriptionTextarea) descriptionTextarea.value = '';
      updateNoSegmentsMessageVisibility();
  }

  function renderSegmentItem(segment) {
      console.log('[DEBUG RenderSegmentItem] Called with segment:', segment);
      if (!currentSegmentsListEl) {
          console.error('[DEBUG RenderSegmentItem] currentSegmentsListEl is null');
          return;
      }

      if (noSegmentsMessageEl && noSegmentsMessageEl.parentNode === currentSegmentsListEl) {
          console.log('[DEBUG RenderSegmentItem] Removing noSegmentsMessageEl from currentSegmentsListEl');
          currentSegmentsListEl.removeChild(noSegmentsMessageEl);
      } else if (noSegmentsMessageEl) {
           if (noSegmentsMessageEl.style.display !== 'none') {
               console.log('[DEBUG RenderSegmentItem] Setting noSegmentsMessageEl.style.display to "none"');
               noSegmentsMessageEl.style.display = 'none';
           }
      }

      const item = document.createElement('div');
      item.className = 'list-group-item list-group-item-action';
      item.dataset.segmentData = JSON.stringify(segment); 
      item.dataset.segmentId = segment.id; 

      const displayStart = formatDisplayDateTime(segment.start_date, segment.start_time);
      const displayDue = formatDisplayDateTime(segment.due_date, segment.due_time);

      item.innerHTML = `
          <div class="d-flex w-100 justify-content-between align-items-center">
              <div class="segment-info">
                  <h6 class="mb-1">Segmento: ${displayStart} - ${displayDue}</h6>
                  ${segment.description ? `<p class="mb-0 small text-muted">${escapeHtml(segment.description)}</p>` : ''}
              </div>
              <div class="segment-actions flex-shrink-0 ms-2">
                  <button type="button" class="btn btn-sm btn-outline-primary me-1 edit-segment-btn" title="Editar Segmento" data-segment-id="${segment.id}">
                      <i class="fas fa-edit"></i>
                  </button>
                  <button type="button" class="btn btn-sm btn-outline-danger remove-segment-btn" title="Remover Segmento" data-segment-id="${segment.id}">
                      <i class="fas fa-trash"></i>
                  </button>
              </div>
          </div>
      `;
      currentSegmentsListEl.appendChild(item);
      console.log('[DEBUG RenderSegmentItem] Appended item:', item, 'Current list children count:', currentSegmentsListEl.children.length);
  }
  
  function populateSegmentFormForEdit(segmentData) {
    console.log('[DEBUG populateSegmentForm] Called with data:', JSON.parse(JSON.stringify(segmentData)));
    if (!addSegmentForm) {
        console.error('[DEBUG populateSegmentForm] addSegmentForm is null. Cannot populate.');
        return;
    }
    console.log('[DEBUG populateSegmentForm] addSegmentForm found:', addSegmentForm);

    try {
        const startDateInput = document.getElementById('segmentStartDate');
        const startTimeInput = document.getElementById('segmentStartTime');
        const dueDateInput = document.getElementById('segmentDueDate');
        const dueTimeInput = document.getElementById('segmentDueTime');
        const descriptionInput = document.getElementById('segmentDescription');

        console.log('[DEBUG populateSegmentForm] Form elements found:', {
            startDateInput, startTimeInput, dueDateInput, dueTimeInput, descriptionInput
        });

        if(startDateInput) startDateInput.value = segmentData.start_date || '';
        if(startTimeInput) startTimeInput.value = segmentData.start_time || '';
        if(dueDateInput) dueDateInput.value = segmentData.due_date || '';
        if(dueTimeInput) dueTimeInput.value = segmentData.due_time || '';
        if(descriptionInput) descriptionInput.value = segmentData.description || '';
        
        console.log('[DEBUG populateSegmentForm] Form values set (or attempted).');

    } catch (e) {
        console.error('[DEBUG populateSegmentForm] Error during field assignment:', e);
    }

    isEditingSegment = true;
    currentEditingSegmentId = segmentData.id;
    
    const submitButton = addSegmentForm.querySelector('button[type="submit"]');
    if (submitButton) {
        submitButton.innerHTML = 'Atualizar Segmento';
        submitButton.classList.remove('btn-success');
        submitButton.classList.add('btn-info');
    }
    const startDateField = document.getElementById('segmentStartDate');
    if (startDateField) startDateField.focus();
  }

  async function handleSaveTaskSegments() {
      console.log('[DEBUG SaveSegments] handleSaveTaskSegments CALLED.');
      if (!currentEditingSegmentTaskId) {
          showToast("Erro: ID da tarefa não encontrado para salvar segmentos.", "error");
          console.error('[DEBUG SaveSegments] currentEditingSegmentTaskId is null or invalid:', currentEditingSegmentTaskId);
          return;
      }

      const segmentsToSave = [];
      const segmentItems = currentSegmentsListEl.querySelectorAll('.list-group-item');
      let dataError = false;
      segmentItems.forEach(item => {
          if (item.dataset.segmentData) {
              try {
                const segmentData = JSON.parse(item.dataset.segmentData);
                segmentsToSave.push({
                    id: segmentData.id.toString().startsWith('temp_') ? null : segmentData.id,
                    start_date: segmentData.start_date,
                    start_time: segmentData.start_time,
                    due_date: segmentData.due_date,
                    due_time: segmentData.due_time,
                    description: segmentData.description
                });
              } catch (e) {
                  console.error("Erro ao parsear segmentData para salvar: ", item.dataset.segmentData, e);
                  dataError = true;
              }
          } else {
              console.warn("Item de segmento sem dataset.segmentData", item);
              dataError = true;
          }
      });

      if (dataError) {
          showToast("Erro nos dados de um ou mais segmentos. Verifique o console.", "error");
          return;
      }

      console.log(`Salvando ${segmentsToSave.length} segmentos para Tarefa ID: ${currentEditingSegmentTaskId}`, segmentsToSave);
      
      if (!saveTaskSegmentsBtn) {
          console.error('[DEBUG SaveSegments] saveTaskSegmentsBtn is null!');
          showToast("Erro: Botão de salvar não encontrado.", "error");
          return;
      }
      const originalButtonText = saveTaskSegmentsBtn.innerHTML;
      saveTaskSegmentsBtn.disabled = true;
      saveTaskSegmentsBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Salvando...';

      try {
          const response = await fetch(`/backlog/api/tasks/${currentEditingSegmentTaskId}/segments`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ segments: segmentsToSave })
          });
          
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: `Erro HTTP ${response.status}` }));
              throw new Error(errorData.message || 'Erro ao salvar segmentos.');
          }
          
          const savedSegmentsData = await response.json(); // Alterado para savedSegmentsData para clareza
          console.log('Segmentos salvos via API:', savedSegmentsData);
          
          if (currentSegmentsListEl) currentSegmentsListEl.innerHTML = ''; // Limpa a lista atual
          if (savedSegmentsData && savedSegmentsData.segments && savedSegmentsData.segments.length > 0) { // Verifica a estrutura retornada pela API
              savedSegmentsData.segments.forEach(segment => { // Itera sobre savedSegmentsData.segments
                const [startDate, startTime] = segment.segment_start_datetime ? segment.segment_start_datetime.split('T') : [null, null];
                const [dueDate, dueTime] = segment.segment_end_datetime ? segment.segment_end_datetime.split('T') : [null, null];
                
                renderSegmentItem({
                    id: segment.id, 
                    start_date: startDate,
                    start_time: startTime ? startTime.substring(0,5) : null,
                    due_date: dueDate,
                    due_time: dueTime ? dueTime.substring(0,5) : null,
                    description: segment.description,
                    is_new: false
                });
              });
          }
          updateNoSegmentsMessageVisibility();
          
          showToast('Segmentos salvos com sucesso!', 'success');
          if (manageSegmentsModalInstance) manageSegmentsModalInstance.hide();
          
          if (typeof tuiCal !== 'undefined' && tuiCal && typeof fetchAndRenderSchedules === 'function') {
              console.log("Modal de segmentos salvo, recarregando a agenda TUI...");
              fetchAndRenderSchedules(); 
          }

      } catch (error) {
          console.error('Erro ao salvar segmentos:', error);
          showToast(`Erro ao salvar segmentos: ${error.message}`, 'error');
      } finally {
          saveTaskSegmentsBtn.disabled = false;
          saveTaskSegmentsBtn.innerHTML = originalButtonText;
      }
  }

  document.addEventListener('DOMContentLoaded', function() {
      segmentTaskNameEl = document.getElementById('segmentTaskName');
      segmentManageTaskIdInput = document.getElementById('segmentManageTaskId');
      addSegmentForm = document.getElementById('addSegmentForm');
      currentSegmentsListEl = document.getElementById('currentSegmentsList');
      noSegmentsMessageEl = document.getElementById('noSegmentsMessage');
      saveTaskSegmentsBtn = document.getElementById('saveTaskSegmentsBtn');

      console.log('[DEBUG DOMContentLoaded] Elementos do Modal de Segmentos:', {
        segmentTaskNameEl, segmentManageTaskIdInput, addSegmentForm,
        currentSegmentsListEl, noSegmentsMessageEl, saveTaskSegmentsBtn
      });

      const manageSegmentsModalEl = document.getElementById('manageTaskSegmentsModal');
      if (manageSegmentsModalEl) {
          manageSegmentsModalInstance = new bootstrap.Modal(manageSegmentsModalEl);
      } else {
          console.error('[DEBUG DOMContentLoaded] Elemento #manageTaskSegmentsModal não encontrado.');
      }

      const boardContainer = document.querySelector('.kanban-board-wrapper') || document.body; 
      boardContainer.addEventListener('click', function(event) {
          // Exemplo: se houvesse outra lógica, ela permaneceria:
          // const anotherButton = event.target.closest('.some-other-button');
          // if (anotherButton) {
          //    handleAnotherAction();
          // }
      });
      
      if (addSegmentForm) {
          addSegmentForm.addEventListener('submit', handleAddSegmentFormSubmit);
          console.log('[DEBUG DOMContentLoaded] Event listener para addSegmentForm ADICIONADO.');
      } else {
          console.error('[DEBUG DOMContentLoaded] addSegmentForm NÃO encontrado para adicionar listener.');
      }

      if (saveTaskSegmentsBtn) {
          saveTaskSegmentsBtn.addEventListener('click', handleSaveTaskSegments);
          console.log('[DEBUG DOMContentLoaded] Event listener para saveTaskSegmentsBtn ADICIONADO.');
      } else {
          console.error('[DEBUG DOMContentLoaded] saveTaskSegmentsBtn NÃO encontrado para adicionar listener.');
      }
      
      if (currentSegmentsListEl) {
        currentSegmentsListEl.addEventListener('click', function(event) {
            const editButton = event.target.closest('.edit-segment-btn');
            const removeButton = event.target.closest('.remove-segment-btn');

            if (editButton) {
                const segmentId = editButton.dataset.segmentId;
                console.log("[DEBUG EventListener] Botão Editar clicado para segmentId:", segmentId);
                const segmentItem = editButton.closest('.list-group-item');
                if (segmentItem && segmentItem.dataset.segmentData) {
                    try {
                        const realData = JSON.parse(segmentItem.dataset.segmentData);
                        console.log("[DEBUG EventListener] Dados REAIS do segmento (realData):", realData);
                        populateSegmentFormForEdit(realData);
                    } catch (e) {
                        console.error("[DEBUG EventListener] ERRO ao parsear realData ou chamar populateSegmentFormForEdit:", e);
                        showToast("Erro ao tentar editar o segmento. Verifique o console.", "error");
                    }
                } else {
                    console.error("[DEBUG EventListener] Não foi possível obter realData do dataset para editar.");
                    showToast("Não foi possível carregar os dados do segmento para edição.", "error");
                }
            } else if (removeButton) {
                const segmentItem = removeButton.closest('.list-group-item');
                if (segmentItem) {
                    const segmentDataString = segmentItem.dataset.segmentData;
                    let segmentDisplayInfo = "este segmento";
                    let segmentIdToRemove = null;
                    if (segmentDataString) {
                        try {
                            const segmentData = JSON.parse(segmentDataString);
                            segmentIdToRemove = segmentData.id;
                            segmentDisplayInfo = `segmento: ${formatDisplayDateTime(segmentData.start_date, segmentData.start_time)} - ${formatDisplayDateTime(segmentData.due_date, segmentData.due_time)}`;
                        } catch(e){ /* Usa o default */ }
                    }

                    if (confirm(`Tem certeza que deseja remover ${segmentDisplayInfo}?`)) {
                        segmentItem.remove();
                        updateNoSegmentsMessageVisibility();
                        if (isEditingSegment && currentEditingSegmentId === segmentIdToRemove ) {
                            addSegmentForm.reset();
                            const descriptionTextarea = document.getElementById('segmentDescription');
                            if(descriptionTextarea) descriptionTextarea.value = '';
                            const submitButton = addSegmentForm.querySelector('button[type="submit"]');
                            if (submitButton) {
                                submitButton.innerHTML = 'Adicionar';
                                submitButton.classList.remove('btn-info');
                                submitButton.classList.add('btn-success');
                            }
                            isEditingSegment = false;
                            currentEditingSegmentId = null;
                        }
                    }
                }
            }
        });
      } else {
          console.error('[DEBUG DOMContentLoaded] currentSegmentsListEl NÃO encontrado para adicionar listener de editar/remover.');
      }
      
      if(noSegmentsMessageEl && currentSegmentsListEl) {
          updateNoSegmentsMessageVisibility();
      }
  });
  // --- FIM: Lógica para Modal de Segmentos de Tarefa ---

  // ...MANTENHA QUALQUER CÓDIGO JAVASCRIPT EXISTENTE DEPOIS DA LÓGICA DOS SEGMENTOS...

  // Função para abreviar o identificador da coluna
  function getAbbreviatedColumnIdentifier(identifier) {
      if (!identifier) return '??';
      const lowerId = identifier.toLowerCase();
      switch (lowerId) {
          case 'afazer': return 'AF';
          case 'andamento': return 'EA';
          case 'revisao': return 'RV';
          case 'concluido': return 'CO';
          case 'bloqueado': return 'BL';
          default:
              return identifier.substring(0, 2).toUpperCase();
      }
  }

  // Sistema de Notas
  const NotesManager = {
      noteModal: null,
      currentEditingNoteId: null,
      initialized: false,

      init: function() {
          if (this.initialized) {
              console.log('[Notes] NotesManager já foi inicializado. Ignorando chamada duplicada.');
          return;
      }
          console.log('[Notes] Inicializando NotesManager pela primeira vez.');

          const modalElement = document.getElementById('noteModal');
          if (modalElement) {
              this.noteModal = new bootstrap.Modal(modalElement);
          } else {
              console.error('[Notes] Elemento #noteModal não encontrado.');
          return;
      }
      
          this.setupEventListeners();
          this.loadNotes();
          this.loadTasksForSelect();
          
          this.initialized = true;
          console.log('[Notes] NotesManager inicializado com sucesso.');
      },

      setupEventListeners: function() {
          const elements = {
              addNoteBtn: document.getElementById('addNoteBtn'),
              saveNoteBtn: document.getElementById('saveNoteBtn'),
              deleteNoteBtn: document.getElementById('deleteNoteBtn'),
              filterNotesBtn: document.getElementById('filterNotesBtn'),
              noteTypeFilter: document.getElementById('noteTypeFilter'),
              noteCategoryFilter: document.getElementById('noteCategoryFilter'),
              notePriorityFilter: document.getElementById('notePriorityFilter'),
              noteSearchBtn: document.getElementById('noteSearchBtn'),
              noteSearchInput: document.getElementById('noteSearchInput')
          };

          // Verifica se todos os elementos necessários foram encontrados
          const missingElements = Object.entries(elements)
              .filter(([key, element]) => !element)
              .map(([key]) => key);

          if (missingElements.length > 0) {
              console.error('[Notes] Elementos não encontrados:', missingElements.join(', '));
              return;
          }
          
          // Remove listeners antigos e adiciona novos
          Object.entries(elements).forEach(([key, element]) => {
              const newElement = element.cloneNode(true);
              element.parentNode.replaceChild(newElement, element);

              switch (key) {
                  case 'addNoteBtn':
                      newElement.addEventListener('click', () => this.showNoteModal());
                      break;
                  case 'saveNoteBtn':
                      newElement.addEventListener('click', () => this.saveNote());
                      break;
                  case 'deleteNoteBtn':
                      newElement.addEventListener('click', () => this.deleteNote());
                      break;
                  case 'filterNotesBtn':
                      newElement.addEventListener('click', () => this.toggleFilters());
                      break;
                  case 'noteTypeFilter':
                  case 'noteCategoryFilter':
                  case 'notePriorityFilter':
                      newElement.addEventListener('change', () => this.applyFilters());
                      break;
                  case 'noteSearchBtn':
                      newElement.addEventListener('click', () => this.applyFilters());
                      break;
                  case 'noteSearchInput':
                      newElement.addEventListener('keypress', (e) => {
                          if (e.key === 'Enter') this.applyFilters();
                      });
                      break;
              }
          });

          console.log('[Notes] Event listeners configurados com sucesso.');
      },

      updateNoteType: function(selectedTaskId) {
        const noteTypeSelect = document.getElementById('noteType');
        if (noteTypeSelect) {
            if (selectedTaskId && selectedTaskId !== '') {
                noteTypeSelect.value = 'task';
            } else {
                // Se nenhuma tarefa for selecionada, pode-se manter 'project' 
                // ou limpar, dependendo da lógica desejada.
                // Por ora, vamos manter como 'project' se nenhuma tarefa estiver selecionada.
                noteTypeSelect.value = 'project'; 
            }
        }
      },

      loadNotes: function() {
          // const projectId = document.getElementById('currentBacklogId')?.value; // LINHA ANTIGA
          const projectId = document.getElementById('currentProjectId')?.value; // CORREÇÃO: Usar o ID do PROJETO

          if (!projectId) {
              // console.warn('[Notes] ID do projeto não encontrado'); // Comentado para evitar confusão se o backlogId for usado intencionalmente em outro lugar
              console.warn('[Notes] ID do projeto (currentProjectId) não encontrado para carregar notas.');
              return;
          }

          const notesList = document.getElementById('notesList');
          if (!notesList) {
              console.error('[Notes] Elemento notesList não encontrado');
          return;
      }
      
          notesList.innerHTML = '<div class="text-center py-3"><div class="spinner-border spinner-border-sm text-primary"></div> Carregando notas...</div>';

          // Caminho correto com o prefixo /backlog/
          fetch(`/backlog/api/notes?project_id=${projectId}`)
              .then(response => {
                  if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                  return response.json();
              })
              .then(notes => {
                  console.log('[Notes] Notas carregadas:', notes);
                  this.renderNotes(notes);
              })
              .catch(error => {
                  console.error('[Notes] Erro ao carregar notas:', error);
                  notesList.innerHTML = '<div class="alert alert-danger">Erro ao carregar notas. Tente novamente.</div>';
              });
      },

      loadTasksForSelect: function() {
          const select = document.getElementById('noteTaskId');
          if (!select) {
              console.error('[Notes] Elemento select noteTaskId não encontrado');
              return;
          }

          select.innerHTML = '<option value="">Selecione uma tarefa...</option>';

          if (currentTasksData && currentTasksData.length > 0) {
              currentTasksData.forEach(task => {
                  select.innerHTML += `<option value="${task.id}">${escapeHtml(task.title)}</option>`;
              });
          }
      },

      saveNote: function() {
          // const projectId = document.getElementById('currentBacklogId')?.value; // LINHA ANTIGA
          const projectId = document.getElementById('currentProjectId')?.value; // CORREÇÃO: Usar o ID do PROJETO
          
          if (!projectId) {
              this.showError('ID do projeto não encontrado no #currentProjectId');
          return;
          }

          const data = {
              content: document.getElementById('noteContent').value.trim(),
              category: document.getElementById('noteCategory').value,
              priority: document.getElementById('notePriority').value,
              project_id: projectId, // O project_id correto (ex: '10237')
              task_id: document.getElementById('noteTaskId').value || null,
              note_type: document.getElementById('noteType').value,
              event_date: document.getElementById('noteEventDate').value || null, // <<< ADICIONADO
              tags: document.getElementById('noteTags').value
                  .split(',')
                  .map(tag => tag.trim())
                  .filter(tag => tag)
          };

          if (!data.content) {
              this.showError('O conteúdo da nota é obrigatório');
          return;
      }
      
          // URL completa incluindo o prefixo /backlog/
          // Caminho completo da API incluindo o prefixo /backlog/
          const url = this.currentEditingNoteId               ? `/backlog/api/notes/${this.currentEditingNoteId}`              : '/backlog/api/notes';
          
          const method = this.currentEditingNoteId ? 'PUT' : 'POST';

          const saveButton = document.getElementById('saveNoteBtn');
          const originalButtonText = saveButton.innerHTML;
          saveButton.disabled = true;
          saveButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Salvando...';

          fetch(url, {
              method: method,
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(data)
          })
              .then(response => {
              if (!response.ok) throw new Error(`Erro ${response.status} ao salvar nota`);
                  return response.json();
              })
          .then(result => {
              console.log('[Notes] Nota salva com sucesso:', result);
              this.noteModal.hide();
              this.loadNotes();
              this.showSuccess('Nota salva com sucesso');
              })
              .catch(error => {
              console.error('[Notes] Erro ao salvar nota:', error);
              this.showError(`Erro ao salvar nota: ${error.message}`);
          })
          .finally(() => {
              saveButton.disabled = false;
              saveButton.innerHTML = originalButtonText;
              this.currentEditingNoteId = null;
          });
      },

      deleteNote: function() {
          if (!this.currentEditingNoteId) return;

          if (!confirm('Tem certeza que deseja excluir esta nota?')) return;

          const deleteButton = document.getElementById('deleteNoteBtn');
          const originalButtonText = deleteButton.innerHTML;
          deleteButton.disabled = true;
          deleteButton.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Excluindo...';

          // Caminho correto com o prefixo /backlog/
          fetch(`/backlog/api/notes/${this.currentEditingNoteId}`, {
              method: 'DELETE'
          })
              .then(response => {
              if (!response.ok) throw new Error('Erro ao excluir nota');
              this.noteModal.hide();
              this.loadNotes();
              this.showSuccess('Nota excluída com sucesso');
          })
          .catch(error => {
              console.error('[Notes] Erro ao excluir nota:', error);
              this.showError('Erro ao excluir nota');
          })
          .finally(() => {
              deleteButton.disabled = false;
              deleteButton.innerHTML = originalButtonText;
          });
      },

      showNoteModal: function(noteId = null) {
          this.currentEditingNoteId = noteId;
          const form = document.getElementById('noteForm');
          form.reset();
          document.getElementById('noteEventDate').value = ''; // <<< ADICIONADO: Limpar campo event_date

          const deleteBtn = document.getElementById('deleteNoteBtn');
          deleteBtn.style.display = noteId ? 'block' : 'none';

          if (noteId) {
              const modalTitle = document.querySelector('#noteModal .modal-title');
              if (modalTitle) modalTitle.textContent = 'Editar Nota';

              // Caminho correto com o prefixo /backlog/
              fetch(`/backlog/api/notes/${noteId}`)
                  .then(response => response.json())
                  .then(note => {
                      document.getElementById('noteContent').value = note.content;
                      document.getElementById('noteCategory').value = note.category;
                      document.getElementById('notePriority').value = note.priority;
                      document.getElementById('noteTaskId').value = note.task_id || '';
                      document.getElementById('noteEventDate').value = note.event_date || ''; // <<< ADICIONADO
                      document.getElementById('noteTags').value = note.tags.join(', ');
              })
              .catch(error => {
                      console.error('[Notes] Erro ao carregar nota:', error);
                      this.showError('Erro ao carregar nota');
                  });
      } else {
              const modalTitle = document.querySelector('#noteModal .modal-title');
              if (modalTitle) modalTitle.textContent = 'Nova Nota';
          }

          this.noteModal.show();
      },

      renderNotes: function(notes) {
          const notesList = document.getElementById('notesList');
          if (!notesList) return;

          if (!notes || notes.length === 0) {
              notesList.innerHTML = '<div class="text-center text-muted py-3">Nenhuma nota encontrada</div>';
          return;
          }

          const sortedNotes = [...notes].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

          notesList.innerHTML = '';
          sortedNotes.forEach(note => {
              const noteElement = document.createElement('div');
              noteElement.className = `note-card priority-${note.priority}`;
              noteElement.dataset.noteId = note.id;

              let eventDateHtml = '';
              if (note.event_date) {
                eventDateHtml = `<div class="text-muted small" style="font-style: italic;" title="Data do Evento"><i class="bi bi-calendar-event me-1"></i>Evento: ${this.formatDate(note.event_date, true)}</div>`;
              }

              noteElement.innerHTML = `
                  <div class="note-header">
                      <div>
                          ${note.task_id ? `<span class="badge bg-info me-2">Tarefa: ${this.getTaskTitle(note.task_id)}</span>` : ''}
                          <span class="badge bg-${this.getCategoryBadgeColor(note.category)}">${this.getCategoryText(note.category)}</span>
                          <span class="badge bg-${this.getPriorityBadgeColor(note.priority)}">${this.getPriorityText(note.priority)}</span>
                      </div>
                      <div class="text-muted small" title="Data de Criação/Modificação"><i class="bi bi-clock-history me-1"></i>${this.formatDate(note.updated_at || note.created_at)}</div>
                  </div>
                  ${eventDateHtml} 
                  <div class="note-content">${escapeHtml(note.content)}</div>
                  <div class="note-footer">
                      <div class="note-tags">
                          ${note.tags.map(tag => `<span class="badge bg-secondary">${escapeHtml(tag)}</span>`).join('')}
                      </div>
                      <div class="note-actions">
                          <button class="btn btn-sm btn-outline-primary btn-xs edit-note-btn" title="Editar Nota">
                              <i class="bi bi-pencil"></i>
                          </button>
                      </div>
                  </div>
              `;

              const editButton = noteElement.querySelector('.edit-note-btn');
              if (editButton) {
                  editButton.addEventListener('click', () => this.showNoteModal(note.id));
              }

              notesList.appendChild(noteElement);
          });
      },

      toggleFilters: function() {
          const filtersDiv = document.getElementById('notesFilters');
          if (filtersDiv) {
              filtersDiv.style.display = filtersDiv.style.display === 'none' ? 'flex' : 'none';
          }
      },

      applyFilters: function() {
          const type = document.getElementById('noteTypeFilter').value;
          const category = document.getElementById('noteCategoryFilter').value;
          const priority = document.getElementById('notePriorityFilter').value;
          const search = document.getElementById('noteSearchInput').value.toLowerCase();

          const notes = document.querySelectorAll('.note-card');
          notes.forEach(note => {
              let show = true;

              if (type && !note.querySelector(`.badge:contains('${type}')`)) show = false;
              if (category && !note.querySelector(`.badge:contains('${category}')`)) show = false;
              if (priority && !note.querySelector(`.badge:contains('${priority}')`)) show = false;
              if (search && !note.textContent.toLowerCase().includes(search)) show = false;

              note.style.display = show ? 'block' : 'none';
          });
      },

      getTaskTitle: function(taskId) {
          const task = currentTasksData.find(t => t.id === taskId);
          return task ? escapeHtml(task.title) : 'Tarefa não encontrada';
      },

      getCategoryBadgeColor: function(category) {
          const colors = {
              'decision': 'primary',
              'risk': 'danger',
              'impediment': 'warning',
              'status_update': 'info',
              'general': 'secondary'
          };
          return colors[category] || 'secondary';
      },

      getPriorityBadgeColor: function(priority) {
          const colors = {
              'high': 'danger',
              'medium': 'warning',
              'low': 'success'
          };
          return colors[priority] || 'secondary';
      },

      getCategoryText: function(category) {
          const texts = {
              'decision': 'Decisão',
              'risk': 'Risco',
              'impediment': 'Impedimento',
              'status_update': 'Atualização',
              'general': 'Geral'
          };
          return texts[category] || category;
      },

      getPriorityText: function(priority) {
          const texts = {
              'high': 'Alta',
              'medium': 'Média',
              'low': 'Baixa'
          };
          return texts[priority] || priority;
      },

      formatDate: function(dateString, isEventDate = false) {
          if (!dateString) return '';

          // Para event_date (que é apenas data, sem hora)
          if (isEventDate) {
              // Se já vier no formato dd/MM/yyyy (ex: do backend, após uma primeira formatação), retorna direto
              if (/^\d{2}\/\d{2}\/\d{4}$/.test(dateString)) {
                  return dateString;
              }
              // Se vier como YYYY-MM-DD (do input date ou do banco)
              const parts = dateString.split('-');
              if (parts.length === 3) {
                  const year = parseInt(parts[0], 10);
                  const month = parseInt(parts[1], 10); // 1-12
                  const day = parseInt(parts[2], 10);
                  if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                    return `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}/${year}`;
                  }
              }
              // Se for um objeto Date (ex: vindo de um input type="date" que já foi convertido para Date pelo navegador antes de chegar aqui)
              if (dateString instanceof Date && !isNaN(dateString)) {
                 // O objeto Date já está no fuso local do navegador, mas representa meia-noite UTC da data selecionada.
                 // Para evitar problemas de off-by-one ao formatar, pegamos os componentes UTC.
                 const day = String(dateString.getUTCDate()).padStart(2, '0');
                 const month = String(dateString.getUTCMonth() + 1).padStart(2, '0'); // getUTCMonth is 0-indexed
                 const year = dateString.getUTCFullYear();
                 return `${day}/${month}/${year}`;
              }
              console.warn('[Notes.formatDate] Formato de event_date não reconhecido:', dateString, typeof dateString);
              return dateString; // Fallback se não conseguir parsear
          }

          // Para datas com hora (created_at, updated_at)
          // new Date() interpreta strings ISO 8601 (com Z ou offset) como UTC e converte para o fuso local do navegador.
          const date = new Date(dateString);
          if (isNaN(date.getTime())) {
            console.warn('[Notes.formatDate] Data/hora inválida recebida:', dateString);
            return dateString; // Retorna a string original se a data for inválida
          }

          return date.toLocaleString('pt-BR', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              // second: '2-digit', // Descomente para incluir segundos
              timeZone: 'America/Sao_Paulo' // Força a exibição neste fuso
          });
      },

      showError: function(message) {
          alert(`Erro: ${message}`);
      },

      showSuccess: function(message) {
          alert(message);
      }
  };

  // Inicialização única do NotesManager
  document.addEventListener('DOMContentLoaded', function() {
      console.log('[Notes] Iniciando carregamento inicial do NotesManager');
      NotesManager.init();
  });

  // Função para controlar a visibilidade do container de detalhes
  function toggleProjectDetails() {
      const container = document.getElementById('projectDetailsContainer');
      const button = document.getElementById('toggleDetailsBtn');
      const kanbanBoard = document.querySelector('.kanban-board');
      const isVisible = container.style.display !== 'none';
      
      container.style.display = isVisible ? 'none' : 'block';
      
      // Ajusta a altura do quadro Kanban
      if (kanbanBoard) {
          kanbanBoard.style.height = isVisible ? 'calc(100vh - 200px)' : 'calc(100vh - 300px)';
      }
      
      // Atualiza o ícone e texto do botão
      const icon = button.querySelector('i');
      if (isVisible) {
          icon.classList.remove('bi-info-circle-fill');
          icon.classList.add('bi-info-circle');
          button.classList.remove('btn-primary');
          button.classList.add('btn-outline-secondary');
      } else {
          icon.classList.remove('bi-info-circle');
          icon.classList.add('bi-info-circle-fill');
          button.classList.remove('btn-outline-secondary');
          button.classList.add('btn-primary');
      }
      
      // Salva a preferência do usuário
      localStorage.setItem('projectDetailsVisible', !isVisible);
  }

  // Ao carregar a página, verifica a preferência salva
  document.addEventListener('DOMContentLoaded', function() {
      const shouldShow = localStorage.getItem('projectDetailsVisible') === 'true';
      if (shouldShow) {
          toggleProjectDetails();
      }
      
      // Adiciona o listener ao botão
      const toggleBtn = document.getElementById('toggleDetailsBtn');
      if (toggleBtn) {
          toggleBtn.addEventListener('click', toggleProjectDetails);
      }
  });

  // Função para verificar se os IDs necessários estão disponíveis
  function checkRequiredIds() {
      const backlogId = document.getElementById('currentBacklogId')?.value;
      const projectId = document.getElementById('currentProjectId')?.value;
      
      if (!projectId) {
          console.error('[Check IDs] ID do projeto não encontrado');
          return false;
      }
      
      if (!backlogId) {
          console.warn('[Check IDs] ID do backlog não encontrado');
          return false;
      }
      
      return true;
  }

  // Modificar a inicialização
  document.addEventListener('DOMContentLoaded', async function() {
      console.log('[Init] Iniciando carregamento da página...');
      
      const idsOk = checkRequiredIds();
      console.log(`[Init] IDs verificados. Resultado: ${idsOk ? 'OK' : 'Faltando IDs'}`);
      
      if (!idsOk) {
          // Se não tiver backlog, mostra botão para criar
          if (!document.getElementById('currentBacklogId')?.value) {
              const placeholder = document.getElementById('createBacklogPlaceholder');
              if (placeholder && typeof addCreateBacklogListener === 'function') {
                  console.log('[Init] Criando botão de criar backlog');
                  const createBtn = document.createElement('button');
                  createBtn.id = 'createBacklogBtn';
                  createBtn.className = 'btn btn-sm btn-outline-secondary';
                  createBtn.innerHTML = '<i class="bi bi-plus-lg me-1"></i>Criar Backlog';
                  placeholder.appendChild(createBtn);
                  addCreateBacklogListener(createBtn);
              }
          }
          
          // Mostra mensagens apropriadas em cada seção
          const sections = {
              'milestonesTableBody': 'Selecione um projeto para ver os marcos.',
              'risksTableBody': 'Selecione um projeto para ver os riscos.',
              'completedTasksList': 'Selecione um projeto para ver as tarefas concluídas.',
              'upcomingTasksList': 'Selecione um projeto para ver as próximas tarefas.',
              'startedTasksList': 'Selecione um projeto para ver as tarefas iniciadas.'
          };
          
          Object.entries(sections).forEach(([elementId, message]) => {
              const element = document.getElementById(elementId);
              if (element) {
                  showNoDataMessage(element, message);
              }
          });
      } else {
          console.log('[Init] Carregando dados do projeto...');
          try {
              // Carrega os dados em paralelo
              await Promise.all([
                  loadMilestones(),
                  loadRisks(),
                  updateTimelineTasks()
              ]);
              
              // Inicializa o NotesManager se disponível
              if (typeof NotesManager !== 'undefined') {
                  NotesManager.init();
              }
              
              console.log('[Init] Carregamento inicial concluído com sucesso');
        } catch (error) {
              console.error('[Init] Erro durante o carregamento inicial:', error);
          }
      }
  });

  // ... rest of the code ...

  // Funções de utilidade para mensagens
  function showLoadingMessage(element, message = 'Carregando...') {
      if (!element) return;
      if (element.tagName === 'TBODY') {
          element.innerHTML = `
              <tr><td colspan="6" class="text-center text-muted py-3">
                  <div class="spinner-border spinner-border-sm text-primary me-2"></div>${message}
              </td></tr>
          `;
      } else {
          element.innerHTML = `
              <div class="text-center text-muted py-3">
                  <div class="spinner-border spinner-border-sm text-primary me-2"></div>${message}
                    </div>
          `;
      }
  }

  function showNoDataMessage(element, message) {
      if (!element) return;
      if (element.tagName === 'TBODY') {
          element.innerHTML = `
              <tr><td colspan="6" class="text-center text-muted py-3">
                  <i class="bi bi-info-circle me-2"></i>${message}
              </td></tr>
          `;
        } else {
          element.innerHTML = `
              <div class="text-center text-muted py-3">
                  <i class="bi bi-info-circle me-2"></i>${message}
              </div>
          `;
      }
  }

  function showErrorMessage(element, error) {
      if (!element) return;
      if (element.tagName === 'TBODY') {
          element.innerHTML = `
              <tr><td colspan="6" class="text-center text-danger py-3">
                  <i class="bi bi-exclamation-triangle-fill me-2"></i>${error}
              </td></tr>
          `;
      } else {
          element.innerHTML = `
              <div class="text-center text-danger py-3">
                  <i class="bi bi-exclamation-triangle-fill me-2"></i>${error}
              </div>
          `;
      }
  }

  // ... rest of the code ...
</script>

<!-- Modal Gerenciar Segmentos de Tarefa -->
<div class="modal fade" id="manageTaskSegmentsModal" tabindex="-1" aria-labelledby="manageTaskSegmentsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="manageTaskSegmentsModalLabel">Gerenciar Segmentos para: <span id="segmentTaskName"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="segmentManageTaskId">

                <!-- Formulário para Adicionar Novo Segmento -->
                <h6>Adicionar Novo Segmento</h6>
                <form id="addSegmentForm" class="row g-3 mb-4 align-items-end">
                    <div class="col-md-3">
                        <label for="segmentStartDate" class="form-label">Data Início</label>
                        <input type="date" class="form-control form-control-sm" id="segmentStartDate" required>
                    </div>
                    <div class="col-md-2">
                        <label for="segmentStartTime" class="form-label">Hora Início</label>
                        <input type="time" class="form-control form-control-sm" id="segmentStartTime" required>
                    </div>
                    <div class="col-md-3">
                        <label for="segmentDueDate" class="form-label">Data Fim</label>
                        <input type="date" class="form-control form-control-sm" id="segmentDueDate" required>
                    </div>
                    <div class="col-md-2">
                        <label for="segmentDueTime" class="form-label">Hora Fim</label>
                        <input type="time" class="form-control form-control-sm" id="segmentDueTime" required>
                    </div>
                    <div class="col-md-2">
                        <button type="submit" class="btn btn-success btn-sm w-100">Adicionar</button>
                    </div>
                    <div class="col-12">
                        <label for="segmentDescription" class="form-label">Descrição do Segmento (Opcional)</label>
                        <textarea class="form-control form-control-sm" id="segmentDescription" rows="2"></textarea>
                    </div>
                </form>

                <!-- Lista de Segmentos Existentes -->
                <h6>Segmentos Atuais</h6>
                <div id="currentSegmentsList" class="list-group">
                    <!-- Segmentos serão populados aqui por JavaScript -->
                    <!-- Exemplo de item (a ser gerado dinamicamente):
                    <div class="list-group-item list-group-item-action">
                        <div class="d-flex w-100 justify-content-between">
                            <h6 class="mb-1">Segmento: 20/07/2024 09:00 - 20/07/2024 11:00</h6>
                            <small>
                                <button class="btn btn-sm btn-outline-primary me-1 edit-segment-btn" data-segment-id="temp_id_123">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-danger remove-segment-btn" data-segment-id="temp_id_123">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </small>
                        </div>
                        <p class="mb-1">Descrição do segmento aqui...</p>
                    </div>
                    -->
                    <p class="text-muted" id="noSegmentsMessage">Nenhum segmento definido para esta tarefa.</p>
                </div>

            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="saveTaskSegmentsBtn">Salvar Alterações nos Segmentos</button>
            </div>
        </div>
    </div>
</div>

:

<!-- Modal de Nota -->
<div class="modal fade" id="noteModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Nova Nota</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="noteForm">
                    <input type="hidden" id="noteId">
                    <input type="hidden" id="noteType" value="project">
                    
                    <!-- Conteúdo -->
                    <div class="mb-3">
                        <label class="form-label">Conteúdo <span class="text-danger">*</span></label>
                        <textarea class="form-control" id="noteContent" rows="4" required></textarea>
                    </div>
                    
                    <div class="row mb-3">
                        <!-- Categoria -->
                        <div class="col-md-4">
                            <label class="form-label">Categoria</label>
                            <select class="form-select" id="noteCategory">
                                <option value="general">Geral</option>
                                <option value="decision">Decisão</option>
                                <option value="risk">Risco</option>
                                <option value="impediment">Impedimento</option>
                                <option value="status_update">Atualização de Status</option>
                            </select>
                        </div>
                        
                        <!-- Prioridade -->
                        <div class="col-md-4">
                            <label class="form-label">Prioridade</label>
                            <select class="form-select" id="notePriority">
                                <option value="medium">Média</option>
                                <option value="high">Alta</option>
                                <option value="low">Baixa</option>
                            </select>
                        </div>
                        
                        <!-- Tarefa (opcional) -->
                        <div class="col-md-4">
                            <label class="form-label">Vincular à Tarefa (Opcional)</label>
                            <select class="form-select" id="noteTaskId" onchange="NotesManager.updateNoteType(this.value)">
                                <option value="">Selecione uma tarefa...</option>
                            </select>
                        </div>

                        {# NOVO CAMPO: Data do Evento #}
                        <div class="col-md-4">
                            <label for="noteEventDate" class="form-label">Data do Evento</label>
                            <input type="date" class="form-control" id="noteEventDate">
                        </div>
                    </div>
                    
                    <!-- Tags -->
                    <div class="mb-3">
                        <label class="form-label">Tags</label>
                        <input type="text" class="form-control" id="noteTags" placeholder="Separe as tags por vírgula">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-danger me-2" id="deleteNoteBtn" style="display: none;">
                    <i class="bi bi-trash me-1"></i>Excluir
                </button>
                <button type="button" class="btn btn-primary" id="saveNoteBtn">
                    <i class="bi bi-save me-1"></i>Salvar
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Estilos para Notas -->
<style>
.notes-list {
    max-height: 500px;
    overflow-y: auto;
}

.note-card {
    background-color: #fff;
    border: 1px solid #e3e6f0;
    border-radius: 0.25rem;
    margin-bottom: 0.5rem; /* Reduzido de 1rem para 0.5rem */
    padding: 0.5rem; /* Reduzido de 1rem para 0.5rem */
    transition: all 0.2s ease;
}

.note-card:hover {
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transform: translateY(-1px);
}

.note-card.priority-high {
    border-left: 3px solid var(--bs-danger);
}

.note-card.priority-medium {
    border-left: 3px solid var(--bs-warning);
}

.note-card.priority-low {
    border-left: 3px solid var(--bs-success);
}

.note-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 0.3rem; /* Reduzido de 0.5rem para 0.3rem */
    font-size: 0.85rem; /* Texto um pouco menor */
}

.note-content {
    white-space: pre-line;
    margin-bottom: 0.3rem; /* Reduzido de 0.5rem para 0.3rem */
    font-size: 0.9rem; /* Texto um pouco menor */
}

.note-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem; /* Reduzido de 0.875rem para 0.8rem */
}

.note-tags .badge {
    font-size: 0.7rem; /* Reduzido de 0.75rem para 0.7rem */
    margin-right: 0.2rem; /* Reduzido de 0.25rem para 0.2rem */
}

.note-actions {
    opacity: 0.5;
    transition: opacity 0.2s ease;
}

.note-card:hover .note-actions {
    opacity: 1;
}

/* Ajuste nos badges */
.note-card .badge {
    padding: 0.2em 0.5em;
    font-size: 0.7rem;
}
</style>

<script>
// Sistema de Notas
// const NotesManager = {
//     // ... outros métodos ...

//     getPriorityText: function(priority) {
//         const texts = {
//             'high': 'Alta',
//             'medium': 'Média',
//             'low': 'Baixa'
//         };
//         return texts[priority] || priority;
//     },

//     getCategoryText: function(category) {
//         const texts = {
//             'decision': 'Decisão',
//             'risk': 'Risco',
//             'impediment': 'Impedimento',
//             'status_update': 'Atualização',
//             'general': 'Geral'
//         };
//         return texts[category] || category;
//     },

//     renderNotes: function(notes) {
//         const notesList = document.getElementById('notesList');
//         if (!notes || notes.length === 0) {
//             notesList.innerHTML = '<div class="text-center text-muted py-3">Nenhuma nota encontrada</div>';
//             return;
//         }

//         notesList.innerHTML = notes.map(note => `
//             <div class="note-card priority-${note.priority}" data-note-id="${note.id}">
//                 <div class="note-header">
//                     <div>
//                         ${note.task_id ? `<span class="badge bg-info me-2">Tarefa: ${this.getTaskTitle(note.task_id)}</span>` : ''}
//                         <span class="badge bg-${this.getCategoryBadgeColor(note.category)}">${this.getCategoryText(note.category)}</span>
//                         <span class="badge bg-${this.getPriorityBadgeColor(note.priority)}">${this.getPriorityText(note.priority)}</span>
//                     </div>
//                     <div class="text-muted small">${this.formatDate(note.created_at)}</div>
//                 </div>
//                 <div class="note-content">${note.content}</div>
//                 <div class="note-footer">
//                     <div class="note-tags">
//                         ${note.tags.map(tag => `
//                             <span class="badge bg-secondary">${tag}</span>
//                         `).join('')}
//                     </div>
//                     <div class="note-actions">
//                         <button class="btn btn-sm btn-outline-primary btn-xs" onclick="NotesManager.editNote(${note.id})" title="Editar Nota">
//                             <i class="bi bi-pencil"></i>
//                         </button>
//                     </div>
//                 </div>
//             </div>
//         `).join('');
//     },

//     // ... outros métodos ...
// };

// ... resto do código ...
</script>

{% endblock %}

