{% extends 'base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<style>
  /* Variáveis de Cores e Estilos */
  :root {
    --sprint-primary: #0d6efd;
    --sprint-secondary: #6c757d;
    --sprint-success: #198754;
    --sprint-info: #0dcaf0;
    --sprint-warning: #ffc107;
    --sprint-danger: #dc3545;
    --sprint-light: #f8f9fa;
    --sprint-dark: #212529;
    --sprint-border: #dee2e6;
    --sprint-hover: #e9ecef;
    --sprint-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --sprint-shadow-lg: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    
    /* Cores de Criticidade */
    --criticality-normal-bg: #f8f9fa;
    --criticality-normal-border: #dee2e6;
    --criticality-alta-bg: #fff3cd;
    --criticality-alta-border: #ffc107;
    --criticality-critica-bg: #f8d7da;
    --criticality-critica-border: #dc3545;
  }

  /* Layout Geral */
  .sprint-board-container {
    display: flex;
    align-items: flex-start;
    gap: 1.5rem;
    height: calc(100vh - 180px);
    min-height: 400px;
    background-color: #ffffff;
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--sprint-border);
    box-shadow: var(--sprint-shadow);
    overflow: hidden; /* Previne scroll não intencional */
  }

  /* NOVO: Toolbar de Controles */
  .sprint-controls-toolbar {
    background-color: var(--sprint-light);
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    padding: 1rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
  }

  .sprint-view-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .sprint-bulk-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .view-toggle-btn {
    padding: 0.5rem 1rem;
    border: 1px solid var(--sprint-border);
    background-color: #ffffff;
    color: var(--sprint-secondary);
    border-radius: 0.375rem;
    transition: all 0.2s ease;
    cursor: pointer;
  }

  .view-toggle-btn.active {
    background-color: var(--sprint-primary);
    color: #ffffff;
    border-color: var(--sprint-primary);
  }

  .view-toggle-btn:hover:not(.active) {
    background-color: var(--sprint-hover);
  }

  /* NOVO: Estilos para Sprints Arquivadas */
  .sprint-card.archived {
    opacity: 0.7;
    background-color: #f8f9fa;
    border-style: dashed;
  }

  .sprint-card.archived .sprint-card-header {
    background-color: #e9ecef !important;
  }

  .sprint-card.archived .archived-badge {
    background-color: var(--sprint-secondary);
    color: #ffffff;
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    display: inline-flex;
    align-items: center;
  }

  /* Checkbox para Seleção Múltipla */
  .sprint-checkbox {
    position: absolute;
    top: 0.5rem;
    left: 0.5rem;
    z-index: 10;
    transform: scale(1.2);
  }

  .sprint-card.selectable {
    position: relative;
    padding-left: 2rem;
  }

  .sprint-card.selected {
    border-color: var(--sprint-primary);
    box-shadow: 0 0 0 2px rgba(13, 110, 253, 0.25);
  }

  /* Sprint Board */
  .sprint-board {
    flex-grow: 1;
    display: flex;
    gap: 1.5rem;
    overflow-x: auto;
    padding: 0.5rem;
    align-items: flex-start;
    height: 100%;
    padding-bottom: 1rem; /* Espaço para evitar corte */
  }

  /* Sprint Cards */
  .sprint-card {
    flex: 0 0 400px !important;
    width: 400px !important;
    min-width: 400px !important;
    max-width: 400px !important;
    height: 680px !important; /* Reduzido ~10% de 760px */
    min-height: 680px !important;
    max-height: 680px !important;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    transition: all 0.2s ease;
    margin-bottom: 0.5rem;
  }

  /* Cabeçalho da Sprint */
  .sprint-card-header {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    border-radius: 0.5rem 0.5rem 0 0;
    min-height: 120px; /* Altura mínima fixa para o cabeçalho */
  }

  /* Cores de Criticidade */
  .sprint-card-header.criticality-normal {
    background-color: var(--criticality-normal-bg);
    border-bottom: 2px solid var(--criticality-normal-border);
  }

  .sprint-card-header.criticality-alta {
    background-color: var(--criticality-alta-bg);
    border-bottom: 2px solid var(--criticality-alta-border);
  }

  .sprint-card-header.criticality-critica {
    background-color: var(--criticality-critica-bg);
    border-bottom: 2px solid var(--criticality-critica-border);
  }

  /* Linha Superior do Cabeçalho */
  .sprint-header-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    gap: 1rem;
  }

  /* Área do Título e Informações */
  .sprint-title-area {
    flex: 1;
    min-width: 0; /* Importante para text-overflow funcionar */
  }

  .sprint-card-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--sprint-dark);
    margin: 0 0 0.5rem 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Badges e Metadados */
  .sprint-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .sprint-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: normal;
    border-radius: 0.25rem;
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--sprint-secondary);
  }

  .sprint-badge i {
    margin-right: 0.25rem;
  }

  /* Área de Ações */
  .sprint-card-actions {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .sprint-card-actions button {
    padding: 0.25rem 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
  }

  /* Linha Inferior do Cabeçalho */
  .sprint-header-bottom {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .sprint-dates {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .sprint-goal {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0;
  }

  /* Corpo da Sprint */
  .sprint-card-body {
    padding: 1rem;
    overflow-y: auto;
    flex-grow: 1;
    background-color: #ffffff;
    height: calc(100% - 120px);
  }

  .sprint-tasks {
    min-height: 50px;
    padding: 0.5rem;
    background-color: var(--sprint-light);
    border-radius: 0.375rem;
  }

  /* Task Cards */
  .backlog-task-card {
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    cursor: grab;
    transition: all 0.2s ease;
  }

  .backlog-task-card:last-child {
    margin-bottom: 0;
  }

  .task-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
  }

  .task-priority-badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    white-space: nowrap;
  }

  .task-hours {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  .task-full-id {
    font-family: monospace;
    font-size: 0.7rem;
    padding: 0.1rem 0.3rem;
    background-color: var(--sprint-light);
    border-radius: 0.2rem;
    color: var(--sprint-secondary);
  }

  /* Responsividade */
  @media (max-width: 1600px) {
    .sprint-card {
      flex: 0 0 350px !important;
      width: 350px !important;
      min-width: 350px !important;
      max-width: 350px !important;
      height: 650px !important; /* Reduzido ~10% de 720px */
      min-height: 650px !important;
      max-height: 650px !important;
    }

    #backlogColumn {
      flex: 0 0 350px;
      min-width: 350px;
      max-width: 350px;
    }
  }

  /* Colunas Laterais (Backlog e Tarefas Genéricas) */
  .side-column {
    flex: 0 0 350px;
    min-width: 350px;
    max-width: 350px;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }

  /* Coluna de Backlog específica */
  #backlogColumn {
    flex: 0 0 400px;
    min-width: 400px;
    max-width: 400px;
  }

  .side-column-header {
    padding: 1rem;
    background-color: #ffffff;
    border-bottom: 1px solid var(--sprint-border);
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .side-column-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .side-column-title h6 {
    margin: 0;
    font-weight: 600;
  }

  .search-container {
    position: relative;
  }

  .search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    padding-left: 2rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
  }

  .search-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--sprint-secondary);
  }

  .side-column-body {
    padding: 0.75rem;
    overflow-y: auto;
    flex-grow: 1;
  }

  /* Projetos no Backlog */
  .backlog-project {
    margin-bottom: 0.5rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    overflow: hidden;
  }

  .backlog-project-header {
    padding: 0.75rem;
    background-color: var(--sprint-light);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
  }

  .project-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
  }

  .project-id {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  .project-name {
    font-size: 0.875rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .project-tasks {
    display: none;
    padding: 0.75rem;
    background-color: #ffffff;
  }

  .project-tasks.show {
    display: block;
  }

  /* Tarefas Genéricas */
  .generic-task {
    padding: 0.75rem;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    margin-bottom: 0.5rem;
    cursor: pointer;
  }

  .generic-task:hover {
    background-color: var(--sprint-hover);
  }

  .generic-task-title {
    font-size: 0.875rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  .generic-task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
  }

  /* Task Project Info - NOVO */
  .task-project-info {
    font-size: 0.7rem !important;
    color: var(--sprint-secondary) !important;
    opacity: 0.8;
    padding: 0.2rem 0;
    border-left: 2px solid var(--sprint-border);
    padding-left: 0.5rem;
    margin-left: 0.2rem;
  }

  .task-project-info i {
    opacity: 0.6;
  }

  /* Badges */
  .project-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    background-color: var(--sprint-light);
    color: var(--sprint-secondary);
    white-space: nowrap;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
  <div class="card shadow mb-4">
    <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
      {# <<< INÍCIO: Agrupamento Título + Botão Collapse >>> #}
      <div class="d-flex align-items-center">
        <button class="btn btn-sm btn-outline-secondary me-2" id="toggleBacklogBtn" title="Recolher Backlog">
            <i class="bi bi-chevron-double-left"></i>
        </button>
        <h6 class="m-0 font-weight-bold text-primary"><i class="bi bi-calendar3-week me-2"></i>{{ title }}</h6>
      </div>
      {# <<< FIM: Agrupamento Título + Botão Collapse >>> #}
      <div>
        <a href="{{ url_for('sprints.consolidated_report_page') }}" class="btn btn-sm btn-outline-primary me-2">
            <i class="bi bi-file-earmark-text me-1"></i>Relatório Consolidado
        </a>
        <button class="btn btn-sm btn-primary" id="addSprintBtn" data-bs-toggle="modal" data-bs-target="#sprintModal">
            <i class="bi bi-plus-lg me-1"></i>Nova Sprint
        </button>
      </div>
    </div>
    <div class="card-body">
      {# NOVO: Toolbar de Controles para Arquivamento #}
      <div class="sprint-controls-toolbar" id="sprintControlsToolbar">
        <div class="sprint-view-controls">
          <label class="form-label mb-0 me-2"><strong>Visualizar:</strong></label>
          <button type="button" class="view-toggle-btn active" id="viewActiveBtn" data-view="active">
            <i class="bi bi-play-circle me-1"></i>Sprints Ativas
          </button>
          <button type="button" class="view-toggle-btn" id="viewArchivedBtn" data-view="archived">
            <i class="bi bi-archive me-1"></i>Sprints Arquivadas
          </button>
          <button type="button" class="view-toggle-btn" id="viewAllBtn" data-view="all">
            <i class="bi bi-collection me-1"></i>Todas as Sprints
          </button>
        </div>
        
        <div class="sprint-bulk-actions" id="sprintBulkActions" style="display: none;">
          <button type="button" class="btn btn-sm btn-outline-secondary" id="enableSelectModeBtn">
            <i class="bi bi-check2-square me-1"></i>Selecionar Múltiplas
          </button>
          <button type="button" class="btn btn-sm btn-warning" id="archiveSelectedBtn" style="display: none;">
            <i class="bi bi-archive me-1"></i>Arquivar Selecionadas
          </button>
          <button type="button" class="btn btn-sm btn-info" id="unarchiveSelectedBtn" style="display: none;">
            <i class="bi bi-box-arrow-up me-1"></i>Desarquivar Selecionadas
          </button>
          <button type="button" class="btn btn-sm btn-secondary" id="cancelSelectModeBtn" style="display: none;">
            <i class="bi bi-x-circle me-1"></i>Cancelar
          </button>
        </div>

        <div class="sprint-search-controls">
          <div class="input-group input-group-sm" style="width: 250px;">
            <span class="input-group-text"><i class="bi bi-search"></i></span>
            <input type="text" class="form-control" id="sprintSearchInput" placeholder="Buscar sprint...">
            <button class="btn btn-outline-secondary" type="button" id="clearSprintSearchBtn">
              <i class="bi bi-x"></i>
            </button>
          </div>
        </div>
      </div>
      
      {# Área do Quadro de Sprints #}
      <div class="sprint-board-container" id="sprintBoardContainer"> {# Novo container geral #}
          {# Coluna do Backlog #}
          <div class="side-column" id="backlogColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Backlog</h6>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar projeto..." id="backlogSearch">
                  </div>
              </div>
              <div class="side-column-body" id="backlogList">
                  {# Conteúdo do backlog será carregado via JavaScript #}
              </div>
          </div>

          {# Nova Coluna de Tarefas Genéricas #}
          <div class="side-column" id="genericTasksColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Tarefas Genéricas</h6>
                      <button class="btn btn-sm btn-outline-primary" id="addGenericTaskBtn">
                          <i class="bi bi-plus"></i>
                      </button>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar tarefa..." id="genericTaskSearch">
                  </div>
              </div>
              <div class="side-column-body" id="genericTasksList">
                  {# Conteúdo das tarefas genéricas será carregado via JavaScript #}
              </div>
          </div>

          {# Área Rolável para Sprints #}
          <div id="sprintBoard" class="sprint-board">
          <div class="text-center text-muted p-5">Carregando sprints...</div>
          </div>
      </div>
    </div>
  </div>
</div>

{# Modal Adicionar/Editar Sprint #}
<div class="modal fade" id="sprintModal" tabindex="-1" aria-labelledby="sprintModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="sprintForm">
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title" id="sprintModalLabel">Nova Sprint</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="sprintId" name="sprintId">
          
          <div class="mb-3">
            <label for="sprintName" class="form-label">Nome <span class="text-danger">*</span></label>
            <input type="text" class="form-control form-control-sm" id="sprintName" name="name" required placeholder="Ex: Sprint 24.01">
          </div>
          
          <div class="row mb-3">
              <div class="col-md-6">
                  <label for="sprintStartDate" class="form-label">Data Início <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintStartDate" name="start_date" required>
              </div>
              <div class="col-md-6">
                  <label for="sprintEndDate" class="form-label">Data Fim <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintEndDate" name="end_date" required>
              </div>
          </div>

          <div class="mb-3">
            <label for="sprintGoal" class="form-label">Objetivo</label>
            <textarea class="form-control form-control-sm" id="sprintGoal" name="goal" rows="3" placeholder="Descreva o objetivo principal desta Sprint..."></textarea>
          </div>
          <div class="mb-3">
            <label for="sprintCriticality" class="form-label">Criticidade</label>
            <select class="form-select form-select-sm" id="sprintCriticality" name="criticality">
                <option value="Normal" selected>Normal</option>
                <option value="Alta">Alta</option>
                <option value="Crítica">Crítica</option>
            </select>
          </div>
          {# Campo oculto para o método HTTP (usado para PUT em edição) #}
          <input type="hidden" id="formMethod" name="_method" value="POST">
        </div>
        <div class="modal-footer">
          {# Botão Excluir aparece apenas na edição #}
          <button type="button" class="btn btn-danger me-auto" id="modalDeleteBtn" style="display: none;">Excluir Sprint</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-primary" onclick="console.log('[Inline Click] Botão Salvar clicado!')">Salvar Sprint</button>
        </div>
        {# Loading Feedback #}
        <div class="loading-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); z-index: 1056; display: flex; justify-content: center; align-items: center; border-radius: inherit;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </form>
    </div>
  </div>
</div>

{# Modal para Adicionar/Editar Tarefa Genérica #}
<div class="modal fade" id="genericTaskModal" tabindex="-1" aria-labelledby="genericTaskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="genericTaskForm">
                <div class="modal-header">
                    <h5 class="modal-title" id="genericTaskModalLabel">Nova Tarefa Genérica</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="genericTaskId" name="taskId">
                    
                    <div class="mb-3">
                        <label for="genericTaskTitle" class="form-label">Título <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="genericTaskTitle" name="title" required>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskDescription" class="form-label">Descrição</label>
                        <textarea class="form-control" id="genericTaskDescription" name="description" rows="3"></textarea>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskPriority" class="form-label">Prioridade</label>
                            <select class="form-select" id="genericTaskPriority" name="priority">
                                <option value="Baixa">Baixa</option>
                                <option value="Média" selected>Média</option>
                                <option value="Alta">Alta</option>
                                <option value="Urgente">Urgente</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskEffort" class="form-label">Esforço (horas)</label>
                            <input type="number" class="form-control" id="genericTaskEffort" name="estimated_effort" step="0.5" min="0">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskSpecialist" class="form-label">Especialista</label>
                        <input type="text" class="form-control" id="genericTaskSpecialist" name="specialist_name">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger me-auto" id="genericTaskDeleteBtn" style="display: none;">Excluir</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="submit" class="btn btn-primary">Salvar</button>
                </div>
            </form>
        </div>
    </div>
</div>

{# Modal para Visualizar/Editar Tarefa #}
<div class="modal fade" id="taskDetailsModal" tabindex="-1" aria-labelledby="taskDetailsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="taskDetailsModalLabel">Detalhes da Tarefa</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="taskDetailsForm">
          <input type="hidden" id="taskId" name="taskId">
          <input type="hidden" id="taskType" name="taskType">
          
          <div class="row mb-3">
            <div class="col-md-8">
              <label for="taskTitle" class="form-label">Título <span class="text-danger">*</span></label>
              <input type="text" class="form-control" id="taskTitle" name="title" required>
            </div>
            <div class="col-md-4">
              <label for="taskPriority" class="form-label">Prioridade</label>
              <select class="form-select" id="taskPriority" name="priority">
                <option value="Baixa">Baixa</option>
                <option value="Média" selected>Média</option>
                <option value="Alta">Alta</option>
                <option value="Urgente">Urgente</option>
              </select>
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="taskSpecialist" class="form-label">Especialista</label>
              <input type="text" class="form-control" id="taskSpecialist" name="specialist_name">
            </div>
            <div class="col-md-3">
              <label for="taskEstimatedHours" class="form-label">Horas Estimadas</label>
              <input type="number" class="form-control" id="taskEstimatedHours" name="estimated_hours" step="0.5" min="0">
            </div>
            <div class="col-md-3">
              <label for="taskStatus" class="form-label">Status</label>
              <select class="form-select" id="taskStatus" name="status">
                <option value="pendente">Pendente</option>
                <option value="em_andamento">Em Andamento</option>
                <option value="concluido">Concluído</option>
                <option value="bloqueado">Bloqueado</option>
              </select>
            </div>
          </div>

          <div class="mb-3">
            <label for="taskDescription" class="form-label">Descrição</label>
            <textarea class="form-control" id="taskDescription" name="description" rows="4"></textarea>
          </div>

          <div id="backlogSpecificFields" class="d-none">
            <div class="row mb-3">
              <div class="col-md-6">
                <label for="taskProjectId" class="form-label">ID do Projeto</label>
                <input type="text" class="form-control" id="taskProjectId" name="project_id" readonly>
              </div>
              <div class="col-md-6">
                <label for="taskColumnIdentifier" class="form-label">Coluna</label>
                <input type="text" class="form-control" id="taskColumnIdentifier" name="column_identifier" readonly>
              </div>
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger me-auto" id="taskDeleteBtn">Excluir Tarefa</button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        <button type="submit" form="taskDetailsForm" class="btn btn-primary">Salvar Alterações</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    console.log("[Sprint Mgmt] DOMContentLoaded iniciado.");
    const backlogColumnBody = document.querySelector('#backlogColumn .side-column-body'); // Corpo da coluna de backlog
    const sprintBoard = document.getElementById('sprintBoard'); // Seleciona o contêiner do quadro
    const sprintModalElement = document.getElementById('sprintModal');
    const sprintModal = new bootstrap.Modal(sprintModalElement);
    const sprintForm = document.getElementById('sprintForm');
    console.log("[Sprint Mgmt] Elemento sprintForm encontrado:", sprintForm); // Log de verificação
    const sprintModalLabel = document.getElementById('sprintModalLabel');
    let editingSprintId = null; // Para controle de edição futura
    const formMethodInput = document.getElementById('formMethod'); // Input oculto para método
    const modalDeleteBtn = document.getElementById('modalDeleteBtn'); // Botão excluir no modal
    const apiSprintsBaseUrl = '/sprints/api/sprints'; // API Sprints
    const apiBacklogTasksUrl = '/backlog/api/backlogs/unassigned-tasks'; // API Backlog Tasks

    // Verifica se os elementos necessários existem antes de tentar usá-los
    if (!sprintBoard) {
        console.error('[Sprint Mgmt] Elemento sprintBoard não encontrado');
        return;
    }

    // ========================================
    // NOVO: SISTEMA DE ARQUIVAMENTO DE SPRINTS - VARIÁVEIS GLOBAIS
    // ========================================
    let currentView = 'active'; // 'active', 'archived', 'all'
    let selectMode = false;
    let selectedSprints = new Set();

    // Variáveis de controle
    const viewActiveBtn = document.getElementById('viewActiveBtn');
    const viewArchivedBtn = document.getElementById('viewArchivedBtn');
    const viewAllBtn = document.getElementById('viewAllBtn');
    const enableSelectModeBtn = document.getElementById('enableSelectModeBtn');
    const archiveSelectedBtn = document.getElementById('archiveSelectedBtn');
    const unarchiveSelectedBtn = document.getElementById('unarchiveSelectedBtn');
    const cancelSelectModeBtn = document.getElementById('cancelSelectModeBtn');
    const sprintSearchInput = document.getElementById('sprintSearchInput');
    const clearSprintSearchBtn = document.getElementById('clearSprintSearchBtn');

    // Event Listeners para controles de view
    if (viewActiveBtn) viewActiveBtn.addEventListener('click', () => changeView('active'));
    if (viewArchivedBtn) viewArchivedBtn.addEventListener('click', () => changeView('archived'));
    if (viewAllBtn) viewAllBtn.addEventListener('click', () => changeView('all'));

    // Event Listeners para modo de seleção
    if (enableSelectModeBtn) enableSelectModeBtn.addEventListener('click', enableSelectMode);
    if (cancelSelectModeBtn) cancelSelectModeBtn.addEventListener('click', disableSelectMode);
    if (archiveSelectedBtn) archiveSelectedBtn.addEventListener('click', archiveSelectedSprints);
    if (unarchiveSelectedBtn) unarchiveSelectedBtn.addEventListener('click', unarchiveSelectedSprints);

    // Event Listeners para busca
    if (sprintSearchInput) sprintSearchInput.addEventListener('input', filterSprints);
    if (clearSprintSearchBtn) clearSprintSearchBtn.addEventListener('click', clearSearch);

    // Função para formatar data (DD/MM/YYYY)
    function formatDate(isoDateString) {
        if (!isoDateString) return '-';
        try {
            // Tenta criar a data. Adiciona 'T00:00:00' se for apenas YYYY-MM-DD
            const dateStr = isoDateString.includes('T') ? isoDateString : isoDateString + 'T00:00:00';
            const date = new Date(dateStr);
            // Verifica se a data é válida
            if (isNaN(date.getTime())) {
                console.warn("Data inválida recebida:", isoDateString);
                return 'Data Inválida';
            }
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Mês é 0-indexed
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        } catch (e) {
            console.error("Erro ao formatar data:", isoDateString, e);
            return 'Erro Data';
        }
    }

    // Função para carregar e renderizar sprints
    async function loadSprints() {
        // SUBSTITUÍDO COMPLETAMENTE: Agora usa o sistema de arquivamento
        return await loadSprintsWithView();
    }

    // Função original de renderização que será sobrescrita depois
    async function originalLoadSprintsFunction() {
        console.log("[Sprint Mgmt] loadSprints() chamado.");
        sprintBoard.innerHTML = '<div class="text-center text-muted p-5"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Carregando...</span></div> Carregando sprints...</div>';
        try {
            console.log(`[Sprint Mgmt] Tentando fetch sprints: ${apiSprintsBaseUrl}`);
            const response = await fetch(apiSprintsBaseUrl);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar sprints`);
            }
            const sprintsApiResponse = await response.json();

            sprintBoard.innerHTML = ''; // Limpa o quadro
            if (!sprintsApiResponse || sprintsApiResponse.length === 0) {
                sprintBoard.innerHTML = '<div class="text-center text-muted p-5">Nenhuma sprint encontrada. Crie uma nova!</div>';
                return;
            } else {
                sprintsApiResponse.forEach(sprint => {
                    // INÍCIO DA NOVA VERIFICAÇÃO DE ERRO
                    if (sprint.error) {
                        console.warn(`[Sprint Mgmt] Sprint ID ${sprint.id || 'N/A'} retornou com erro da API: ${sprint.error}`);
                        const errorCard = document.createElement('div');
                        // Adicionar classes para estilizar o card de erro, se desejado
                        errorCard.className = 'sprint-card'; 
                        errorCard.style.border = '2px solid red';
                        errorCard.innerHTML = `
                            <div class="sprint-card-header" style="background-color: #f8d7da; color: #721c24;">
                                <h6 class="sprint-card-title">Erro ao carregar Sprint ${sprint.id || '(ID Desconhecido)'}</h6>
                            </div>
                            <div class="sprint-card-body">
                                <p><strong>Detalhe do erro:</strong> ${escapeHtml(sprint.error)}</p>
                                <p class="text-muted small">Verifique os logs do servidor para mais informações.</p>
                            </div>
                        `;
                        sprintBoard.appendChild(errorCard);
                        return; // Pula para a próxima sprint
                    }
                    // FIM DA NOVA VERIFICAÇÃO DE ERRO

                    const sprintCard = document.createElement('div');
                    sprintCard.className = 'sprint-card';
                    sprintCard.dataset.sprintId = sprint.id;

                    // <<< INÍCIO: Calcular Total de Horas Estimadas da Sprint >>>
                    let totalSprintHours = 0;
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        totalSprintHours = sprint.tasks.reduce((sum, task) => {
                            const hours = parseFloat(task.estimated_hours);
                            return sum + (isNaN(hours) ? 0 : hours);
                        }, 0);
                    }
                    // <<< FIM: Calcular Total de Horas Estimadas da Sprint >>>

                    // <<< INÍCIO: Calcular Horas por Especialista >>>
                    let hoursBySpecialist = {};
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        hoursBySpecialist = sprint.tasks.reduce((acc, task) => {
                            const specialist = task.specialist_name || 'Não Atribuído';
                            const hours = parseFloat(task.estimated_hours);
                            if (!isNaN(hours)) {
                                acc[specialist] = (acc[specialist] || 0) + hours;
                            }
                            return acc;
                        }, {});
                    }
                    // Formata o conteúdo do popover
                    let popoverContent = Object.entries(hoursBySpecialist)
                        .map(([name, hours]) => `<div>${escapeHtml(name)}: <strong>${hours.toFixed(1)}h</strong></div>`)
                        .join('');
                    if (!popoverContent) {
                        popoverContent = '<div class="text-muted small">Especialista</div>';
                    }
                    // <<< FIM: Calcular Horas por Especialista >>>

                    sprintCard.innerHTML = `
                        <div class="sprint-card-header criticality-${(sprint.criticality || 'normal').toLowerCase()}">
                            <div class="sprint-header-top">
                                <div class="sprint-title-area">
                                    <h6 class="sprint-card-title">${escapeHtml(sprint.name)}</h6>
                                    <div class="sprint-meta">
                                        <span class="sprint-badge">
                                            <i class="bi bi-stopwatch"></i>${totalSprintHours.toFixed(1)}h
                                        </span>
                                        ${Object.keys(hoursBySpecialist).length > 0 ? `
                                        <button type="button" class="sprint-badge specialist-hours-popover" 
                                                data-bs-toggle="popover" 
                                                data-bs-placement="bottom"
                                                data-bs-trigger="hover focus"
                                                data-bs-html="true" 
                                                title="Horas por Especialista"
                                                data-bs-content="${popoverContent}">
                                            <i class="bi bi-people"></i>Especialistas
                                        </button>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="sprint-card-actions">
                                    <button class="btn btn-sm btn-outline-secondary edit-btn" data-id="${sprint.id}" title="Editar Sprint">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${sprint.id}" data-name="${escapeHtml(sprint.name)}" title="Excluir Sprint">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sprint-header-bottom">
                                <div class="sprint-dates">
                                    <i class="bi bi-calendar-range"></i>
                                    ${formatDate(sprint.start_date)} - ${formatDate(sprint.end_date)}
                                </div>
                                <div class="sprint-goal">
                                    ${escapeHtml(sprint.goal || 'Sem objetivo definido.')}
                                </div>
                            </div>
                        </div>
                        <div class="sprint-card-body">
                            <div class="sprint-tasks" data-sprint-id="${sprint.id}">
                                ${sprint.tasks && sprint.tasks.length > 0 ? 
                                    sprint.tasks.map(task => {
                                        const projectPart = task.project_id || 'PROJ';
                                        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase(); 
                                        const isCompleted = task.column_identifier === 'concluido';
                                        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;
                                        return `
                                        <div class="backlog-task-card sprint-task-card ${isCompleted ? 'task-completed' : ''}" data-task-id="${task.id}" draggable="true" data-estimated-hours="${task.estimated_hours || 0}" data-specialist-name="${escapeHtml(task.specialist_name || '')}" data-is-generic="${task.is_generic || false}">
                                            <div class="task-title">${escapeHtml(task.name)}</div>
                                            ${task.project_id && !task.is_generic ? `<div class="task-project-info small text-muted mb-2">
                                                <i class="bi bi-folder2 me-1"></i>${task.project_id}${task.project_name ? ` - ${escapeHtml(task.project_name.length > 20 ? task.project_name.substring(0, 20) + '...' : task.project_name)}` : ''}
                                            </div>` : ''}
                                            <div class="task-meta">
                                                <div class="task-meta-left">
                                                    <span class="badge rounded-pill task-priority-badge">${escapeHtml(task.priority || 'Média')}</span>
                                                </div>
                                                <div class="task-meta-right text-muted task-hours">
                                                    ${task.estimated_hours ? `<i class="bi bi-clock"></i> ${task.estimated_hours}h` : ''}
                                                </div>
                                            </div>
                                            ${task.specialist_name ? `<div class="task-specialist"><i class="bi bi-person-fill"></i> ${escapeHtml(task.specialist_name)}</div>` : ''}
                                            <div class="task-actions">
                                                {# REMOVIDO BOTÃO DEVOLVER DAQUI #}
                                            </div>
                                        </div>`;
                                    }).join('') 
                                    : '<small class="text-muted fst-italic ps-2">Nenhuma tarefa alocada.</small>' 
                                } 
                            </div>
                        </div>
                    `;
                    sprintBoard.appendChild(sprintCard);

                    // Aplica classe de cor ao badge de prioridade APÓS adicionar ao DOM
                    sprint.tasks.forEach(task => {
                        const cardElement = sprintBoard.querySelector(`.sprint-task-card[data-task-id="${task.id}"]`);
                        if (cardElement) {
                            const badgeElement = cardElement.querySelector('.task-priority-badge');
                            if (badgeElement) {
                                const priorityLower = (task.priority || '').toLowerCase();
                                let badgeClass = 'text-bg-primary'; // Default: Média
                                if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                                else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                                else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                                badgeElement.classList.add(...badgeClass.split(' '));
                            }
                        }
                    });
                });
                initializeSortable(); // Inicializa Sortable DEPOIS de renderizar sprints
                initializePopovers(); // <<< INICIALIZA Popovers DEPOIS de renderizar sprints >>>
            }
        } catch (error) {
            console.error("Erro ao carregar sprints:", error);
            sprintBoard.innerHTML = `<div class="alert alert-danger">Erro ao carregar sprints: ${error.message}</div>`;
        }
    }

    // Função para renderizar uma tarefa do backlog
    function renderBacklogTask(task) {
        const projectPart = task.project_id || 'PROJ';
        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase();
        const isCompleted = task.column_identifier === 'concluido';
        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;

        return `
            <div class="backlog-task-card ${isCompleted ? 'task-completed' : ''}" 
                 data-task-id="${task.id}" 
                 draggable="true" 
                 data-estimated-hours="${task.estimated_hours || 0}" 
                 data-specialist-name="${escapeHtml(task.specialist_name || '')}">
                <div class="task-title">${escapeHtml(task.name)}</div>
                <div class="task-meta">
                    <div class="task-meta-left">
                        <span class="badge rounded-pill task-priority-badge ${getPriorityClass(task.priority)}">${escapeHtml(task.priority || 'Média')}</span>
                    </div>
                    <div class="task-meta-right text-muted task-hours">
                        <span title="Estimado"><i class="bi bi-clock-history me-1"></i>${task.estimated_hours != null ? task.estimated_hours.toFixed(1) : '-'}h</span>
                        <code class="task-full-id">${fullTaskId}</code>
                    </div>
                </div>
            </div>
        `;
    }

    // Função auxiliar para obter a classe CSS baseada na prioridade
    function getPriorityClass(priority) {
        const priorityLower = (priority || '').toLowerCase();
        switch (priorityLower) {
            case 'urgente': return 'text-bg-danger';
            case 'alta': return 'text-bg-warning';
            case 'baixa': return 'text-bg-secondary';
            default: return 'text-bg-primary'; // Média ou outro
        }
    }

    // Função para renderizar um projeto do backlog
    function renderBacklogProject(backlog) {
        const projectBoardUrl = `/backlog/board/${backlog.project_id}`; // URL de destino para o quadro do projeto
        
        // NOVO: Limita o nome do projeto para evitar quebras de linha
        let displayName = backlog.project_name || 'Sem Nome';
        
        // Estratégia inteligente de truncamento:
        // 1. Sempre mantém o número do projeto se estiver no início
        // 2. Limita por palavras (primeiras 2-3 palavras após o número)
        // 3. Backup: limita por caracteres se ainda for muito longo
        
        const palavras = displayName.split(' ');
        
        // Se começar com número (ID do projeto), mantém ele + próximas 2 palavras
        if (palavras.length > 1 && /^\d+$/.test(palavras[0])) {
            // Exemplo: "11362 PLANALTO SOLUÇÕES IMOBILIÁRIAS" -> "11362 PLANALTO SOLUÇÕES"
            if (palavras.length > 3) {
                displayName = palavras.slice(0, 3).join(' ');
            }
        } else {
            // Se não começar com número, limita a 2-3 palavras
            if (palavras.length > 2) {
                displayName = palavras.slice(0, 2).join(' ');
            }
        }
        
        // Backup: Se ainda for muito longo, corta por caracteres
        if (displayName.length > 30) {
            displayName = displayName.substring(0, 27) + '...';
        }

        return `
            <div class="backlog-project" data-project-id="${backlog.project_id}">
                <div class="backlog-project-header">
                    <div class="project-info">
                        <a href="${projectBoardUrl}" class="project-link-to-board" title="Abrir quadro do projeto ${escapeHtml(backlog.project_name || 'Projeto sem nome')}" style="text-decoration: none; color: inherit;">
                            <span class="project-id">${backlog.project_id}</span>
                            <span class="project-name">${escapeHtml(displayName)}</span>
                        </a>
                    </div>
                    <i class="bi bi-chevron-down" onclick="toggleProjectTasks(this.closest('.backlog-project-header'))" style="cursor: pointer;"></i>
                </div>
                <div class="project-tasks">
                    ${backlog.tasks && backlog.tasks.length > 0 
                        ? backlog.tasks.map(task => renderBacklogTask(task)).join('')
                        : '<div class="text-muted small p-2">Nenhuma tarefa disponível.</div>'
                    }
                </div>
            </div>
        `;
    }

    // Função para carregar e renderizar tarefas do backlog não alocadas
    async function loadBacklogTasks() {
        const backlogList = document.getElementById('backlogList');
        backlogList.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm"></div> Carregando...</div>';

        try {
            const response = await fetch('/backlog/api/backlogs/unassigned-tasks');
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            const backlogs = await response.json();
            
            if (!backlogs || backlogs.length === 0) {
                backlogList.innerHTML = '<div class="text-center text-muted p-3">Nenhum projeto encontrado.</div>';
                return;
            }

            backlogList.innerHTML = backlogs.map(backlog => renderBacklogProject(backlog)).join('');

            // Inicializa Sortable para as novas tarefas
            initializeSortable();

        } catch (error) {
            console.error("Erro ao carregar backlogs:", error);
            backlogList.innerHTML = `<div class="alert alert-danger m-3">Erro ao carregar: ${error.message}</div>`;
        }
    }

    // Função para busca nos backlogs
    function setupSearch(inputId, itemsContainer, itemSelector) {
        const searchInput = document.getElementById(inputId);
        if (!searchInput) return;

        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const items = itemsContainer.querySelectorAll(itemSelector);

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        });
    }

    // Inicializa as buscas
    setupSearch('backlogSearch', document.getElementById('backlogList'), '.backlog-project');
    setupSearch('genericTaskSearch', document.getElementById('genericTasksList'), '.generic-task');

    // Função para alternar visibilidade das tarefas do projeto
    window.toggleProjectTasks = function(header) {
        const tasksDiv = header.nextElementSibling;
        const chevron = header.querySelector('.bi');
        
        if (tasksDiv.classList.contains('show')) {
            tasksDiv.classList.remove('show');
            chevron.classList.replace('bi-chevron-up', 'bi-chevron-down');
        } else {
            tasksDiv.classList.add('show');
            chevron.classList.replace('bi-chevron-down', 'bi-chevron-up');
        }
    };

    // --- Funções de Drag and Drop (SortableJS) ---
    let sortableInstances = []; // Guarda instâncias para possível destruição/recriação

    // <<< INÍCIO: Armazena instâncias de Popover para atualização >>>
    let popoverInstances = {}; // Guarda instâncias por ID do botão (ex: popover-sprint-123)
    // <<< FIM: Armazena instâncias de Popover >>>

    function initializeSortable() {
        // Destroi instâncias antigas se existirem (útil se recarregar dinamicamente)
        sortableInstances.forEach(instance => instance.destroy());
        sortableInstances = [];

        console.log("[Sprint Mgmt] Inicializando SortableJS...");

        // Seleciona TODAS as listas de tarefas (backlog, sprints e tarefas genéricas)
        const taskLists = document.querySelectorAll('.project-tasks, #genericTasksList, .sprint-tasks');
        
        taskLists.forEach(list => {
            const instance = new Sortable(list, {
                group: 'shared-tasks', // Nome do grupo para permitir mover entre listas
                animation: 150,
                ghostClass: 'sortable-ghost-task', // Classe CSS para o fantasma
                chosenClass: 'sortable-chosen-task', // Classe CSS para o item escolhido
                draggable: '.backlog-task-card, .generic-task', // Itens arrastáveis
                
                onEnd: function (evt) {
                    const item = evt.item; // O elemento da tarefa movida
                    const taskId = item.dataset.taskId;
                    const fromList = evt.from; // Lista de origem
                    const toList = evt.to;     // Lista de destino
                    const newIndex = evt.newIndex; // Nova posição na lista de destino

                    // Atualiza horas estimadas na UI
                    const taskHours = parseFloat(item.dataset.estimatedHours) || 0;
                    const taskSpecialist = item.dataset.specialistName || 'Não Atribuído';

                    // Função auxiliar para atualizar o display de horas de uma sprint
                    function updateSprintHoursDisplay(sprintListElement, hoursDelta) {
                        const sprintCard = sprintListElement.closest('.sprint-card');
                        if (!sprintCard) return;
                        const hoursSpan = sprintCard.querySelector('.sprint-total-hours');
                        if (!hoursSpan) return;

                        try {
                            const currentHoursText = hoursSpan.textContent.match(/([\d\.]+)/);
                            let currentHours = currentHoursText ? parseFloat(currentHoursText[1]) : 0;
                            if (isNaN(currentHours)) currentHours = 0;
                            
                            const newTotalHours = currentHours + hoursDelta;
                            
                            hoursSpan.innerHTML = `<i class="bi bi-stopwatch me-1"></i>${newTotalHours.toFixed(1)}h`;
                        } catch (e) {
                            console.error("Erro ao atualizar display de horas da sprint:", e);
                        }
                    }

                    // Atualiza horas da sprint de ORIGEM (se for uma sprint)
                    if (fromList.classList.contains('sprint-tasks')) {
                        updateSprintHoursDisplay(fromList, -taskHours);
                        updateSpecialistPopover(fromList);
                    }

                    // Atualiza horas da sprint de DESTINO (se for uma sprint)
                    if (toList.classList.contains('sprint-tasks')) {
                        updateSprintHoursDisplay(toList, taskHours);
                        updateSpecialistPopover(toList);
                    }

                    // Identifica o destino (para a API)
                    let targetSprintId = null;
                    if (toList.classList.contains('sprint-tasks')) {
                        targetSprintId = toList.dataset.sprintId;
                    }

                    // Se a tarefa foi movida para uma sprint, atualiza o sprint_id
                    if (targetSprintId) {
                        updateTaskSprintAssignment(taskId, targetSprintId, newIndex);
                    } else {
                        // Se a tarefa foi movida para fora de uma sprint (para Backlog ou Tarefas Genéricas na UI)
                        // chamar a API de "move-to-backlog".
                        console.log(`[Sortable onEnd] Tarefa ${taskId} movida para fora da sprint (destino não é uma sprint). Chamando API /move-to-backlog.`);
                        fetch(`/sprints/api/sprints/tasks/${taskId}/move-to-backlog`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                // Adicionar CSRF token se necessário
                                // {% raw %}'X-CSRFToken': '{{ csrf_token() }}'{% endraw %} 
                            }
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.message || `Erro ${response.status}`); });
                            }
                            return response.json();
                        })
                        .then(updatedTask => {
                            console.log(`[Sortable onEnd] Tarefa ${taskId} movida para backlog via API. Dados:`, updatedTask);
                            // O elemento já foi movido pelo SortableJS.
                            // A sprint de origem precisa ser atualizada (contagem de horas).
                            // As listas de backlog/genéricas precisam ser atualizadas para refletir a tarefa devolvida corretamente.
                            if (updatedTask.is_generic) {
                                console.log(`[Sortable onEnd] Tarefa ${taskId} (genérica) devolvida. Recarregando tarefas genéricas.`);
                                loadGenericTasks();
                            } else {
                                console.log(`[Sortable onEnd] Tarefa ${taskId} (de projeto) devolvida. Recarregando backlog de projetos.`);
                                loadBacklogTasks();
                            }
                            loadSprints(); // Atualiza a sprint de origem e outras para consistência
                        })
                        .catch(error => {
                            console.error(`[Sortable onEnd] Erro ao mover tarefa ${taskId} para o backlog via API:`, error);
                            alert(`Erro ao tentar mover tarefa para o backlog: ${error.message}. A interface pode estar dessincronizada. Por favor, atualize a página.`);
                            // Para garantir, recarregar tudo para tentar sincronizar
                            loadSprints();
                            loadBacklogTasks();
                            loadGenericTasks();
                        });
                    }
                }
            });
            sortableInstances.push(instance);
        });
    }

    // <<< INÍCIO: Função para inicializar todos os popovers >>>
    function initializePopovers() {
        console.log("[Sprint Mgmt] Inicializando Popovers...");
        const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
        popoverTriggerList.forEach(popoverTriggerEl => {
            // Gera um ID único para o botão se não existir (necessário para armazenar instância)
            if (!popoverTriggerEl.id) {
                popoverTriggerEl.id = `popover-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
            }
            // Cria e armazena a instância
            const instance = new bootstrap.Popover(popoverTriggerEl);
            popoverInstances[popoverTriggerEl.id] = instance;
        });
        console.log(`[Sprint Mgmt] ${Object.keys(popoverInstances).length} instâncias Popover inicializadas.`);

        // Opcional: Adicionar listener para destruir popovers ao sair da página?
    }
    // <<< FIM: Função para inicializar todos os popovers >>>

    // *** TODO: Função para chamar a API ***
    // Função para chamar a API e atualizar a associação da sprint da tarefa
    async function updateTaskSprintAssignment(taskId, sprintId, newPosition) {
        const apiUrl = `/backlog/api/tasks/${taskId}/assign`;
        // Se sprintId for undefined (arrastado para a coluna de backlog), envia null
        const payload = {
             sprint_id: sprintId === undefined ? null : sprintId, 
             position: newPosition 
            };

        console.log(`[API Call] Chamando ${apiUrl} com payload:`, payload);

        try {
            const response = await fetch(apiUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { 
                    const errorData = await response.json();
                    errorMsg = errorData.message || errorData.description || errorMsg; 
                } catch(e) {}
                throw new Error(errorMsg);
            }

            const updatedTask = await response.json();
            console.log("[API Call] Tarefa atualizada com sucesso:", updatedTask);
            // Opcional: Atualizar visualmente o card da tarefa se a API retornar dados úteis
            // Por enquanto, a mudança visual já foi feita pelo SortableJS.

        } catch (error) {
            console.error("[API Call] Erro ao atualizar sprint da tarefa:", error);
            alert(`Erro ao mover tarefa: ${error.message}\nA interface pode estar dessincronizada. Recarregue a página.`);
            // TODO: Implementar lógica para reverter a mudança visual do SortableJS?
            // Isso é complexo, recarregar a página pode ser a solução mais simples.
            // window.location.reload(); 
        }
    }

    // Função para escapar HTML (segurança)
    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
           .replace(/&/g, "&amp;")
           .replace(/</g, "&lt;")
           .replace(/>/g, "&gt;")
           .replace(/"/g, "&quot;")
           .replace(/'/g, "&#039;");
    }

    // --- Funções de Ação (Editar/Excluir) ---

    // Prepara e abre o modal para edição
    async function openEditModal(sprintId) {
        console.log(`Abrindo modal para editar Sprint ID: ${sprintId}`);
        sprintForm.reset(); // Limpa o formulário
        editingSprintId = sprintId;
        formMethodInput.value = 'PUT'; // Define método como PUT
        sprintModalLabel.textContent = 'Editar Sprint';
        modalDeleteBtn.style.display = 'inline-block'; // Mostra botão excluir
        showModalLoading(true); // Mostra loading antes do fetch
        sprintModal.show();

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar dados da sprint ${sprintId}`);
            }
            const sprintData = await response.json();

            // Preenche o formulário
            document.getElementById('sprintId').value = sprintData.id;
            document.getElementById('sprintName').value = sprintData.name;
            // Formata data para YYYY-MM-DD para input date
            document.getElementById('sprintStartDate').value = sprintData.start_date ? sprintData.start_date.substring(0, 10) : '';
            document.getElementById('sprintEndDate').value = sprintData.end_date ? sprintData.end_date.substring(0, 10) : '';
            document.getElementById('sprintGoal').value = sprintData.goal || '';
            document.getElementById('sprintCriticality').value = sprintData.criticality || 'Normal';

        } catch (error) {
            console.error("Erro ao carregar dados para edição:", error);
            alert(`Erro ao carregar dados da sprint: ${error.message}`)
            sprintModal.hide(); // Esconde o modal se deu erro ao carregar
        } finally {
            showModalLoading(false);
        }
    }

    // Exclui uma sprint
    async function deleteSprint(sprintId, sprintName) {
        if (!confirm(`Tem certeza que deseja excluir a sprint "${sprintName}"?\nAs tarefas associadas serão desvinculadas.`)) {
            return;
        }
        console.log(`Tentando excluir Sprint ID: ${sprintId}`);
        // Poderíamos mostrar um loading na linha da tabela ou geral

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`, {
                method: 'DELETE'
            });

            if (!response.ok && response.status !== 200 && response.status !== 204) { // Aceita 200 ou 204
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            console.log(`Sprint ${sprintId} excluída com sucesso.`);
            // Opcional: Mostrar um toast/alert de sucesso
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("Erro ao excluir sprint:", error);
            alert(`Erro ao excluir sprint: ${error.message}`);
        }
    }

    // --- Fim Funções de Ação ---

    // Listener para submissão do formulário (Criar/Editar Sprint)
    sprintForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("[Submit Handler] Evento submit detectado."); // Log A
        showModalLoading(true);

        const formData = new FormData(sprintForm);
        console.log("[Submit Handler] FormData criado."); // Log B
        const data = {
            name: formData.get('name'),
            // Input type=date já retorna YYYY-MM-DD, que é compatível com fromisoformat no backend
            start_date: formData.get('start_date'), 
            end_date: formData.get('end_date'),   // O input type=date já retorna YYYY-MM-DD
            goal: formData.get('goal') || null,
            criticality: formData.get('criticality') || 'Normal'
        };

        // Validação simples das datas no frontend
        if (data.start_date && data.end_date && data.start_date > data.end_date) {
            alert('A data de início não pode ser posterior à data de fim.');
            showModalLoading(false);
            return;
        }

        console.log("[Submit Handler] Validação passou. Preparando fetch..."); // Log C
        // Define URL e Método baseado na edição ou criação
        const isEditing = !!editingSprintId;
        const url = isEditing ? `${apiSprintsBaseUrl}/${editingSprintId}` : apiSprintsBaseUrl;
        const method = isEditing ? 'PUT' : 'POST';
        console.log(`Enviando ${method} para ${url}`);

        try {
            console.log("[Submit Handler] Dentro do try, antes do fetch."); // Log D
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            console.log("[Submit Handler] Fetch concluído, resposta recebida.", response.status); // Log E

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            const savedSprint = await response.json();
            console.log(`Sprint ${isEditing ? 'atualizada' : 'criada'}:`, savedSprint);
            sprintModal.hide();
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("[Submit Handler] Erro no bloco catch:", error); // Log F
            console.error("Erro ao salvar sprint:", error);
            alert(`Erro ao salvar sprint: ${error.message}`);
        } finally {
            console.log("[Submit Handler] Bloco finally executado."); // Log G
            showModalLoading(false);
        }
    });

    // Listener de CLIQUE no botão Salvar (para depuração)
    const submitButton = sprintForm.querySelector('button[type="submit"]');
    if (submitButton) {
        submitButton.addEventListener('click', function(clickEvent) {
            console.log("[Submit Button Click] Botão Salvar clicado!");
            // Poderíamos até chamar a função de submit daqui manualmente se necessário,
            // mas primeiro vamos ver se o clique é registrado.
        });
    } else {
        console.error("[Sprint Mgmt] Botão Salvar (submit) não encontrado dentro do formulário!");
    }

    // Event Delegation para botões de Ação na tabela
    sprintBoard.addEventListener('click', function(event) { // Agora escuta cliques no quadro
        const target = event.target.closest('button'); // Encontra o botão clicado
        if (!target) return; // Sai se o clique não foi em um botão

        const sprintId = target.dataset.id;
        if (!sprintId) return; // Sai se o botão não tem ID

        if (target.classList.contains('edit-btn')) {
            openEditModal(sprintId);
        }
        else if (target.classList.contains('delete-btn')) {
            const sprintName = target.dataset.name || `Sprint ${sprintId}`; // Pega nome do data attribute
            deleteSprint(sprintId, sprintName);
        }
        // Adicionar else if para 'allocate-btn' futuramente
    });

    // Listener para botão Excluir DENTRO do modal (apenas na edição)
    modalDeleteBtn.addEventListener('click', function() {
        if (editingSprintId) {
            const sprintNameInput = document.getElementById('sprintName');
            const sprintName = sprintNameInput ? sprintNameInput.value : `Sprint ${editingSprintId}`; 
            sprintModal.hide(); // Esconde o modal antes de confirmar exclusão
            deleteSprint(editingSprintId, sprintName);
        }
    });

    // Listener para quando o modal é fechado (resetar)
    sprintModalElement.addEventListener('hidden.bs.modal', function (event) {
        sprintForm.reset();
        sprintModalLabel.textContent = 'Nova Sprint';
        formMethodInput.value = 'POST'; // Reseta método para POST
        editingSprintId = null;
        modalDeleteBtn.style.display = 'none'; // Esconde botão excluir
    });

    // Listener para quando o modal está PRESTES A SER EXIBIDO
    sprintModalElement.addEventListener('show.bs.modal', function (event) {
        // Garante que o modal sempre abra sem o loading ativo
        // A função openEditModal vai ativar o loading se necessário DEPOIS disso.
        console.log("[Sprint Mgmt] Evento show.bs.modal disparado. Garantindo que loading está desligado.");
        showModalLoading(false);
        // O reset do formulário e título já é feito no hidden.bs.modal
        // Mas podemos garantir o título aqui também para o caso de criação
        if (!editingSprintId) {
            sprintModalLabel.textContent = 'Nova Sprint';
            modalDeleteBtn.style.display = 'none';
            formMethodInput.value = 'POST';
        }
    });

    // Carrega Sprints e Backlog em paralelo e inicializa SortableJS DEPOIS que ambos terminarem
    console.log("[Sprint Mgmt] Iniciando carregamento inicial de Sprints e Backlog...");
    Promise.all([
        loadSprints(),      // loadSprints já é async
        loadBacklogTasks()  // loadBacklogTasks já é async
    ]).then(() => {
        console.log("[Sprint Mgmt] Carregamento inicial de Sprints e Backlog CONCLUÍDO.");
        initializeSortable(); // Chama UMA VEZ após tudo estar carregado
        initializePopovers(); // <<< INICIALIZA Popovers após carregamento inicial >>>
    }).catch(error => {
        console.error("[Sprint Mgmt] Erro durante o carregamento inicial (Promise.all):", error);
        // Mostrar uma mensagem de erro geral para o usuário?
        sprintBoard.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais. Recarregue a página.</div>';
        backlogColumnBody.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais.</div>';
    });

    // <<< INÍCIO: Lógica para Recolher/Expandir Backlog (JS Manipula Estilos) >>>
    const toggleBtn = document.getElementById('toggleBacklogBtn');
    const backlogColumn = document.getElementById('backlogColumn'); // Seleciona a coluna diretamente
    const boardContainer = document.getElementById('sprintBoardContainer'); // Container ainda útil?

    if (toggleBtn && backlogColumn) { // Verifica se botão e COLUNA existem
        // Função para aplicar estilos de recolhimento/expansão
        function applyCollapseStyles(collapse) {
            if (collapse) {
                backlogColumn.style.flexBasis = '0px';
                backlogColumn.style.minWidth = '0px';
                backlogColumn.style.opacity = '0';
                backlogColumn.style.paddingLeft = '0';
                backlogColumn.style.paddingRight = '0';
                backlogColumn.style.borderWidth = '0';
                backlogColumn.style.pointerEvents = 'none';
                toggleBtn.classList.add('collapsed-trigger'); // Adiciona classe ao botão
            } else {
                // Remove estilos inline para voltar aos padrões do CSS
                backlogColumn.style.removeProperty('flex-basis');
                backlogColumn.style.removeProperty('min-width');
                backlogColumn.style.removeProperty('opacity');
                backlogColumn.style.removeProperty('padding-left');
                backlogColumn.style.removeProperty('padding-right');
                backlogColumn.style.removeProperty('border-width');
                backlogColumn.style.removeProperty('pointer-events');
                toggleBtn.classList.remove('collapsed-trigger'); // Remove classe do botão
            }
        }

        // Função para atualizar ícone e título do botão
        function updateButtonState(collapsed) {
            const icon = toggleBtn.querySelector('i');
            if (collapsed) {
                if (icon) icon.className = 'bi bi-chevron-double-right';
                toggleBtn.title = 'Expandir Backlog';
            } else {
                if (icon) icon.className = 'bi bi-chevron-double-left';
                toggleBtn.title = 'Recolher Backlog';
            }
        }

        // Estado inicial (lido do localStorage)
        let isCollapsed = localStorage.getItem('sprintBacklogCollapsed') === 'true';
        applyCollapseStyles(isCollapsed); // Aplica estilos iniciais
        updateButtonState(isCollapsed); // Define botão inicial

        // Listener de clique no botão
        toggleBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed; // Inverte o estado
            applyCollapseStyles(isCollapsed); // Aplica novos estilos
            updateButtonState(isCollapsed); // Atualiza botão
            localStorage.setItem('sprintBacklogCollapsed', isCollapsed ? 'true' : 'false'); // Salva estado
        });

    } else {
        console.error('[Sprint Mgmt] Botão #toggleBacklogBtn ou Coluna #backlogColumn não encontrados.');
    }
    // <<< FIM: Lógica para Recolher/Expandir Backlog >>>

    // Função para carregar tarefas genéricas
    async function loadGenericTasks() {
        const genericTasksBody = document.querySelector('#genericTasksColumn .side-column-body');
        genericTasksBody.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm" role="status"></div> Carregando tarefas genéricas...</div>';
        
        try {
            const response = await fetch('/sprints/api/generic-tasks');
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar tarefas genéricas`);
            }
            const tasks = await response.json();
            
            genericTasksBody.innerHTML = '';
            if (tasks.length === 0) {
                genericTasksBody.innerHTML = '<div class="text-center text-muted p-3">Nenhuma tarefa genérica encontrada.</div>';
                return;
            }
            
            tasks.forEach(task => {
                const taskCard = document.createElement('div');
                taskCard.className = `generic-task ${task.status === 'Concluído' ? 'task-completed' : ''}`;
                taskCard.dataset.taskId = task.id;
                taskCard.draggable = true;
                
                taskCard.innerHTML = `
                    <div class="generic-task-title">${escapeHtml(task.title)}</div>
                    <div class="generic-task-meta">
                        <span class="project-badge">${escapeHtml(task.priority)}</span>
                    </div>
                `;
                
                // Adiciona evento de clique para edição
                taskCard.addEventListener('click', () => openGenericTaskModal(task));
                
                genericTasksBody.appendChild(taskCard);
                
                // Aplica classe de cor ao badge de prioridade
                const badgeElement = taskCard.querySelector('.project-badge');
                if (badgeElement) {
                    const priorityLower = (task.priority || '').toLowerCase();
                    let badgeClass = 'text-bg-primary'; // Default: Média
                    if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                    else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                    else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                    badgeElement.classList.add(...badgeClass.split(' '));
                }
            });
        } catch (error) {
            console.error("Erro ao carregar tarefas genéricas:", error);
            genericTasksBody.innerHTML = `<div class="alert alert-danger">Erro ao carregar tarefas genéricas: ${error.message}</div>`;
        }
    }

    // Modal de Tarefa Genérica
    const genericTaskModal = new bootstrap.Modal(document.getElementById('genericTaskModal'));
    const genericTaskForm = document.getElementById('genericTaskForm');
    const genericTaskDeleteBtn = document.getElementById('genericTaskDeleteBtn');
    let editingGenericTaskId = null;

    // Função para abrir o modal de tarefa genérica
    function openGenericTaskModal(task = null) {
        const modalTitle = document.getElementById('genericTaskModalLabel');
        const deleteBtn = document.getElementById('genericTaskDeleteBtn');
        
        genericTaskForm.reset();
        
        if (task) {
            modalTitle.textContent = 'Editar Tarefa Genérica';
            document.getElementById('genericTaskId').value = task.id;
            document.getElementById('genericTaskTitle').value = task.title;
            document.getElementById('genericTaskDescription').value = task.description || '';
            document.getElementById('genericTaskPriority').value = task.priority || 'Média';
            document.getElementById('genericTaskEffort').value = task.estimated_hours || '';
            document.getElementById('genericTaskSpecialist').value = task.specialist_name || '';
            deleteBtn.style.display = 'block';
            editingGenericTaskId = task.id;
        } else {
            modalTitle.textContent = 'Nova Tarefa Genérica';
            deleteBtn.style.display = 'none';
            editingGenericTaskId = null;
        }
        
        genericTaskModal.show();
    }

    // Handler para submissão do formulário de tarefa genérica
    genericTaskForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(genericTaskForm);
        const data = {
            title: formData.get('title'),
            description: formData.get('description'),
            priority: formData.get('priority'),
            estimated_hours: formData.get('estimated_effort') ? parseFloat(formData.get('estimated_effort')) : null,
            specialist_name: formData.get('specialist_name') || null
        };
        
        try {
            const url = editingGenericTaskId 
                ? `/sprints/api/generic-tasks/${editingGenericTaskId}`
                : '/sprints/api/generic-tasks';
            
            const response = await fetch(url, {
                method: editingGenericTaskId ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks();
            
        } catch (error) {
            console.error("Erro ao salvar tarefa genérica:", error);
            alert(`Erro ao salvar tarefa genérica: ${error.message}`);
        }
    });

    // Handler para exclusão de tarefa genérica
    genericTaskDeleteBtn.addEventListener('click', async function() {
        if (!editingGenericTaskId || !confirm('Tem certeza que deseja excluir esta tarefa genérica?')) {
            return;
        }
        
        try {
            const response = await fetch(`/sprints/api/generic-tasks/${editingGenericTaskId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks(); // Recarrega as tarefas genéricas
            loadSprints(); // Recarrega as sprints para atualizar caso a tarefa estivesse em alguma sprint
            
        } catch (error) {
            console.error("Erro ao excluir tarefa genérica:", error);
            alert(`Erro ao excluir tarefa genérica: ${error.message}`);
        }
    });

    // Carrega as tarefas genéricas junto com o resto dos dados
    loadGenericTasks();

    // Adiciona listener para o botão de adicionar tarefa genérica
    const addGenericTaskBtn = document.getElementById('addGenericTaskBtn');
    if (addGenericTaskBtn) {
        addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    }

    // Função para atualizar o popover de horas por especialista de uma sprint
    function updateSpecialistPopover(sprintListElement) {
        const sprintCard = sprintListElement.closest('.sprint-card');
        if (!sprintCard) return;

        // Encontra todas as tarefas na sprint
        const tasks = sprintListElement.querySelectorAll('.backlog-task-card');
        let hoursBySpecialist = {};

        // Calcula horas por especialista
        tasks.forEach(task => {
            const specialist = task.dataset.specialistName;
            if (specialist && specialist.trim()) { // Só considera se tiver especialista
                const hours = parseFloat(task.dataset.estimatedHours) || 0;
                hoursBySpecialist[specialist] = (hoursBySpecialist[specialist] || 0) + hours;
            }
        });

        // Formata o conteúdo do popover
        let popoverContent = Object.entries(hoursBySpecialist)
            .map(([name, hours]) => `<div>${escapeHtml(name)}: <strong>${hours.toFixed(1)}h</strong></div>`)
            .join('');

        // Atualiza o popover
        const popoverButton = sprintCard.querySelector('.specialist-hours-popover');
        if (popoverButton) {
            // Destrói o popover existente
            const popoverInstance = bootstrap.Popover.getInstance(popoverButton);
            if (popoverInstance) {
                popoverInstance.dispose();
            }

            if (Object.keys(hoursBySpecialist).length > 0) {
                // Cria um novo popover com o conteúdo atualizado
                new bootstrap.Popover(popoverButton, {
                    content: popoverContent,
                    html: true,
                    placement: 'bottom',
                    trigger: 'hover focus'
                });
                popoverButton.style.display = 'inline-flex';
            } else {
                popoverButton.style.display = 'none';
            }
        }
    }

    // Função para abrir o modal de detalhes da tarefa
    function openTaskDetailsModal(taskElement) {
        const taskId = taskElement.dataset.taskId;
        const taskType = taskElement.classList.contains('generic-task') ? 'generic' : 'backlog';
        const form = document.getElementById('taskDetailsForm');
        const backlogFields = document.getElementById('backlogSpecificFields');
        const modalTitle = document.getElementById('taskDetailsModalLabel');
        const deleteBtn = document.getElementById('taskDeleteBtn');

        // Reset form e configura campos básicos
        form.reset();
        document.getElementById('taskId').value = taskId;
        document.getElementById('taskType').value = taskType;

        // Configura visibilidade dos campos específicos do backlog
        backlogFields.classList.toggle('d-none', taskType === 'generic');

        // Busca dados da tarefa na API
        fetch(`/backlog/api/tasks/${taskId}`)
            .then(response => {
                if (!response.ok) throw new Error(`Erro ${response.status}`);
                return response.json();
            })
            .then(task => {
                // Preenche os campos do formulário
                document.getElementById('taskTitle').value = task.name || '';
                document.getElementById('taskPriority').value = task.priority || 'Média';
                document.getElementById('taskSpecialist').value = task.specialist_name || '';
                document.getElementById('taskEstimatedHours').value = task.estimated_hours || '';
                document.getElementById('taskDescription').value = task.description || '';
                document.getElementById('taskStatus').value = task.status || 'pendente';

                if (taskType === 'backlog') {
                    document.getElementById('taskProjectId').value = task.project_id || '';
                    document.getElementById('taskColumnIdentifier').value = task.column_identifier || '';
                }

                // Configura título do modal
                modalTitle.textContent = `Detalhes da Tarefa - ${task.name}`;

                // Mostra o modal
                const taskModal = new bootstrap.Modal(document.getElementById('taskDetailsModal'));
                taskModal.show();
            })
            .catch(error => {
                console.error('Erro ao carregar detalhes da tarefa:', error);
                alert('Erro ao carregar detalhes da tarefa. Por favor, tente novamente.');
            });
    }

    // Handler para submissão do formulário de detalhes da tarefa
    document.getElementById('taskDetailsForm').addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(this);
        const taskId = formData.get('taskId');
        const taskType = formData.get('taskType');
        
        const data = {
            name: formData.get('title'),
            priority: formData.get('priority'),
            specialist_name: formData.get('specialist_name'),
            estimated_hours: formData.get('estimated_hours') ? parseFloat(formData.get('estimated_hours')) : null,
            description: formData.get('description')
        };
        const statusValue = formData.get('status');
        if (statusValue && statusValue !== 'None' && statusValue !== '') {
            data.status = statusValue;
        }

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao salvar tarefa:', error);
            alert('Erro ao salvar alterações. Por favor, tente novamente.');
        }
    });

    // Handler para exclusão de tarefa
    document.getElementById('taskDeleteBtn').addEventListener('click', async function() {
        const taskId = document.getElementById('taskId').value;
        const taskType = document.getElementById('taskType').value;
        
        if (!confirm('Tem certeza que deseja excluir esta tarefa?')) return;

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'DELETE'
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao excluir tarefa:', error);
            alert('Erro ao excluir tarefa. Por favor, tente novamente.');
        }
    });

    // Adiciona evento de clique nas tarefas
    document.addEventListener('click', function(event) {
        const taskCard = event.target.closest('.backlog-task-card:not(.generic-task)');
        if (taskCard && !event.target.closest('.task-actions')) {
            openTaskDetailsModal(taskCard);
        }
    });

    // Delegação de eventos para botões de editar e excluir Sprints
    sprintBoard.addEventListener('click', function(event) {
        const editButton = event.target.closest('.edit-btn');
        const deleteButton = event.target.closest('.delete-btn');
        const unarchiveButton = event.target.closest('.unarchive-btn');

        if (editButton) {
            const sprintId = editButton.dataset.id;
            openEditModal(sprintId);
        } else if (deleteButton) {
            const sprintId = deleteButton.dataset.id;
            const sprintName = deleteButton.dataset.name;
            deleteSprint(sprintId, sprintName);
        } else if (unarchiveButton) {
            const sprintId = unarchiveButton.dataset.id;
            const sprintName = unarchiveButton.dataset.name;
            openUnarchiveModal(sprintId, sprintName);
        }
    });

    // Carrega os dados iniciais (Este bloco de chamadas diretas é redundante se Promise.all está sendo usado)
    // loadSprints(); // Redundante
    // loadBacklogTasks(); // Redundante
    // loadGenericTasks(); // Redundante

    // <<< INÍCIO: Event Listeners para Coluna de Tarefas Genéricas >>>
    // A declaração e o listener para addGenericTaskBtn já foram feitos anteriormente no código.
    // Este bloco abaixo é uma duplicação e causa o erro de linter, então será removido.
    // const addGenericTaskBtn = document.getElementById('addGenericTaskBtn'); 
    // if (addGenericTaskBtn) {
    //     addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    // }
    // <<< FIM: Event Listeners para Coluna de Tarefas Genéricas >>>

    // ========================================
    // NOVO: SISTEMA DE ARQUIVAMENTO DE SPRINTS
    // ========================================

    // Função para alternar view
    function changeView(view) {
        currentView = view;
        
        // Atualiza botões
        document.querySelectorAll('.view-toggle-btn').forEach(btn => btn.classList.remove('active'));
        const targetBtn = document.getElementById(`view${view.charAt(0).toUpperCase() + view.slice(1)}Btn`);
        if (targetBtn) targetBtn.classList.add('active');
        
        // Atualiza controles de ações em lote
        const bulkActions = document.getElementById('sprintBulkActions');
        if (bulkActions) {
            if (view === 'active') {
                bulkActions.style.display = 'flex';
                if (archiveSelectedBtn) archiveSelectedBtn.style.display = selectMode ? 'inline-block' : 'none';
                if (unarchiveSelectedBtn) unarchiveSelectedBtn.style.display = 'none';
            } else if (view === 'archived') {
                bulkActions.style.display = 'flex';
                if (archiveSelectedBtn) archiveSelectedBtn.style.display = 'none';
                if (unarchiveSelectedBtn) unarchiveSelectedBtn.style.display = selectMode ? 'inline-block' : 'none';
            } else {
                bulkActions.style.display = 'none';
            }
        }
        
        // Recarrega sprints
        loadSprintsWithView();
    }

    // Função para carregar sprints baseada na view atual
    async function loadSprintsWithView() {
        try {
            let url;
            if (currentView === 'active') {
                // TEMPORÁRIO: Usar API original para teste
                url = '/sprints/api/sprints';
            } else if (currentView === 'archived') {
                url = '/backlog/api/sprints/archived';
            } else {
                // Para 'all', carrega ambas e combina
                const [activeResponse, archivedResponse] = await Promise.all([
                    fetch('/sprints/api/sprints'),
                    fetch('/backlog/api/sprints/archived')
                ]);
                
                const activeData = await activeResponse.json();
                const archivedData = await archivedResponse.json();
                
                // A API original retorna array direto, não objeto com 'sprints'
                const activeSprints = Array.isArray(activeData) ? activeData : activeData.sprints || [];
                const archivedSprints = Array.isArray(archivedData) ? archivedData : archivedData.sprints || [];
                
                const combinedSprints = [
                    ...activeSprints,
                    ...archivedSprints
                ];
                
                renderSprints(combinedSprints);
                return;
            }
            
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            const data = await response.json();
            
            // A API original retorna array direto
            const sprints = Array.isArray(data) ? data : data.sprints || [];
            renderSprints(sprints);
            
        } catch (error) {
            console.error('Erro ao carregar sprints:', error);
            if (sprintBoard) {
                sprintBoard.innerHTML = `
                    <div class="text-center text-danger p-5">
                        <i class="bi bi-exclamation-triangle fs-1"></i>
                        <p>Erro ao carregar sprints. Tente novamente.</p>
                    </div>
                `;
            }
        }
    }

    // Funções vazias para os elementos de arquivamento que não existem na interface atual
    function enableSelectMode() { console.log('enableSelectMode - não implementado'); }
    function disableSelectMode() { console.log('disableSelectMode - não implementado'); }
    function archiveSelectedSprints() { console.log('archiveSelectedSprints - não implementado'); }
    function unarchiveSelectedSprints() { console.log('unarchiveSelectedSprints - não implementado'); }
    function filterSprints() { console.log('filterSprints - não implementado'); }
    function clearSearch() { console.log('clearSearch - não implementado'); }

    // Função para habilitar modo de seleção
    function enableSelectMode() {
        selectMode = true;
        selectedSprints.clear();
        
        // Atualiza interface
        enableSelectModeBtn.style.display = 'none';
        cancelSelectModeBtn.style.display = 'inline-block';
        
        if (currentView === 'active') {
            archiveSelectedBtn.style.display = 'inline-block';
        } else if (currentView === 'archived') {
            unarchiveSelectedBtn.style.display = 'inline-block';
        }
        
        // Adiciona checkboxes
        addCheckboxesToSprints();
    }

    // Função para desabilitar modo de seleção
    function disableSelectMode() {
        selectMode = false;
        selectedSprints.clear();
        
        // Atualiza interface
        enableSelectModeBtn.style.display = 'inline-block';
        cancelSelectModeBtn.style.display = 'none';
        archiveSelectedBtn.style.display = 'none';
        unarchiveSelectedBtn.style.display = 'none';
        
        // Remove checkboxes
        removeCheckboxesFromSprints();
    }

    // Função para adicionar checkboxes às sprints
    function addCheckboxesToSprints() {
        document.querySelectorAll('.sprint-card').forEach(card => {
            if (!card.querySelector('.sprint-checkbox')) {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'form-check-input sprint-checkbox';
                checkbox.addEventListener('change', handleSprintSelection);
                
                card.classList.add('selectable');
                card.appendChild(checkbox);
            }
        });
    }

    // Função para remover checkboxes das sprints
    function removeCheckboxesFromSprints() {
        document.querySelectorAll('.sprint-card').forEach(card => {
            const checkbox = card.querySelector('.sprint-checkbox');
            if (checkbox) {
                checkbox.remove();
                card.classList.remove('selectable', 'selected');
            }
        });
    }

    // Handler para seleção de sprint
    function handleSprintSelection(event) {
        const checkbox = event.target;
        const sprintCard = checkbox.closest('.sprint-card');
        const sprintId = sprintCard.dataset.sprintId;
        
        if (checkbox.checked) {
            selectedSprints.add(sprintId);
            sprintCard.classList.add('selected');
        } else {
            selectedSprints.delete(sprintId);
            sprintCard.classList.remove('selected');
        }
        
        // Atualiza estado dos botões
        updateBulkActionButtons();
    }

    // Função para atualizar botões de ação em lote
    function updateBulkActionButtons() {
        const hasSelection = selectedSprints.size > 0;
        
        if (currentView === 'active') {
            archiveSelectedBtn.disabled = !hasSelection;
        } else if (currentView === 'archived') {
            unarchiveSelectedBtn.disabled = !hasSelection;
        }
    }

    // Função para arquivar sprints selecionadas
    async function archiveSelectedSprints() {
        if (selectedSprints.size === 0) return;
        
        // Mostra modal de confirmação em lote
        const selectedSprintsList = document.getElementById('selectedSprintsList');
        selectedSprintsList.innerHTML = '';
        
        selectedSprints.forEach(sprintId => {
            const sprintCard = document.querySelector(`[data-sprint-id="${sprintId}"]`);
            const sprintName = sprintCard.querySelector('.sprint-card-title')?.textContent || `Sprint ${sprintId}`;
            
            const sprintItem = document.createElement('div');
            sprintItem.className = 'mb-1 p-2 bg-white border rounded';
            sprintItem.innerHTML = `<i class="bi bi-calendar3 me-2"></i>${sprintName}`;
            selectedSprintsList.appendChild(sprintItem);
        });
        
        const bulkArchiveModal = new bootstrap.Modal(document.getElementById('bulkArchiveModal'));
        bulkArchiveModal.show();
    }

    // Função para desarquivar sprints selecionadas
    async function unarchiveSelectedSprints() {
        if (selectedSprints.size === 0) return;
        
        if (!confirm(`Desarquivar ${selectedSprints.size} sprint(s) selecionada(s)?`)) return;
        
        try {
            const sprintIds = Array.from(selectedSprints);
            const response = await fetch('/backlog/api/sprints/archive-bulk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sprint_ids: sprintIds,
                    archived_by: 'Sistema',
                    reason: 'Desarquivamento em lote'
                })
            });
            
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            disableSelectMode();
            loadSprintsWithView();
            
            showNotification('Sprints desarquivadas com sucesso!', 'success');
            
        } catch (error) {
            console.error('Erro ao desarquivar sprints:', error);
            showNotification('Erro ao desarquivar sprints', 'error');
        }
    }

    // Função para filtrar sprints
    function filterSprints() {
        const searchTerm = sprintSearchInput.value.toLowerCase();
        
        document.querySelectorAll('.sprint-card').forEach(card => {
            const sprintName = card.querySelector('.sprint-card-title')?.textContent?.toLowerCase() || '';
            const sprintGoal = card.querySelector('.sprint-goal')?.textContent?.toLowerCase() || '';
            
            const matches = sprintName.includes(searchTerm) || sprintGoal.includes(searchTerm);
            card.style.display = matches ? 'flex' : 'none';
        });
    }

    // Função para limpar busca
    function clearSearch() {
        sprintSearchInput.value = '';
        filterSprints();
    }

    // Event Listeners para modais de arquivamento
    document.getElementById('confirmArchiveBtn').addEventListener('click', confirmArchiveSprint);
    document.getElementById('confirmUnarchiveBtn').addEventListener('click', confirmUnarchiveSprint);
    document.getElementById('confirmBulkArchiveBtn').addEventListener('click', confirmBulkArchive);

    // Função para confirmar arquivamento individual
    async function confirmArchiveSprint() {
        const sprintId = document.getElementById('archiveSprintModal').dataset.sprintId;
        const archivedBy = document.getElementById('archivedBy').value || 'Sistema';
        const reason = document.getElementById('archiveReason').value;
        
        try {
            const response = await fetch(`/backlog/api/sprints/${sprintId}/archive`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ archived_by: archivedBy, reason })
            });
            
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            bootstrap.Modal.getInstance(document.getElementById('archiveSprintModal')).hide();
            loadSprintsWithView();
            
            showNotification('Sprint arquivada com sucesso!', 'success');
            
        } catch (error) {
            console.error('Erro ao arquivar sprint:', error);
            showNotification('Erro ao arquivar sprint', 'error');
        }
    }

    // Função para confirmar desarquivamento individual
    async function confirmUnarchiveSprint() {
        const sprintId = document.getElementById('unarchiveSprintModal').dataset.sprintId;
        const unarchivedBy = document.getElementById('unarchivedBy').value || 'Sistema';
        const reason = document.getElementById('unarchiveReason').value;
        
        try {
            const response = await fetch(`/backlog/api/sprints/${sprintId}/unarchive`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ unarchived_by: unarchivedBy, reason })
            });
            
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            bootstrap.Modal.getInstance(document.getElementById('unarchiveSprintModal')).hide();
            loadSprintsWithView();
            
            showNotification('Sprint desarquivada com sucesso!', 'success');
            
        } catch (error) {
            console.error('Erro ao desarquivar sprint:', error);
            showNotification('Erro ao desarquivar sprint', 'error');
        }
    }

    // Função para confirmar arquivamento em lote
    async function confirmBulkArchive() {
        const sprintIds = Array.from(selectedSprints);
        const archivedBy = document.getElementById('bulkArchivedBy').value || 'Sistema';
        const reason = document.getElementById('bulkArchiveReason').value || 'Arquivamento em lote';
        
        try {
            const response = await fetch('/backlog/api/sprints/archive-bulk', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    sprint_ids: sprintIds,
                    archived_by: archivedBy,
                    reason
                })
            });
            
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            bootstrap.Modal.getInstance(document.getElementById('bulkArchiveModal')).hide();
            disableSelectMode();
            loadSprintsWithView();
            
            showNotification(`${sprintIds.length} sprints arquivadas com sucesso!`, 'success');
            
        } catch (error) {
            console.error('Erro ao arquivar sprints em lote:', error);
            showNotification('Erro ao arquivar sprints', 'error');
        }
    }

    // Função para mostrar notificações
    function showNotification(message, type = 'info') {
        // Implementação simples com alert - pode ser melhorada com toast
        if (type === 'success') {
            alert('✅ ' + message);
        } else if (type === 'error') {
            alert('❌ ' + message);
        } else {
            alert('ℹ️ ' + message);
        }
    }

    // Inicializa funcionalidades após renderizar
    initializeSortable();
    initializePopovers();

    // Função para renderizar sprints (VERSÃO FINAL CORRIGIDA)
    window.renderSprints = function(sprints) {
        console.log("[Sprint Mgmt] renderSprints() chamado com", sprints.length, "sprints");
        sprintBoard.innerHTML = ''; // Limpa o quadro
        
        if (!sprints || sprints.length === 0) {
            sprintBoard.innerHTML = '<div class="text-center text-muted p-5">Nenhuma sprint encontrada.</div>';
            return;
        }

        sprints.forEach(sprint => {
            // INÍCIO DA NOVA VERIFICAÇÃO DE ERRO
            if (sprint.error) {
                console.warn(`[Sprint Mgmt] Sprint ID ${sprint.id || 'N/A'} retornou com erro da API: ${sprint.error}`);
                const errorCard = document.createElement('div');
                errorCard.className = 'sprint-card'; 
                errorCard.style.border = '2px solid red';
                errorCard.innerHTML = `
                    <div class="sprint-card-header" style="background-color: #f8d7da; color: #721c24;">
                        <h6 class="sprint-card-title">Erro ao carregar Sprint ${sprint.id || '(ID Desconhecido)'}</h6>
                    </div>
                    <div class="sprint-card-body">
                        <p><strong>Detalhe do erro:</strong> ${escapeHtml(sprint.error)}</p>
                        <p class="text-muted small">Verifique os logs do servidor para mais informações.</p>
                    </div>
                `;
                sprintBoard.appendChild(errorCard);
                return; // Pula para a próxima sprint
            }
            // FIM DA NOVA VERIFICAÇÃO DE ERRO

            const sprintCard = document.createElement('div');
            sprintCard.className = 'sprint-card';
            sprintCard.dataset.sprintId = sprint.id;

            // Adiciona classe de arquivada se necessário
            if (sprint.is_archived) {
                sprintCard.classList.add('archived');
            }

            // <<< INÍCIO: Calcular Total de Horas Estimadas da Sprint >>>
            let totalSprintHours = 0.0;
            if (sprint.tasks && sprint.tasks.length > 0) {
                totalSprintHours = sprint.tasks.reduce((sum, task) => {
                    const taskHours = parseFloat(task.estimated_hours);
                    return sum + (isNaN(taskHours) ? 0 : taskHours);
                }, 0.0);
            }
            // <<< FIM: Calcular Total de Horas Estimadas da Sprint >>>

            // <<< INÍCIO: Calcular Horas por Especialista >>>
            let hoursBySpecialist = {};
            if (sprint.tasks && sprint.tasks.length > 0) {
                hoursBySpecialist = sprint.tasks.reduce((acc, task) => {
                    const specialist = task.specialist_name || 'Não Atribuído';
                    const hours = parseFloat(task.estimated_hours);
                    if (!isNaN(hours)) {
                        acc[specialist] = (acc[specialist] || 0) + hours;
                    }
                    return acc;
                }, {});
            }
            // Formata o conteúdo do popover
            let popoverContent = Object.entries(hoursBySpecialist)
                .map(([name, hours]) => `<div>${escapeHtml(name)}: <strong>${hours.toFixed(1)}h</strong></div>`)
                .join('');
            if (!popoverContent) {
                popoverContent = '<div class="text-muted small">Nenhum especialista</div>';
            }
            // <<< FIM: Calcular Horas por Especialista >>>

            // Determina botões de ação baseado no status de arquivamento
            let actionButtons = '';
            if (sprint.is_archived) {
                actionButtons = `
                    <button class="btn btn-sm btn-info unarchive-btn" data-id="${sprint.id}" data-name="${escapeHtml(sprint.name)}" title="Desarquivar Sprint">
                        <i class="bi bi-box-arrow-up"></i>
                    </button>
                `;
            } else {
                actionButtons = `
                    <button class="btn btn-sm btn-outline-secondary edit-btn" data-id="${sprint.id}" title="Editar Sprint">
                        <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${sprint.id}" data-name="${escapeHtml(sprint.name)}" title="Excluir Sprint">
                        <i class="bi bi-trash"></i>
                    </button>
                `;
            }

            sprintCard.innerHTML = `
                <div class="sprint-card-header criticality-${(sprint.criticality || 'normal').toLowerCase()}">
                    ${sprint.is_archived ? '<span class="archived-badge"><i class="bi bi-archive me-1"></i>Arquivada</span>' : ''}
                    <div class="sprint-header-top">
                        <div class="sprint-title-area">
                            <h6 class="sprint-card-title">${escapeHtml(sprint.name)}</h6>
                            <div class="sprint-meta">
                                <span class="sprint-badge">
                                    <i class="bi bi-stopwatch"></i>${totalSprintHours.toFixed(1)}h
                                </span>
                                ${Object.keys(hoursBySpecialist).length > 0 ? `
                                <button type="button" class="sprint-badge specialist-hours-popover" 
                                        data-bs-toggle="popover" 
                                        data-bs-placement="bottom"
                                        data-bs-trigger="hover focus"
                                        data-bs-html="true" 
                                        title="Horas por Especialista"
                                        data-bs-content="${popoverContent}">
                                    <i class="bi bi-people"></i>Especialistas
                                </button>
                                ` : ''}
                            </div>
                        </div>
                        <div class="sprint-card-actions">
                            ${actionButtons}
                        </div>
                    </div>
                    <div class="sprint-header-bottom">
                        <div class="sprint-dates">
                            <i class="bi bi-calendar-range"></i>
                            ${formatDate(sprint.start_date)} - ${formatDate(sprint.end_date)}
                        </div>
                        <div class="sprint-goal">
                            ${escapeHtml(sprint.goal || 'Sem objetivo definido.')}
                        </div>
                    </div>
                </div>
                <div class="sprint-card-body">
                    <div class="sprint-tasks" data-sprint-id="${sprint.id}">
                        ${sprint.tasks && sprint.tasks.length > 0 ? 
                            sprint.tasks.map(task => {
                                const projectPart = task.project_id || 'PROJ';
                                const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase(); 
                                const isCompleted = task.column_identifier === 'concluido';
                                const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;
                                return `
                                <div class="backlog-task-card sprint-task-card ${isCompleted ? 'task-completed' : ''}" data-task-id="${task.id}" draggable="true" data-estimated-hours="${task.estimated_hours || 0}" data-specialist-name="${escapeHtml(task.specialist_name || '')}" data-is-generic="${task.is_generic || false}">
                                    <div class="task-title">${escapeHtml(task.name)}</div>
                                    ${task.project_id && !task.is_generic ? `<div class="task-project-info small text-muted mb-2">
                                        <i class="bi bi-folder2 me-1"></i>${task.project_id}${task.project_name ? ` - ${escapeHtml(task.project_name.length > 20 ? task.project_name.substring(0, 20) + '...' : task.project_name)}` : ''}
                                    </div>` : ''}
                                    <div class="task-meta">
                                        <div class="task-meta-left">
                                            <span class="badge rounded-pill task-priority-badge">${escapeHtml(task.priority || 'Média')}</span>
                                        </div>
                                        <div class="task-meta-right text-muted task-hours">
                                            ${task.estimated_hours ? `<i class="bi bi-clock"></i> ${task.estimated_hours}h` : ''}
                                        </div>
                                    </div>
                                    ${task.specialist_name ? `<div class="task-specialist"><i class="bi bi-person-fill"></i> ${escapeHtml(task.specialist_name)}</div>` : ''}
                                    <div class="task-actions">
                                        {# REMOVIDO BOTÃO DEVOLVER DAQUI #}
                                    </div>
                                </div>`;
                            }).join('') 
                            : '<small class="text-muted fst-italic ps-2">Nenhuma tarefa alocada.</small>' 
                        } 
                    </div>
                </div>
            `;
            sprintBoard.appendChild(sprintCard);

            // Aplica classe de cor ao badge de prioridade APÓS adicionar ao DOM
            if (sprint.tasks) {
                sprint.tasks.forEach(task => {
                    const cardElement = sprintBoard.querySelector(`.sprint-task-card[data-task-id="${task.id}"]`);
                    if (cardElement) {
                        const badgeElement = cardElement.querySelector('.task-priority-badge');
                        if (badgeElement) {
                            const priorityLower = (task.priority || '').toLowerCase();
                            let badgeClass = 'text-bg-primary'; // Default: Média
                            if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                            else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                            else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                            badgeElement.classList.add(...badgeClass.split(' '));
                        }
                    }
                });
            }
        });
        
        // Adiciona checkboxes se em modo de seleção
        if (selectMode) {
            addCheckboxesToSprints();
        }
        
        // Inicializa funcionalidades após renderizar
        initializeSortable();
        initializePopovers();
    };

    // Funções para abrir modais
    window.openArchiveModal = function(sprintId, sprintName) {
        document.getElementById('archiveSprintName').textContent = sprintName;
        document.getElementById('archiveSprintModal').dataset.sprintId = sprintId;
        
        // Reset form
        document.getElementById('archiveReason').value = '';
        document.getElementById('archivedBy').value = 'Sistema';
        
        const modal = new bootstrap.Modal(document.getElementById('archiveSprintModal'));
        modal.show();
    };

    window.openUnarchiveModal = function(sprintId, sprintName) {
        document.getElementById('unarchiveSprintName').textContent = sprintName;
        document.getElementById('unarchiveSprintModal').dataset.sprintId = sprintId;
        
        // Reset form
        document.getElementById('unarchiveReason').value = '';
        document.getElementById('unarchivedBy').value = 'Sistema';
        
        const modal = new bootstrap.Modal(document.getElementById('unarchiveSprintModal'));
        modal.show();
    };

    // Substitui loadSprints original para usar a nova função
    const originalLoadSprints = window.loadSprints;
    window.loadSprints = loadSprintsWithView;

    // ========================================
    // FIM: SISTEMA DE ARQUIVAMENTO DE SPRINTS
    // ========================================

    // Carrega os dados iniciais
    Promise.all([
        loadSprintsWithView(), // Usa o novo sistema de arquivamento
        loadBacklogTasks(),
        loadGenericTasks()
    ]).then(() => {
        console.log('[Sprint Mgmt] Todos os dados carregados com sucesso.');
    }).catch(error => {
        console.error('[Sprint Mgmt] Erro ao carregar dados iniciais:', error);
    });

    // ========================================
    // FUNÇÕES AUXILIARES E MODAIS
    // ========================================

    // Event Listeners para modais de arquivamento (se existirem)
    const confirmArchiveBtn = document.getElementById('confirmArchiveBtn');
    const confirmUnarchiveBtn = document.getElementById('confirmUnarchiveBtn');
    const confirmBulkArchiveBtn = document.getElementById('confirmBulkArchiveBtn');
    
    if (confirmArchiveBtn) confirmArchiveBtn.addEventListener('click', confirmArchiveSprint);
    if (confirmUnarchiveBtn) confirmUnarchiveBtn.addEventListener('click', confirmUnarchiveSprint);
    if (confirmBulkArchiveBtn) confirmBulkArchiveBtn.addEventListener('click', confirmBulkArchive);

    // Funções para modais (implementações básicas)
    async function confirmArchiveSprint() { console.log('confirmArchiveSprint - não implementado'); }
    async function confirmUnarchiveSprint() { console.log('confirmUnarchiveSprint - não implementado'); } 
    async function confirmBulkArchive() { console.log('confirmBulkArchive - não implementado'); }
    function openUnarchiveModal(sprintId, sprintName) { console.log('openUnarchiveModal - não implementado'); }
    function showNotification(message, type) { console.log(`Notificação [${type}]: ${message}`); }
  }); // Fim DOMContentLoaded
</script>
{# Adiciona SortableJS #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

{# NOVO: Modais para Arquivamento de Sprints #}
<!-- Modal para Arquivar Sprint Individual -->
<div class="modal fade" id="archiveSprintModal" tabindex="-1" aria-labelledby="archiveSprintModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header bg-warning text-dark">
        <h5 class="modal-title" id="archiveSprintModalLabel">
          <i class="bi bi-archive me-2"></i>Arquivar Sprint
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          <i class="bi bi-info-circle me-2"></i>
          <strong>Arquivar sprint:</strong> A sprint será movida para o arquivo, mas poderá ser revisitada quando necessário.
        </div>
        <p>Tem certeza que deseja arquivar a sprint <strong id="archiveSprintName"></strong>?</p>
        <div class="mb-3">
          <label for="archiveReason" class="form-label">Motivo (opcional):</label>
          <textarea class="form-control" id="archiveReason" rows="2" placeholder="Motivo do arquivamento..."></textarea>
        </div>
        <div class="mb-3">
          <label for="archivedBy" class="form-label">Arquivado por:</label>
          <input type="text" class="form-control" id="archivedBy" placeholder="Seu nome" value="Sistema">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-warning" id="confirmArchiveBtn">
          <i class="bi bi-archive me-1"></i>Arquivar Sprint
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Modal para Desarquivar Sprint -->
<div class="modal fade" id="unarchiveSprintModal" tabindex="-1" aria-labelledby="unarchiveSprintModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header bg-info text-white">
        <h5 class="modal-title" id="unarchiveSprintModalLabel">
          <i class="bi bi-box-arrow-up me-2"></i>Desarquivar Sprint
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-warning">
          <i class="bi bi-exclamation-triangle me-2"></i>
          <strong>Desarquivar sprint:</strong> A sprint voltará para a lista de sprints ativas.
        </div>
        <p>Tem certeza que deseja desarquivar a sprint <strong id="unarchiveSprintName"></strong>?</p>
        <div class="mb-3">
          <label for="unarchiveReason" class="form-label">Motivo (opcional):</label>
          <textarea class="form-control" id="unarchiveReason" rows="2" placeholder="Motivo do desarquivamento..."></textarea>
        </div>
        <div class="mb-3">
          <label for="unarchivedBy" class="form-label">Desarquivado por:</label>
          <input type="text" class="form-control" id="unarchivedBy" placeholder="Seu nome" value="Sistema">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-info" id="confirmUnarchiveBtn">
          <i class="bi bi-box-arrow-up me-1"></i>Desarquivar Sprint
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Modal para Arquivamento em Lote -->
<div class="modal fade" id="bulkArchiveModal" tabindex="-1" aria-labelledby="bulkArchiveModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header bg-warning text-dark">
        <h5 class="modal-title" id="bulkArchiveModalLabel">
          <i class="bi bi-archive me-2"></i>Arquivar Múltiplas Sprints
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info">
          <i class="bi bi-info-circle me-2"></i>
          <strong>Arquivamento em lote:</strong> As sprints selecionadas serão movidas para o arquivo.
        </div>
        <div class="mb-3">
          <label class="form-label"><strong>Sprints selecionadas para arquivamento:</strong></label>
          <div id="selectedSprintsList" class="border rounded p-2 bg-light" style="min-height: 100px;">
            <!-- Lista será preenchida via JavaScript -->
          </div>
        </div>
        <div class="mb-3">
          <label for="bulkArchiveReason" class="form-label">Motivo (opcional):</label>
          <textarea class="form-control" id="bulkArchiveReason" rows="2" placeholder="Motivo do arquivamento em lote..."></textarea>
        </div>
        <div class="mb-3">
          <label for="bulkArchivedBy" class="form-label">Arquivado por:</label>
          <input type="text" class="form-control" id="bulkArchivedBy" placeholder="Seu nome" value="Sistema">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
        <button type="button" class="btn btn-warning" id="confirmBulkArchiveBtn">
          <i class="bi bi-archive me-1"></i>Arquivar Selecionadas
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Modal de Detalhes de Sprint Arquivada -->
<div class="modal fade" id="archivedSprintDetailsModal" tabindex="-1" aria-labelledby="archivedSprintDetailsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header bg-secondary text-white">
        <h5 class="modal-title" id="archivedSprintDetailsModalLabel">
          <i class="bi bi-archive me-2"></i>Detalhes da Sprint Arquivada
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="archivedSprintDetailsContent">
          <!-- Conteúdo será carregado via JavaScript -->
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-info" id="modalUnarchiveBtn" style="display: none;">
          <i class="bi bi-box-arrow-up me-1"></i>Desarquivar
        </button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
      </div>
    </div>
  </div>
</div>
{% endblock %} 