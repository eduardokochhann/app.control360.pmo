{% extends 'base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<style>
  /* Variáveis de Cores e Estilos */
  :root {
    --sprint-primary: #0d6efd;
    --sprint-secondary: #6c757d;
    --sprint-success: #198754;
    --sprint-info: #0dcaf0;
    --sprint-warning: #ffc107;
    --sprint-danger: #dc3545;
    --sprint-light: #f8f9fa;
    --sprint-dark: #212529;
    --sprint-border: #dee2e6;
    --sprint-hover: #e9ecef;
    --sprint-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --sprint-shadow-lg: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    
    /* Cores de Criticidade */
    --criticality-normal-bg: #f8f9fa;
    --criticality-normal-border: #dee2e6;
    --criticality-alta-bg: #fff3cd;
    --criticality-alta-border: #ffc107;
    --criticality-critica-bg: #f8d7da;
    --criticality-critica-border: #dc3545;
  }

  /* Layout Geral */
  .sprint-board-container {
    display: flex;
    align-items: flex-start;
    gap: 1.5rem;
    height: calc(100vh - 180px);
    min-height: 400px;
    background-color: #ffffff;
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--sprint-border);
    box-shadow: var(--sprint-shadow);
    overflow: hidden; /* Previne scroll não intencional */
  }

  /* Sprint Board */
  .sprint-board {
    flex-grow: 1;
    display: flex;
    gap: 1.5rem;
    overflow-x: auto;
    padding: 0.5rem;
    align-items: flex-start;
    height: 100%;
    padding-bottom: 1rem; /* Espaço para evitar corte */
  }

  /* Sprint Cards */
  .sprint-card {
    flex: 0 0 400px !important;
    width: 400px !important;
    min-width: 400px !important;
    max-width: 400px !important;
    height: 680px !important; /* Reduzido ~10% de 760px */
    min-height: 680px !important;
    max-height: 680px !important;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    transition: all 0.2s ease;
    margin-bottom: 0.5rem;
  }

  /* Cabeçalho da Sprint */
  .sprint-card-header {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    border-radius: 0.5rem 0.5rem 0 0;
    min-height: 120px; /* Altura mínima fixa para o cabeçalho */
  }

  /* Cores de Criticidade */
  .sprint-card-header.criticality-normal {
    background-color: var(--criticality-normal-bg);
    border-bottom: 2px solid var(--criticality-normal-border);
  }

  .sprint-card-header.criticality-alta {
    background-color: var(--criticality-alta-bg);
    border-bottom: 2px solid var(--criticality-alta-border);
  }

  .sprint-card-header.criticality-critica {
    background-color: var(--criticality-critica-bg);
    border-bottom: 2px solid var(--criticality-critica-border);
  }

  /* Linha Superior do Cabeçalho */
  .sprint-header-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    gap: 1rem;
  }

  /* Área do Título e Informações */
  .sprint-title-area {
    flex: 1;
    min-width: 0; /* Importante para text-overflow funcionar */
  }

  .sprint-card-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--sprint-dark);
    margin: 0 0 0.5rem 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Badges e Metadados */
  .sprint-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .sprint-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: normal;
    border-radius: 0.25rem;
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--sprint-secondary);
  }

  .sprint-badge i {
    margin-right: 0.25rem;
  }

  /* Área de Ações */
  .sprint-card-actions {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .sprint-card-actions button {
    padding: 0.25rem 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
  }

  /* Linha Inferior do Cabeçalho */
  .sprint-header-bottom {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .sprint-dates {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .sprint-goal {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0;
  }

  /* Corpo da Sprint */
  .sprint-card-body {
    padding: 1rem;
    overflow-y: auto;
    flex-grow: 1;
    background-color: #ffffff;
    height: calc(100% - 120px);
  }

  .sprint-tasks {
    min-height: 50px;
    padding: 0.5rem;
    background-color: var(--sprint-light);
    border-radius: 0.375rem;
  }

  /* Task Cards */
  .backlog-task-card {
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    background: white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .backlog-task-card:last-child {
    margin-bottom: 0;
  }

  .backlog-task-card:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transform: translateY(-1px);
  }

  /* Task Title */
  .task-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
    font-size: 14px;
    line-height: 1.3;
  }

  /* Task Project Info */
  .task-project-info {
    background: #f8f9fa;
    padding: 4px 8px;
    border-radius: 4px;
    border-left: 3px solid #6c757d;
  }

  /* Task Meta */
  .task-meta {
    margin-bottom: 8px;
  }

  .task-priority-badge {
    font-size: 11px;
    font-weight: 500;
  }

  /* Task Specialist */
  .task-specialist {
    font-weight: 500;
  }

  /* Generic Tasks */
  .generic-task {
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
    background: white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .generic-task:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    transform: translateY(-1px);
  }

  .generic-task-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: #333;
    font-size: 14px;
    line-height: 1.3;
  }

  .generic-task-meta {
    margin-bottom: 8px;
  }

  .priority-badge {
    font-size: 11px;
    font-weight: 500;
  }

  /* Responsividade */
  @media (max-width: 1600px) {
    .sprint-card {
      flex: 0 0 350px !important;
      width: 350px !important;
      min-width: 350px !important;
      max-width: 350px !important;
      height: 650px !important; /* Reduzido ~10% de 720px */
      min-height: 650px !important;
      max-height: 650px !important;
    }

    #backlogColumn {
      flex: 0 0 350px;
      min-width: 350px;
      max-width: 350px;
    }
  }

  /* Colunas Laterais (Backlog e Tarefas Genéricas) */
  .side-column {
    flex: 0 0 350px;
    min-width: 350px;
    max-width: 350px;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }

  /* Coluna de Backlog específica */
  #backlogColumn {
    flex: 0 0 400px;
    min-width: 400px;
    max-width: 400px;
  }

  .side-column-header {
    padding: 1rem;
    background-color: #ffffff;
    border-bottom: 1px solid var(--sprint-border);
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .side-column-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .side-column-title h6 {
    margin: 0;
    font-weight: 600;
  }

  .search-container {
    position: relative;
  }

  .search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    padding-left: 2rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
  }

  .search-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--sprint-secondary);
  }

  .side-column-body {
    padding: 0.75rem;
    overflow-y: auto;
    flex-grow: 1;
  }

  /* Projetos no Backlog */
  .backlog-project {
    margin-bottom: 0.5rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    overflow: hidden;
  }

  .backlog-project-header {
    padding: 0.75rem;
    background-color: var(--sprint-light);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
  }

  .project-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
  }

  .project-id {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  .project-name {
    font-size: 0.875rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .project-tasks {
    display: none;
    padding: 0.75rem;
    background-color: #ffffff;
  }

  .project-tasks.show {
    display: block;
  }

  /* Tarefas Genéricas */
  .generic-task {
    padding: 0.75rem;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    margin-bottom: 0.5rem;
    cursor: pointer;
  }

  .generic-task:hover {
    background-color: var(--sprint-hover);
  }

  .generic-task-title {
    font-size: 0.875rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  .generic-task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
  }

  /* Task Project Info - NOVO */
  .task-project-info {
    font-size: 0.7rem !important;
    color: var(--sprint-secondary) !important;
    opacity: 0.8;
    padding: 0.2rem 0;
    border-left: 2px solid var(--sprint-border);
    padding-left: 0.5rem;
    margin-left: 0.2rem;
  }

  .task-project-info i {
    opacity: 0.6;
  }

  /* Badges */
  .project-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    background-color: var(--sprint-light);
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  /* Popover básico de especialistas */
  .specialist-hours-popover {
    cursor: pointer;
    border: none;
    background: none;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
  }

  .specialist-hours-popover:hover {
    background-color: rgba(0, 0, 0, 0.05);
    border-radius: 0.25rem;
  }

  /* CSS básico para popovers limpos */
  .popover {
    max-width: 250px;
    font-size: 0.875rem;
  }

  .popover-body {
    padding: 0.5rem;
  }
  
  /* Estados de Sortable para melhor feedback visual */
  .sortable-dragging {
    opacity: 0.6;
    transform: rotate(2deg);
    z-index: 9999;
  }

  .sortable-ghost-task {
    opacity: 0.3;
    background-color: #e9ecef !important;
  }

  .sortable-chosen-task {
    cursor: grabbing !important;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
  <div class="card shadow mb-4">
    <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
      {# <<< INÍCIO: Agrupamento Título + Botão Collapse >>> #}
      <div class="d-flex align-items-center">
        <button class="btn btn-sm btn-outline-secondary me-2" id="toggleBacklogBtn" title="Recolher Backlog">
            <i class="bi bi-chevron-double-left"></i>
        </button>
        <h6 class="m-0 font-weight-bold text-primary"><i class="bi bi-calendar3-week me-2"></i>{{ title }}</h6>
      </div>
      {# <<< FIM: Agrupamento Título + Botão Collapse >>> #}
      <div>
        <a href="{{ url_for('sprints.consolidated_report_page') }}" class="btn btn-sm btn-outline-primary me-2">
            <i class="bi bi-file-earmark-text me-1"></i>Relatório Consolidado
        </a>
        <button class="btn btn-sm btn-primary" id="addSprintBtn" data-bs-toggle="modal" data-bs-target="#sprintModal">
            <i class="bi bi-plus-lg me-1"></i>Nova Sprint
        </button>
      </div>
    </div>
    <div class="card-body">
      {# Área do Quadro de Sprints #}
      <div class="sprint-board-container" id="sprintBoardContainer"> {# Novo container geral #}
          {# Coluna do Backlog #}
          <div class="side-column" id="backlogColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Backlog</h6>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar projeto..." id="backlogSearch">
                  </div>
              </div>
              <div class="side-column-body" id="backlogList">
                  {# Conteúdo do backlog será carregado via JavaScript #}
              </div>
          </div>

          {# Nova Coluna de Tarefas Genéricas #}
          <div class="side-column" id="genericTasksColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Tarefas Genéricas</h6>
                      <button class="btn btn-sm btn-outline-primary" id="addGenericTaskBtn">
                          <i class="bi bi-plus"></i>
                      </button>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar tarefa..." id="genericTaskSearch">
                  </div>
              </div>
              <div class="side-column-body" id="genericTasksList">
                  {# Conteúdo das tarefas genéricas será carregado via JavaScript #}
              </div>
          </div>

          {# Área Rolável para Sprints #}
          <div id="sprintBoard" class="sprint-board">
          <div class="text-center text-muted p-5">Carregando sprints...</div>
          </div>
      </div>
    </div>
  </div>
</div>

{# Modal Adicionar/Editar Sprint #}
<div class="modal fade" id="sprintModal" tabindex="-1" aria-labelledby="sprintModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="sprintForm">
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title" id="sprintModalLabel">Nova Sprint</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="sprintId" name="sprintId">
          
          <div class="mb-3">
            <label for="sprintName" class="form-label">Nome <span class="text-danger">*</span></label>
            <input type="text" class="form-control form-control-sm" id="sprintName" name="name" required placeholder="Ex: Sprint 24.01">
          </div>
          
          <div class="row mb-3">
              <div class="col-md-6">
                  <label for="sprintStartDate" class="form-label">Data Início <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintStartDate" name="start_date" required>
              </div>
              <div class="col-md-6">
                  <label for="sprintEndDate" class="form-label">Data Fim <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintEndDate" name="end_date" required>
              </div>
          </div>

          <div class="mb-3">
            <label for="sprintGoal" class="form-label">Objetivo</label>
            <textarea class="form-control form-control-sm" id="sprintGoal" name="goal" rows="3" placeholder="Descreva o objetivo principal desta Sprint..."></textarea>
          </div>
          <div class="mb-3">
            <label for="sprintCriticality" class="form-label">Criticidade</label>
            <select class="form-select form-select-sm" id="sprintCriticality" name="criticality">
                <option value="Normal" selected>Normal</option>
                <option value="Alta">Alta</option>
                <option value="Crítica">Crítica</option>
            </select>
          </div>
          {# Campo oculto para o método HTTP (usado para PUT em edição) #}
          <input type="hidden" id="formMethod" name="_method" value="POST">
        </div>
        <div class="modal-footer">
          {# Botão Excluir aparece apenas na edição #}
          <button type="button" class="btn btn-danger me-auto" id="modalDeleteBtn" style="display: none;">Excluir Sprint</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-primary" onclick="console.log('[Inline Click] Botão Salvar clicado!')">Salvar Sprint</button>
        </div>
        {# Loading Feedback #}
        <div class="loading-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); z-index: 1056; display: flex; justify-content: center; align-items: center; border-radius: inherit;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </form>
    </div>
  </div>
</div>

{# Modal para Adicionar/Editar Tarefa Genérica #}
<div class="modal fade" id="genericTaskModal" tabindex="-1" aria-labelledby="genericTaskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="genericTaskForm">
                <div class="modal-header">
                    <h5 class="modal-title" id="genericTaskModalLabel">Nova Tarefa Genérica</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="genericTaskId" name="taskId">
                    
                    <div class="mb-3">
                        <label for="genericTaskTitle" class="form-label">Título <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="genericTaskTitle" name="title" required>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskDescription" class="form-label">Descrição</label>
                        <textarea class="form-control" id="genericTaskDescription" name="description" rows="3"></textarea>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskPriority" class="form-label">Prioridade</label>
                            <select class="form-select" id="genericTaskPriority" name="priority">
                                <option value="Baixa">Baixa</option>
                                <option value="Média" selected>Média</option>
                                <option value="Alta">Alta</option>
                                <option value="Urgente">Urgente</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskEffort" class="form-label">Esforço (horas)</label>
                            <input type="number" class="form-control" id="genericTaskEffort" name="estimated_effort" step="0.5" min="0">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskSpecialist" class="form-label">Especialista</label>
                        <input type="text" class="form-control" id="genericTaskSpecialist" name="specialist_name">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger me-auto" id="genericTaskDeleteBtn" style="display: none;">Excluir</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="submit" class="btn btn-primary">Salvar</button>
                </div>
            </form>
        </div>
    </div>
</div>

{# Modal para Visualizar/Editar Tarefa #}
<div class="modal fade" id="taskDetailsModal" tabindex="-1" aria-labelledby="taskDetailsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="taskDetailsModalLabel">Detalhes da Tarefa</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="taskDetailsForm">
          <input type="hidden" id="taskId" name="taskId">
          <input type="hidden" id="taskType" name="taskType">
          
          <div class="row mb-3">
            <div class="col-md-8">
              <label for="taskTitle" class="form-label">Título <span class="text-danger">*</span></label>
              <input type="text" class="form-control" id="taskTitle" name="title" required>
            </div>
            <div class="col-md-4">
              <label for="taskPriority" class="form-label">Prioridade</label>
              <select class="form-select" id="taskPriority" name="priority">
                <option value="Baixa">Baixa</option>
                <option value="Média" selected>Média</option>
                <option value="Alta">Alta</option>
                <option value="Urgente">Urgente</option>
              </select>
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="taskSpecialist" class="form-label">Especialista</label>
              <input type="text" class="form-control" id="taskSpecialist" name="specialist_name">
            </div>
            <div class="col-md-3">
              <label for="taskEstimatedHours" class="form-label">Horas Estimadas</label>
              <input type="number" class="form-control" id="taskEstimatedHours" name="estimated_hours" step="0.5" min="0">
            </div>
            <div class="col-md-3">
              <label for="taskStatus" class="form-label">Status</label>
              <select class="form-select" id="taskStatus" name="status">
                <option value="pendente">Pendente</option>
                <option value="em_andamento">Em Andamento</option>
                <option value="concluido">Concluído</option>
                <option value="bloqueado">Bloqueado</option>
              </select>
            </div>
          </div>

          <div class="mb-3">
            <label for="taskDescription" class="form-label">Descrição</label>
            <textarea class="form-control" id="taskDescription" name="description" rows="4"></textarea>
          </div>

          <div id="backlogSpecificFields" class="d-none">
            <div class="row mb-3">
              <div class="col-md-6">
                <label for="taskProjectId" class="form-label">ID do Projeto</label>
                <input type="text" class="form-control" id="taskProjectId" name="project_id" readonly>
              </div>
              <div class="col-md-6">
                <label for="taskColumnIdentifier" class="form-label">Coluna</label>
                <input type="text" class="form-control" id="taskColumnIdentifier" name="column_identifier" readonly>
              </div>
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger me-auto" id="taskDeleteBtn">Excluir Tarefa</button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        <button type="submit" form="taskDetailsForm" class="btn btn-primary">Salvar Alterações</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    console.log("[Sprint Mgmt] DOMContentLoaded iniciado.");
    const backlogColumnBody = document.querySelector('#backlogColumn .side-column-body'); // Corpo da coluna de backlog
    const sprintBoard = document.getElementById('sprintBoard'); // Seleciona o contêiner do quadro
    const sprintModalElement = document.getElementById('sprintModal');
    const sprintModal = new bootstrap.Modal(sprintModalElement);
    const sprintForm = document.getElementById('sprintForm');
    console.log("[Sprint Mgmt] Elemento sprintForm encontrado:", sprintForm); // Log de verificação
    const sprintModalLabel = document.getElementById('sprintModalLabel');
    let editingSprintId = null; // Para controle de edição futura
    const formMethodInput = document.getElementById('formMethod'); // Input oculto para método
    const modalDeleteBtn = document.getElementById('modalDeleteBtn'); // Botão excluir no modal
    const apiSprintsBaseUrl = '/sprints/api/sprints'; // API Sprints
    const apiBacklogTasksUrl = '/backlog/api/backlogs/unassigned-tasks'; // API Backlog Tasks

    // Função para mostrar feedback de loading no modal
    function showModalLoading(isLoading) {
        const overlay = sprintForm.querySelector('.loading-overlay');
        const submitButton = sprintForm.querySelector('button[type="submit"]');
        const cancelButton = sprintForm.querySelector('button[data-bs-dismiss="modal"]');
        if (overlay) overlay.style.display = isLoading ? 'flex' : 'none';
        if (modalDeleteBtn) modalDeleteBtn.disabled = isLoading;
        if (submitButton) submitButton.disabled = isLoading;
        if (cancelButton) cancelButton.disabled = isLoading;
    }

    // Função para formatar data (DD/MM/YYYY)
    function formatDate(isoDateString) {
        if (!isoDateString) return '-';
        try {
            // Tenta criar a data. Adiciona 'T00:00:00' se for apenas YYYY-MM-DD
            const dateStr = isoDateString.includes('T') ? isoDateString : isoDateString + 'T00:00:00';
            const date = new Date(dateStr);
            // Verifica se a data é válida
            if (isNaN(date.getTime())) {
                console.warn("Data inválida recebida:", isoDateString);
                return 'Data Inválida';
            }
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Mês é 0-indexed
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        } catch (e) {
            console.error("Erro ao formatar data:", isoDateString, e);
            return 'Erro Data';
        }
    }

    // Função para carregar e renderizar sprints
    async function loadSprints() {
        console.log("[Sprint Mgmt] loadSprints() chamado.");
        sprintBoard.innerHTML = '<div class="text-center text-muted p-5"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Carregando...</span></div> Carregando sprints...</div>';
        try {
            console.log(`[Sprint Mgmt] Tentando fetch sprints: ${apiSprintsBaseUrl}`);
            const response = await fetch(apiSprintsBaseUrl);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar sprints`);
            }
            const sprintsApiResponse = await response.json();

            sprintBoard.innerHTML = ''; // Limpa o quadro
            if (!sprintsApiResponse || sprintsApiResponse.length === 0) {
                sprintBoard.innerHTML = '<div class="text-center text-muted p-5">Nenhuma sprint encontrada. Crie uma nova!</div>';
            } else {
                for (const sprint of sprintsApiResponse) {
                    // INÍCIO DA NOVA VERIFICAÇÃO DE ERRO
                    if (sprint.error) {
                        console.warn(`[Sprint Mgmt] Sprint ID ${sprint.id || 'N/A'} retornou com erro da API: ${sprint.error}`);
                        const errorCard = document.createElement('div');
                        // Adicionar classes para estilizar o card de erro, se desejado
                        errorCard.className = 'sprint-card'; 
                        errorCard.style.border = '2px solid red';
                        errorCard.innerHTML = `
                            <div class="sprint-card-header" style="background-color: #f8d7da; color: #721c24;">
                                <h6 class="sprint-card-title">Erro ao carregar Sprint ${sprint.id || '(ID Desconhecido)'}</h6>
                            </div>
                            <div class="sprint-card-body">
                                <p><strong>Detalhe do erro:</strong> ${escapeHtml(sprint.error)}</p>
                                <p class="text-muted small">Verifique os logs do servidor para mais informações.</p>
                            </div>
                        `;
                        sprintBoard.appendChild(errorCard);
                        continue; // Pula para a próxima sprint
                    }
                    // FIM DA NOVA VERIFICAÇÃO DE ERRO

                    const sprintCard = document.createElement('div');
                    sprintCard.className = 'sprint-card';
                    sprintCard.dataset.sprintId = sprint.id;

                    // <<< INÍCIO: Calcular Total de Horas Estimadas da Sprint >>>
                    let totalSprintHours = 0;
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        totalSprintHours = sprint.tasks.reduce((sum, task) => {
                            const hours = parseFloat(task.estimated_effort);
                            return sum + (isNaN(hours) ? 0 : hours);
                        }, 0);
                    }
                    // <<< FIM: Calcular Total de Horas Estimadas da Sprint >>>

                    // <<< INÍCIO: Calcular Horas por Especialista >>>
                    let hoursBySpecialist = {};
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        hoursBySpecialist = sprint.tasks.reduce((acc, task) => {
                            const specialist = task.specialist_name || 'Não Atribuído';
                            const hours = parseFloat(task.estimated_effort);
                            if (!isNaN(hours)) {
                                acc[specialist] = (acc[specialist] || 0) + hours;
                            }
                            return acc;
                        }, {});
                    }
                    
                    // <<< INÍCIO: Buscar Capacidade Dinâmica da API >>>
                    function calcularSemanasDoSprint(startDate, endDate) {
                        if (!startDate || !endDate) return 1; // Default para 1 semana se não tiver datas
                        
                        const start = new Date(startDate);
                        const end = new Date(endDate);
                        const diffTime = Math.abs(end - start);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        const weeks = Math.ceil(diffDays / 7); // Arredonda para cima
                        
                        return Math.max(weeks, 1); // Mínimo de 1 semana
                    }
                    
                    async function buscarCapacidadeDinamica(sprintId) {
                        try {
                            const response = await fetch(`/backlog/api/sprints/${sprintId}/capacity`);
                            if (response.ok) {
                                return await response.json();
                            }
                            return null;
                        } catch (error) {
                            console.error('Erro ao buscar capacidade dinâmica:', error);
                            return null;
                        }
                    }
                    
                    // Busca dados de capacidade da API
                    const capacidadeDinamica = await buscarCapacidadeDinamica(sprint.id);
                    const semanasSprint = capacidadeDinamica ? capacidadeDinamica.duration_weeks : calcularSemanasDoSprint(sprint.start_date, sprint.end_date);
                    const capacidadeSemanalPorEspecialista = 40; // 40h por semana
                    const capacidadeTotalPorEspecialista = capacidadeDinamica ? capacidadeDinamica.capacidade_total_por_especialista : (capacidadeSemanalPorEspecialista * semanasSprint);
                    // <<< FIM: Buscar Capacidade Dinâmica da API >>>
                    
                    // Formata o conteúdo do popover com informações básicas
                    let popoverContent = '';
                    Object.entries(hoursBySpecialist).forEach(([specialist, hours]) => {
                        if (specialist !== 'Não Atribuído') {
                            const capacidadeTotal = capacidadeTotalPorEspecialista;
                            const horasRestantes = capacidadeTotal - hours;
                            const percentualUtilizado = Math.round((hours / capacidadeTotal) * 100);
                            
                            // Se temos dados da API, usa informações mais precisas
                            let statusInfo = '';
                            if (capacidadeDinamica && capacidadeDinamica.specialist_details && capacidadeDinamica.specialist_details[specialist]) {
                                const apiData = capacidadeDinamica.specialist_details[specialist];
                                statusInfo = ` | Status: ${apiData.status}`;
                            }
                            
                            // Define cor do badge baseado na utilização
                            let badgeClass = 'success';
                            if (percentualUtilizado > 100) {
                                badgeClass = 'danger';
                            } else if (percentualUtilizado > 80) {
                                badgeClass = 'warning';
                            }
                            
                            popoverContent += `
                                <div class="mb-2">
                                    <strong>${escapeHtml(specialist)}</strong><br>
                                    <small>
                                        ${hours.toFixed(1)}h utilizadas / ${capacidadeTotal}h disponíveis (${semanasSprint} sem.)${statusInfo}<br>
                                        Saldo: ${horasRestantes.toFixed(1)}h 
                                        <span class="badge bg-${badgeClass} ms-1">${percentualUtilizado}%</span>
                                    </small>
                                </div>
                            `;
                        }
                    });
                    
                    if (!popoverContent) {
                        popoverContent = '<small class="text-muted">Nenhum especialista alocado</small>';
                    }
                    
                    // Escape do conteúdo do popover para uso seguro no atributo HTML
                    const escapedPopoverContent = popoverContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                    // <<< FIM: Calcular Horas por Especialista >>>

                    sprintCard.innerHTML = `
                        <div class="sprint-card-header criticality-${(sprint.criticality || 'normal').toLowerCase()}">
                            <div class="sprint-header-top">
                                <div class="sprint-title-area">
                                    <h6 class="sprint-card-title">${escapeHtml(sprint.name)}</h6>
                                    <div class="sprint-meta">
                                        <span class="sprint-badge">
                                            <i class="bi bi-stopwatch"></i>${totalSprintHours.toFixed(1)}h
                                        </span>
                                        ${Object.keys(hoursBySpecialist).length > 0 ? `
                                        <button type="button" class="sprint-badge specialist-hours-popover" 
                                                data-bs-toggle="popover" 
                                                data-bs-placement="bottom"
                                                data-bs-trigger="hover focus"
                                                data-bs-html="true" 
                                                title="Especialistas"
                                                data-popover-content-id="popover-content-${sprint.id}">
                                            <i class="bi bi-people"></i>Especialistas
                                        </button>
                                        <div id="popover-content-${sprint.id}" style="display: none;">${popoverContent}</div>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="sprint-card-actions">
                                    <button class="btn btn-sm btn-outline-secondary edit-btn" data-id="${sprint.id}" title="Editar Sprint">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-primary test-update-btn" data-id="${sprint.id}" title="Teste: Atualizar Contadores" style="display: none;">
                                        <i class="bi bi-arrow-clockwise"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${sprint.id}" data-name="${escapeHtml(sprint.name)}" title="Excluir Sprint">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sprint-header-bottom">
                                <div class="sprint-dates">
                                    <i class="bi bi-calendar-range"></i>
                                    ${formatDate(sprint.start_date)} - ${formatDate(sprint.end_date)}
                                </div>
                                <div class="sprint-goal">
                                    ${escapeHtml(sprint.goal || 'Sem objetivo definido.')}
                                </div>
                            </div>
                        </div>
                        <div class="sprint-card-body">
                            <div class="sprint-tasks" data-sprint-id="${sprint.id}">
                                ${sprint.tasks && sprint.tasks.length > 0 ? 
                                    sprint.tasks.map(task => {
                                        const projectPart = task.project_id || 'PROJ';
                                        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase(); 
                                        const isCompleted = task.column_identifier === 'concluido';
                                        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;
                                        return `
                                        <div class="backlog-task-card sprint-task-card ${isCompleted ? 'task-completed' : ''}" data-task-id="${task.id}" draggable="true" data-estimated-hours="${task.estimated_effort || 0}" data-specialist-name="${escapeHtml(task.specialist_name || '')}" data-is-generic="${task.is_generic || false}">
                                            <div class="task-title">${escapeHtml(task.title)}</div>
                                            
                                            ${task.project_id && !task.is_generic ? `<div class="task-project-info small text-muted mb-2">
                                                <i class="bi bi-folder2 me-1"></i><strong>${task.project_id}</strong>${task.project_name ? ` - ${escapeHtml(task.project_name.length > 25 ? task.project_name.substring(0, 25) + '...' : task.project_name)}` : ''}
                                            </div>` : ''}
                                            
                                            <div class="task-meta d-flex justify-content-between align-items-center mb-2">
                                                <div class="task-meta-left">
                                                    <span class="badge rounded-pill task-priority-badge">${escapeHtml(task.priority || 'Média')}</span>
                                                </div>
                                                <div class="task-meta-right d-flex align-items-center gap-2">
                                                    ${task.estimated_effort ? `<span class="text-muted small"><i class="bi bi-clock me-1"></i>${task.estimated_effort}h</span>` : ''}
                                                </div>
                                            </div>
                                            
                                            ${task.specialist_name ? `<div class="task-specialist small text-primary">
                                                <i class="bi bi-person-fill me-1"></i>${escapeHtml(task.specialist_name)}
                                            </div>` : '<div class="task-specialist small text-muted"><i class="bi bi-person me-1"></i>Não atribuído</div>'}
                                            
                                            <div class="task-actions">
                                                
                                            </div>
                                        </div>`;
                                    }).join('') 
                                    : '<small class="text-muted fst-italic ps-2">Nenhuma tarefa alocada.</small>' 
                                } 
                            </div>
                        </div>
                    `;
                    sprintBoard.appendChild(sprintCard);

                    // Aplica classe de cor ao badge de prioridade APÓS adicionar ao DOM
                    sprint.tasks.forEach(task => {
                        const cardElement = sprintBoard.querySelector(`.sprint-task-card[data-task-id="${task.id}"]`);
                        if (cardElement) {
                            const badgeElement = cardElement.querySelector('.task-priority-badge');
                            if (badgeElement) {
                                const priorityLower = (task.priority || '').toLowerCase();
                                let badgeClass = 'text-bg-primary'; // Default: Média
                                if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                                else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                                else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                                badgeElement.classList.add(...badgeClass.split(' '));
                            }
                        }
                    });
                }
                initializeSortable(); // Inicializa Sortable DEPOIS de renderizar sprints
                initializePopovers(); // <<< INICIALIZA Popovers DEPOIS de renderizar sprints >>>
            }
        } catch (error) {
            console.error("Erro ao carregar sprints:", error);
            sprintBoard.innerHTML = `<div class="alert alert-danger">Erro ao carregar sprints: ${error.message}</div>`;
        }
    }

    // Função para renderizar uma tarefa do backlog
    function renderBacklogTask(task) {
        const projectPart = task.project_id || 'PROJ';
        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase();
        const isCompleted = task.column_identifier === 'concluido';
        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;

        return `
            <div class="backlog-task-card ${isCompleted ? 'task-completed' : ''}" 
                 data-task-id="${task.id}" 
                 draggable="true" 
                 data-estimated-hours="${task.estimated_effort || 0}" 
                 data-specialist-name="${escapeHtml(task.specialist_name || '')}">
                <div class="task-title">${escapeHtml(task.title)}</div>
                <div class="task-meta">
                    <div class="task-meta-left">
                        <span class="badge rounded-pill task-priority-badge ${getPriorityClass(task.priority)}">${escapeHtml(task.priority || 'Média')}</span>
                    </div>
                    <div class="task-meta-right text-muted task-hours">
                        <span title="Estimado"><i class="bi bi-clock-history me-1"></i>${task.estimated_effort != null ? task.estimated_effort.toFixed(1) : '-'}h</span>
                        <code class="task-full-id">${fullTaskId}</code>
                    </div>
                </div>
            </div>
        `;
    }

    // Função auxiliar para obter a classe CSS baseada na prioridade
    function getPriorityClass(priority) {
        const priorityLower = (priority || '').toLowerCase();
        switch (priorityLower) {
            case 'urgente': return 'text-bg-danger';
            case 'alta': return 'text-bg-warning';
            case 'baixa': return 'text-bg-secondary';
            default: return 'text-bg-primary'; // Média ou outro
        }
    }

    // Função para renderizar um projeto do backlog
    function renderBacklogProject(backlog) {
        const projectBoardUrl = `/backlog/board/${backlog.project_id}`; // URL de destino para o quadro do projeto
        
        // NOVO: Limita o nome do projeto para evitar quebras de linha
        let displayName = backlog.project_name || 'Sem Nome';
        
        // Estratégia inteligente de truncamento:
        // 1. Sempre mantém o número do projeto se estiver no início
        // 2. Limita por palavras (primeiras 2-3 palavras após o número)
        // 3. Backup: limita por caracteres se ainda for muito longo
        
        const palavras = displayName.split(' ');
        
        // Se começar com número (ID do projeto), mantém ele + próximas 2 palavras
        if (palavras.length > 1 && /^\d+$/.test(palavras[0])) {
            // Exemplo: "11362 PLANALTO SOLUÇÕES IMOBILIÁRIAS" -> "11362 PLANALTO SOLUÇÕES"
            if (palavras.length > 3) {
                displayName = palavras.slice(0, 3).join(' ');
            }
        } else {
            // Se não começar com número, limita a 2-3 palavras
            if (palavras.length > 2) {
                displayName = palavras.slice(0, 2).join(' ');
            }
        }
        
        // Backup: Se ainda for muito longo, corta por caracteres
        if (displayName.length > 30) {
            displayName = displayName.substring(0, 27) + '...';
        }

        return `
            <div class="backlog-project" data-project-id="${backlog.project_id}">
                <div class="backlog-project-header">
                    <div class="project-info">
                        <a href="${projectBoardUrl}" class="project-link-to-board" title="Abrir quadro do projeto ${escapeHtml(backlog.project_name || 'Projeto sem nome')}" style="text-decoration: none; color: inherit;">
                            <span class="project-id">${backlog.project_id}</span>
                            <span class="project-name">${escapeHtml(displayName)}</span>
                        </a>
                    </div>
                    <i class="bi bi-chevron-down" onclick="toggleProjectTasks(this.closest('.backlog-project-header'))" style="cursor: pointer;"></i>
                </div>
                <div class="project-tasks">
                    ${backlog.tasks && backlog.tasks.length > 0 
                        ? backlog.tasks.map(task => renderBacklogTask(task)).join('')
                        : '<div class="text-muted small p-2">Nenhuma tarefa disponível.</div>'
                    }
                </div>
            </div>
        `;
    }

    // Função para carregar e renderizar tarefas do backlog não alocadas
    async function loadBacklogTasks() {
        const backlogList = document.getElementById('backlogList');
        backlogList.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm"></div> Carregando...</div>';

        try {
            const response = await fetch('/backlog/api/backlogs/unassigned-tasks');
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            const backlogs = await response.json();
            
            if (!backlogs || backlogs.length === 0) {
                backlogList.innerHTML = '<div class="text-center text-muted p-3">Nenhum projeto encontrado.</div>';
                return;
            }

            backlogList.innerHTML = backlogs.map(backlog => renderBacklogProject(backlog)).join('');

            // Inicializa Sortable para as novas tarefas
            initializeSortable();

        } catch (error) {
            console.error("Erro ao carregar backlogs:", error);
            backlogList.innerHTML = `<div class="alert alert-danger m-3">Erro ao carregar: ${error.message}</div>`;
        }
    }

    // Função para busca nos backlogs
    function setupSearch(inputId, itemsContainer, itemSelector) {
        const searchInput = document.getElementById(inputId);
        if (!searchInput) return;

        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const items = itemsContainer.querySelectorAll(itemSelector);

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        });
    }

    // Inicializa as buscas
    setupSearch('backlogSearch', document.getElementById('backlogList'), '.backlog-project');
    setupSearch('genericTaskSearch', document.getElementById('genericTasksList'), '.generic-task');

    // Função para alternar visibilidade das tarefas do projeto
    window.toggleProjectTasks = function(header) {
        const tasksDiv = header.nextElementSibling;
        const chevron = header.querySelector('.bi');
        
        if (tasksDiv.classList.contains('show')) {
            tasksDiv.classList.remove('show');
            chevron.classList.replace('bi-chevron-up', 'bi-chevron-down');
        } else {
            tasksDiv.classList.add('show');
            chevron.classList.replace('bi-chevron-down', 'bi-chevron-up');
        }
    };

    // --- Funções de Drag and Drop (SortableJS) ---
    let sortableInstances = []; // Guarda instâncias para possível destruição/recriação

    // <<< INÍCIO: Armazena instâncias de Popover para atualização >>>
    let popoverInstances = {}; // Guarda instâncias por ID do botão (ex: popover-sprint-123)
    // <<< FIM: Armazena instâncias de Popover >>>

    function initializeSortable() {
        // Destroi instâncias antigas se existirem (útil se recarregar dinamicamente)
        sortableInstances.forEach(instance => {
            try {
                instance.destroy();
            } catch (e) {
                console.warn("Erro ao destruir instância sortable:", e);
            }
        });
        sortableInstances = [];

        console.log("[Sprint Mgmt] Inicializando SortableJS...");

        // Seleciona TODAS as listas de tarefas (backlog, sprints e tarefas genéricas)
        const taskLists = document.querySelectorAll('.project-tasks, #genericTasksList, .sprint-tasks');
        
        taskLists.forEach(list => {
            const instance = new Sortable(list, {
                group: 'shared-tasks', // Nome do grupo para permitir mover entre listas
                animation: 150,
                ghostClass: 'sortable-ghost-task', // Classe CSS para o fantasma
                chosenClass: 'sortable-chosen-task', // Classe CSS para o item escolhido
                draggable: '.backlog-task-card, .generic-task', // Itens arrastáveis
                forceFallback: true, // Força o uso do fallback para evitar conflitos
                fallbackTolerance: 5, // Tolerância para iniciar o drag
                delay: 100, // Atraso antes de iniciar o drag para evitar conflitos com cliques
                delayOnTouchStart: 100, // Atraso no touch
                touchStartThreshold: 10, // Threshold para touch
                
                onStart: function (evt) {
                    console.log("[Sortable] Iniciando drag da tarefa:", evt.item.dataset.taskId);
                    // Desabilita eventos de clique temporariamente para evitar conflitos
                    evt.item.style.pointerEvents = 'none';
                    evt.item.style.userSelect = 'none';
                    // Adiciona classe visual durante o drag
                    evt.item.classList.add('sortable-dragging');
                },
                
                onEnd: function (evt) {
                    const item = evt.item; // O elemento da tarefa movida
                    const taskId = item.dataset.taskId;
                    const fromList = evt.from; // Lista de origem
                    const toList = evt.to;     // Lista de destino
                    const newIndex = evt.newIndex; // Nova posição na lista de destino

                    console.log(`[Sortable] Drag finalizado - Tarefa ${taskId} de ${fromList.className} para ${toList.className}`);
                    
                    // Reabilita eventos de clique após um pequeno delay e limpa classes
                    setTimeout(() => {
                        item.style.pointerEvents = '';
                        item.style.userSelect = '';
                        item.classList.remove('sortable-dragging');
                        
                        // Força reflow para garantir que as mudanças sejam aplicadas
                        item.offsetHeight;
                    }, 150);

                    // Se não houve mudança real, não faz nada
                    if (fromList === toList && evt.oldIndex === evt.newIndex) {
                        console.log("[Sortable] Sem mudança real, ignorando.");
                        return;
                    }

                    // Atualiza horas estimadas na UI
                    const taskHours = parseFloat(item.dataset.estimatedHours) || 0;
                    const taskSpecialist = item.dataset.specialistName || 'Não Atribuído';

                    // Identifica o destino (para a API)
                    let targetSprintId = null;
                    if (toList.classList.contains('sprint-tasks')) {
                        targetSprintId = toList.dataset.sprintId;
                    }

                    // Processa a movimentação
                    if (targetSprintId) {
                        // Movendo PARA uma sprint
                        console.log(`[Sortable] Movendo tarefa ${taskId} para sprint ${targetSprintId}`);
                        updateTaskSprintAssignmentOptimized(taskId, targetSprintId, newIndex, item, fromList, toList, taskHours);
                    } else {
                        // Movendo PARA FORA de uma sprint (para Backlog ou Tarefas Genéricas)
                        console.log(`[Sortable] Movendo tarefa ${taskId} para fora da sprint`);
                        moveTaskToBacklogOptimized(taskId, item, fromList, toList, taskHours);
                    }
                }
            });
            sortableInstances.push(instance);
        });
    }

    // Versão otimizada da função de atualização que não recarrega tudo
    async function updateTaskSprintAssignmentOptimized(taskId, sprintId, newPosition, taskElement, fromList, toList, taskHours) {
        const apiUrl = `/backlog/api/tasks/${taskId}/assign`;
        const payload = {
            sprint_id: sprintId,
            position: newPosition 
        };

        console.log(`[API Call] Chamando ${apiUrl} com payload:`, payload);

        try {
            const response = await fetch(apiUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { 
                    const errorData = await response.json();
                    errorMsg = errorData.message || errorData.description || errorMsg; 
                } catch(e) {}
                throw new Error(errorMsg);
            }

            const updatedTask = await response.json();
            console.log("[API Call] Tarefa atualizada com sucesso:", updatedTask);
            
            // Usa os novos métodos globais para atualização automática
            if (fromList && fromList.classList.contains('sprint-tasks')) {
                const fromSprintId = fromList.dataset.sprintId;
                window.updateSprintHourCounters(fromSprintId);
            }
            
            if (toList && toList.classList.contains('sprint-tasks')) {
                const toSprintId = toList.dataset.sprintId;
                window.updateSprintHourCounters(toSprintId);
            }

        } catch (error) {
            console.error("[API Call] Erro ao atualizar sprint da tarefa:", error);
            
            // Reverte a mudança visual em caso de erro
            console.log("[API Call] Revertendo mudança visual devido ao erro...");
            fromList.insertBefore(taskElement, fromList.children[newPosition] || null);
            
            alert(`Erro ao mover tarefa: ${error.message}`);
        }
    }

    // Versão otimizada para mover tarefa para backlog
    async function moveTaskToBacklogOptimized(taskId, taskElement, fromList, toList, taskHours) {
        try {
            const response = await fetch(`/sprints/api/sprints/tasks/${taskId}/move-to-backlog`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            const updatedTask = await response.json();
            console.log(`[API Call] Tarefa ${taskId} movida para backlog via API:`, updatedTask);
            
            // Usa os novos métodos globais para atualização automática
            if (fromList && fromList.classList.contains('sprint-tasks')) {
                const fromSprintId = fromList.dataset.sprintId;
                window.updateSprintHourCounters(fromSprintId);
            }
            
            // Remove o elemento da lista atual e recarrega apenas a lista de destino
            taskElement.remove();
            
        } catch (error) {
            console.error(`[API Call] Erro ao mover tarefa para backlog:`, error);
            
            // Reverte a mudança visual
            fromList.appendChild(taskElement);
            
            alert(`Erro ao mover tarefa: ${error.message}`);
        }
    }

    // Função otimizada para atualizar display de horas sem recarregar
    function updateSprintHoursDisplayOptimized(fromList, toList, taskHours) {
        // Atualiza sprint de origem
        if (fromList && fromList.classList.contains('sprint-tasks')) {
            updateSingleSprintHours(fromList, -taskHours);
        }
        
        // Atualiza sprint de destino
        if (toList && toList.classList.contains('sprint-tasks')) {
            updateSingleSprintHours(toList, taskHours);
        }
    }

    // Função para atualizar horas de uma única sprint
    function updateSingleSprintHours(sprintList, hoursDelta) {
        const sprintCard = sprintList.closest('.sprint-card');
        if (!sprintCard) return;
        
        const hoursSpan = sprintCard.querySelector('.sprint-badge i.bi-stopwatch').parentElement;
        if (!hoursSpan) return;

        try {
            const currentHoursText = hoursSpan.textContent.match(/([\d\.]+)/);
            let currentHours = currentHoursText ? parseFloat(currentHoursText[1]) : 0;
            if (isNaN(currentHours)) currentHours = 0;
            
            const newTotalHours = Math.max(0, currentHours + hoursDelta);
            hoursSpan.innerHTML = `<i class="bi bi-stopwatch"></i>${newTotalHours.toFixed(1)}h`;
        } catch (e) {
            console.error("Erro ao atualizar display de horas da sprint:", e);
        }
    }

    // Função otimizada para atualizar popovers
    function updateSpecialistPopoverOptimized(fromList, toList) {
        if (fromList && fromList.classList.contains('sprint-tasks')) {
            updateSingleSprintPopover(fromList);
        }
        
        if (toList && toList.classList.contains('sprint-tasks')) {
            updateSingleSprintPopover(toList);
        }
    }

    // Função para atualizar popover de uma única sprint
    function updateSingleSprintPopover(sprintList) {
        try {
            const sprintCard = sprintList.closest('.sprint-card');
            if (!sprintCard) return;

            // Recalcula horas por especialista
            const tasks = sprintList.querySelectorAll('.backlog-task-card');
            let hoursBySpecialist = {};

            tasks.forEach(task => {
                const specialist = task.dataset.specialistName;
                if (specialist && specialist.trim() && specialist !== 'Não Atribuído') {
                    const hours = parseFloat(task.dataset.estimatedHours) || 0;
                    hoursBySpecialist[specialist] = (hoursBySpecialist[specialist] || 0) + hours;
                }
            });

            // Atualiza o popover
            const popoverButton = sprintCard.querySelector('.specialist-hours-popover');
            if (!popoverButton) return;

            // Destrói popover existente
            const existingPopover = bootstrap.Popover.getInstance(popoverButton);
            if (existingPopover) {
                existingPopover.dispose();
            }

            if (Object.keys(hoursBySpecialist).length > 0) {
                // Gera novo conteúdo
                let popoverContent = '';
                Object.entries(hoursBySpecialist).forEach(([specialist, hours]) => {
                    const capacidadeTotal = 80; // Valor padrão, idealmente vir da API
                    const horasRestantes = capacidadeTotal - hours;
                    const percentualUtilizado = Math.round((hours / capacidadeTotal) * 100);
                    
                    let badgeClass = 'success';
                    if (percentualUtilizado > 100) {
                        badgeClass = 'danger';
                    } else if (percentualUtilizado > 80) {
                        badgeClass = 'warning';
                    }
                    
                    popoverContent += `
                        <div class="mb-2">
                            <strong>${escapeHtml(specialist)}</strong><br>
                            <small>
                                ${hours.toFixed(1)}h utilizadas / ${capacidadeTotal}h disponíveis<br>
                                Saldo: ${horasRestantes.toFixed(1)}h 
                                <span class="badge bg-${badgeClass} ms-1">${percentualUtilizado}%</span>
                            </small>
                        </div>
                    `;
                });

                // Cria novo popover
                const popoverInstance = new bootstrap.Popover(popoverButton, {
                    content: popoverContent,
                    html: true,
                    placement: 'bottom',
                    trigger: 'hover', // Apenas hover, remove focus para evitar problemas
                    title: 'Especialistas',
                    delay: { show: 300, hide: 100 }, // Adiciona delays para melhor UX
                    container: 'body' // Anexa ao body para evitar conflitos de z-index
                });

                // Adiciona listeners manuais para melhor controle
                let hideTimeout;
                
                popoverButton.addEventListener('mouseenter', () => {
                    if (hideTimeout) {
                        clearTimeout(hideTimeout);
                    }
                });
                
                popoverButton.addEventListener('mouseleave', () => {
                    hideTimeout = setTimeout(() => {
                        if (popoverInstance) {
                            popoverInstance.hide();
                        }
                    }, 200); // Delay de 200ms antes de esconder
                });
                
                popoverButton.style.display = 'inline-flex';
            } else {
                popoverButton.style.display = 'none';
            }
        } catch (e) {
            console.error("Erro ao atualizar popover:", e);
        }
    }

    // <<< INÍCIO: Função para inicializar todos os popovers >>>
    function initializePopovers() {
        console.log("[Sprint Mgmt] Inicializando Popovers...");
        const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
        popoverTriggerList.forEach(popoverTriggerEl => {
            // Gera um ID único para o botão se não existir (necessário para armazenar instância)
            if (!popoverTriggerEl.id) {
                popoverTriggerEl.id = `popover-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
            }
            
            // Para popovers de especialistas, usa o conteúdo do div oculto
            let popoverOptions = {
                html: true,
                placement: 'bottom',
                trigger: 'hover', // Apenas hover, remove focus para evitar problemas
                title: 'Especialistas',
                delay: { show: 300, hide: 100 }, // Adiciona delays para melhor UX
                container: 'body' // Anexa ao body para evitar conflitos de z-index
            };
            
            if (popoverTriggerEl.hasAttribute('data-popover-content-id')) {
                const contentId = popoverTriggerEl.getAttribute('data-popover-content-id');
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    popoverOptions.content = contentDiv.innerHTML;
                }
            }
            
            // Cria e armazena a instância
            const instance = new bootstrap.Popover(popoverTriggerEl, popoverOptions);
            popoverInstances[popoverTriggerEl.id] = instance;

            // Adiciona listeners manuais para melhor controle
            let hideTimeout;
            
            popoverTriggerEl.addEventListener('mouseenter', () => {
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                }
            });
            
            popoverTriggerEl.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    if (instance) {
                        instance.hide();
                    }
                }, 200); // Delay de 200ms antes de esconder
            });
        });
        console.log(`[Sprint Mgmt] ${Object.keys(popoverInstances).length} instâncias Popover inicializadas.`);
    }
    // <<< FIM: Função para inicializar todos os popovers >>>

    // *** TODO: Função para chamar a API ***
    // Função para chamar a API e atualizar a associação da sprint da tarefa
    async function updateTaskSprintAssignment(taskId, sprintId, newPosition) {
        const apiUrl = `/backlog/api/tasks/${taskId}/assign`;
        // Se sprintId for undefined (arrastado para a coluna de backlog), envia null
        const payload = {
             sprint_id: sprintId === undefined ? null : sprintId, 
             position: newPosition 
            };

        console.log(`[API Call] Chamando ${apiUrl} com payload:`, payload);

        try {
            const response = await fetch(apiUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { 
                    const errorData = await response.json();
                    errorMsg = errorData.message || errorData.description || errorMsg; 
                } catch(e) {}
                throw new Error(errorMsg);
            }

            const updatedTask = await response.json();
            console.log("[API Call] Tarefa atualizada com sucesso:", updatedTask);
            // Opcional: Atualizar visualmente o card da tarefa se a API retornar dados úteis
            // Por enquanto, a mudança visual já foi feita pelo SortableJS.

        } catch (error) {
            console.error("[API Call] Erro ao atualizar sprint da tarefa:", error);
            alert(`Erro ao mover tarefa: ${error.message}\nA interface pode estar dessincronizada. Recarregue a página.`);
            // TODO: Implementar lógica para reverter a mudança visual do SortableJS?
            // Isso é complexo, recarregar a página pode ser a solução mais simples.
            // window.location.reload(); 
        }
    }

    // Função para escapar HTML (segurança)
    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
           .replace(/&/g, "&amp;")
           .replace(/</g, "&lt;")
           .replace(/>/g, "&gt;")
           .replace(/"/g, "&quot;")
           .replace(/'/g, "&#039;");
    }

    // --- Funções de Ação (Editar/Excluir) ---

    // Prepara e abre o modal para edição
    async function openEditModal(sprintId) {
        console.log(`Abrindo modal para editar Sprint ID: ${sprintId}`);
        sprintForm.reset(); // Limpa o formulário
        editingSprintId = sprintId;
        formMethodInput.value = 'PUT'; // Define método como PUT
        sprintModalLabel.textContent = 'Editar Sprint';
        modalDeleteBtn.style.display = 'inline-block'; // Mostra botão excluir
        showModalLoading(true); // Mostra loading antes do fetch
        sprintModal.show();

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar dados da sprint ${sprintId}`);
            }
            const sprintData = await response.json();

            // Preenche o formulário
            document.getElementById('sprintId').value = sprintData.id;
            document.getElementById('sprintName').value = sprintData.name;
            // Formata data para YYYY-MM-DD para input date
            document.getElementById('sprintStartDate').value = sprintData.start_date ? sprintData.start_date.substring(0, 10) : '';
            document.getElementById('sprintEndDate').value = sprintData.end_date ? sprintData.end_date.substring(0, 10) : '';
            document.getElementById('sprintGoal').value = sprintData.goal || '';
            document.getElementById('sprintCriticality').value = sprintData.criticality || 'Normal';

        } catch (error) {
            console.error("Erro ao carregar dados para edição:", error);
            alert(`Erro ao carregar dados da sprint: ${error.message}`)
            sprintModal.hide(); // Esconde o modal se deu erro ao carregar
        } finally {
            showModalLoading(false);
        }
    }

    // Exclui uma sprint
    async function deleteSprint(sprintId, sprintName) {
        if (!confirm(`Tem certeza que deseja excluir a sprint "${sprintName}"?\nAs tarefas associadas serão desvinculadas.`)) {
            return;
        }
        console.log(`Tentando excluir Sprint ID: ${sprintId}`);
        // Poderíamos mostrar um loading na linha da tabela ou geral

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`, {
                method: 'DELETE'
            });

            if (!response.ok && response.status !== 200 && response.status !== 204) { // Aceita 200 ou 204
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            console.log(`Sprint ${sprintId} excluída com sucesso.`);
            // Opcional: Mostrar um toast/alert de sucesso
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("Erro ao excluir sprint:", error);
            alert(`Erro ao excluir sprint: ${error.message}`);
        }
    }

    // --- Fim Funções de Ação ---

    // Listener para submissão do formulário (Criar/Editar Sprint)
    sprintForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("[Submit Handler] Evento submit detectado."); // Log A
        showModalLoading(true);

        const formData = new FormData(sprintForm);
        console.log("[Submit Handler] FormData criado."); // Log B
        const data = {
            name: formData.get('name'),
            // Input type=date já retorna YYYY-MM-DD, que é compatível com fromisoformat no backend
            start_date: formData.get('start_date'), 
            end_date: formData.get('end_date'),   // O input type=date já retorna YYYY-MM-DD
            goal: formData.get('goal') || null,
            criticality: formData.get('criticality') || 'Normal'
        };

        // Validação simples das datas no frontend
        if (data.start_date && data.end_date && data.start_date > data.end_date) {
            alert('A data de início não pode ser posterior à data de fim.');
            showModalLoading(false);
            return;
        }

        console.log("[Submit Handler] Validação passou. Preparando fetch..."); // Log C
        // Define URL e Método baseado na edição ou criação
        const isEditing = !!editingSprintId;
        const url = isEditing ? `${apiSprintsBaseUrl}/${editingSprintId}` : apiSprintsBaseUrl;
        const method = isEditing ? 'PUT' : 'POST';
        console.log(`Enviando ${method} para ${url}`);

        try {
            console.log("[Submit Handler] Dentro do try, antes do fetch."); // Log D
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            console.log("[Submit Handler] Fetch concluído, resposta recebida.", response.status); // Log E

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            const savedSprint = await response.json();
            console.log(`Sprint ${isEditing ? 'atualizada' : 'criada'}:`, savedSprint);
            sprintModal.hide();
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("[Submit Handler] Erro no bloco catch:", error); // Log F
            console.error("Erro ao salvar sprint:", error);
            alert(`Erro ao salvar sprint: ${error.message}`);
        } finally {
            console.log("[Submit Handler] Bloco finally executado."); // Log G
            showModalLoading(false);
        }
    });

    // Listener de CLIQUE no botão Salvar (para depuração)
    const submitButton = sprintForm.querySelector('button[type="submit"]');
    if (submitButton) {
        submitButton.addEventListener('click', function(clickEvent) {
            console.log("[Submit Button Click] Botão Salvar clicado!");
            // Poderíamos até chamar a função de submit daqui manualmente se necessário,
            // mas primeiro vamos ver se o clique é registrado.
        });
    } else {
        console.error("[Sprint Mgmt] Botão Salvar (submit) não encontrado dentro do formulário!");
    }

    // Event Delegation para botões de Ação na tabela
    sprintBoard.addEventListener('click', function(event) { // Agora escuta cliques no quadro
        const target = event.target.closest('button'); // Encontra o botão clicado
        if (!target) return; // Sai se o clique não foi em um botão

        const sprintId = target.dataset.id;
        if (!sprintId) return; // Sai se o botão não tem ID

        if (target.classList.contains('edit-btn')) {
            openEditModal(sprintId);
        }
        else if (target.classList.contains('delete-btn')) {
            const sprintName = target.dataset.name || `Sprint ${sprintId}`; // Pega nome do data attribute
            deleteSprint(sprintId, sprintName);
        }
        else if (target.classList.contains('test-update-btn')) {
            // Botão de teste para desenvolvedores
            console.log(`[TESTE] Atualizando contadores da sprint ${sprintId}`);
            window.updateSprintHourCounters(sprintId);
            
            // Exemplo de como adicionar uma tarefa de teste
            if (confirm('Deseja adicionar uma tarefa de teste?')) {
                const taskData = {
                    id: Date.now(), // ID temporário
                    title: `Tarefa de Teste ${new Date().getHours()}:${new Date().getMinutes()}`,
                    estimated_effort: Math.floor(Math.random() * 8) + 1, // 1-8 horas
                    specialist_name: 'Desenvolvedor Teste',
                    priority: 'Média',
                    project_id: 'TEST',
                    is_generic: false
                };
                
                const success = window.addTaskToSprintVisually(sprintId, taskData);
                if (success) {
                    alert('Tarefa de teste adicionada com sucesso! Observe como o contador foi atualizado automaticamente.');
                }
            }
        }
        // Adicionar else if para 'allocate-btn' futuramente
    });

    // Listener para botão Excluir DENTRO do modal (apenas na edição)
    modalDeleteBtn.addEventListener('click', function() {
        if (editingSprintId) {
            const sprintNameInput = document.getElementById('sprintName');
            const sprintName = sprintNameInput ? sprintNameInput.value : `Sprint ${editingSprintId}`; 
            sprintModal.hide(); // Esconde o modal antes de confirmar exclusão
            deleteSprint(editingSprintId, sprintName);
        }
    });

    // Listener para quando o modal é fechado (resetar)
    sprintModalElement.addEventListener('hidden.bs.modal', function (event) {
        sprintForm.reset();
        sprintModalLabel.textContent = 'Nova Sprint';
        formMethodInput.value = 'POST'; // Reseta método para POST
        editingSprintId = null;
        modalDeleteBtn.style.display = 'none'; // Esconde botão excluir
    });

    // Listener para quando o modal está PRESTES A SER EXIBIDO
    sprintModalElement.addEventListener('show.bs.modal', function (event) {
        // Garante que o modal sempre abra sem o loading ativo
        // A função openEditModal vai ativar o loading se necessário DEPOIS disso.
        console.log("[Sprint Mgmt] Evento show.bs.modal disparado. Garantindo que loading está desligado.");
        showModalLoading(false);
        // O reset do formulário e título já é feito no hidden.bs.modal
        // Mas podemos garantir o título aqui também para o caso de criação
        if (!editingSprintId) {
            sprintModalLabel.textContent = 'Nova Sprint';
            modalDeleteBtn.style.display = 'none';
            formMethodInput.value = 'POST';
        }
    });

    // Carrega Sprints e Backlog em paralelo e inicializa SortableJS DEPOIS que ambos terminarem
    console.log("[Sprint Mgmt] Iniciando carregamento inicial de Sprints e Backlog...");
    Promise.all([
        loadSprints(),      // loadSprints já é async
        loadBacklogTasks()  // loadBacklogTasks já é async
    ]).then(() => {
        console.log("[Sprint Mgmt] Carregamento inicial de Sprints e Backlog CONCLUÍDO.");
        initializeSortable(); // Chama UMA VEZ após tudo estar carregado
        initializePopovers(); // <<< INICIALIZA Popovers após carregamento inicial >>>
    }).catch(error => {
        console.error("[Sprint Mgmt] Erro durante o carregamento inicial (Promise.all):", error);
        // Mostrar uma mensagem de erro geral para o usuário?
        sprintBoard.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais. Recarregue a página.</div>';
        backlogColumnBody.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais.</div>';
    });

    // <<< INÍCIO: Lógica para Recolher/Expandir Backlog (JS Manipula Estilos) >>>
    const toggleBtn = document.getElementById('toggleBacklogBtn');
    const backlogColumn = document.getElementById('backlogColumn'); // Seleciona a coluna diretamente
    const boardContainer = document.getElementById('sprintBoardContainer'); // Container ainda útil?

    if (toggleBtn && backlogColumn) { // Verifica se botão e COLUNA existem
        // Função para aplicar estilos de recolhimento/expansão
        function applyCollapseStyles(collapse) {
            if (collapse) {
                backlogColumn.style.flexBasis = '0px';
                backlogColumn.style.minWidth = '0px';
                backlogColumn.style.opacity = '0';
                backlogColumn.style.paddingLeft = '0';
                backlogColumn.style.paddingRight = '0';
                backlogColumn.style.borderWidth = '0';
                backlogColumn.style.pointerEvents = 'none';
                toggleBtn.classList.add('collapsed-trigger'); // Adiciona classe ao botão
            } else {
                // Remove estilos inline para voltar aos padrões do CSS
                backlogColumn.style.removeProperty('flex-basis');
                backlogColumn.style.removeProperty('min-width');
                backlogColumn.style.removeProperty('opacity');
                backlogColumn.style.removeProperty('padding-left');
                backlogColumn.style.removeProperty('padding-right');
                backlogColumn.style.removeProperty('border-width');
                backlogColumn.style.removeProperty('pointer-events');
                toggleBtn.classList.remove('collapsed-trigger'); // Remove classe do botão
            }
        }

        // Função para atualizar ícone e título do botão
        function updateButtonState(collapsed) {
            const icon = toggleBtn.querySelector('i');
            if (collapsed) {
                if (icon) icon.className = 'bi bi-chevron-double-right';
                toggleBtn.title = 'Expandir Backlog';
            } else {
                if (icon) icon.className = 'bi bi-chevron-double-left';
                toggleBtn.title = 'Recolher Backlog';
            }
        }

        // Estado inicial (lido do localStorage)
        let isCollapsed = localStorage.getItem('sprintBacklogCollapsed') === 'true';
        applyCollapseStyles(isCollapsed); // Aplica estilos iniciais
        updateButtonState(isCollapsed); // Define botão inicial

        // Listener de clique no botão
        toggleBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed; // Inverte o estado
            applyCollapseStyles(isCollapsed); // Aplica novos estilos
            updateButtonState(isCollapsed); // Atualiza botão
            localStorage.setItem('sprintBacklogCollapsed', isCollapsed ? 'true' : 'false'); // Salva estado
        });

    } else {
        console.error('[Sprint Mgmt] Botão #toggleBacklogBtn ou Coluna #backlogColumn não encontrados.');
    }
    // <<< FIM: Lógica para Recolher/Expandir Backlog >>>

    // Função para carregar tarefas genéricas
    async function loadGenericTasks() {
        const genericTasksBody = document.querySelector('#genericTasksColumn .side-column-body');
        genericTasksBody.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm" role="status"></div> Carregando tarefas genéricas...</div>';
        
        try {
            const response = await fetch('/sprints/api/generic-tasks');
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar tarefas genéricas`);
            }
            const tasks = await response.json();
            
            genericTasksBody.innerHTML = '';
            if (tasks.length === 0) {
                genericTasksBody.innerHTML = '<div class="text-center text-muted p-3">Nenhuma tarefa genérica encontrada.</div>';
                return;
            }
            
            tasks.forEach(task => {
                const taskCard = document.createElement('div');
                taskCard.className = `generic-task ${task.status === 'Concluído' ? 'task-completed' : ''}`;
                taskCard.dataset.taskId = task.id;
                taskCard.draggable = true;
                
                taskCard.innerHTML = `
                    <div class="generic-task-title">${escapeHtml(task.title)}</div>
                    
                    ${task.project_id ? `<div class="task-project-info small text-muted mb-2">
                        <i class="bi bi-folder2 me-1"></i><strong>${task.project_id}</strong>${task.project_name ? ` - ${escapeHtml(task.project_name.length > 20 ? task.project_name.substring(0, 20) + '...' : task.project_name)}` : ''}
                    </div>` : ''}
                    
                    <div class="generic-task-meta d-flex justify-content-between align-items-center mb-2">
                        <span class="badge rounded-pill priority-badge">${escapeHtml(task.priority)}</span>
                        ${task.estimated_effort ? `<span class="text-muted small"><i class="bi bi-clock me-1"></i>${task.estimated_effort}h</span>` : ''}
                    </div>
                    
                    ${task.specialist_name ? `<div class="task-specialist small text-primary">
                        <i class="bi bi-person-fill me-1"></i>${escapeHtml(task.specialist_name)}
                    </div>` : '<div class="task-specialist small text-muted"><i class="bi bi-person me-1"></i>Não atribuído</div>'}
                `;
                
                // Adiciona evento de clique para edição
                taskCard.addEventListener('click', () => openGenericTaskModal(task));
                
                genericTasksBody.appendChild(taskCard);
                
                // Aplica classe de cor ao badge de prioridade
                const badgeElement = taskCard.querySelector('.priority-badge');
                if (badgeElement) {
                    const priorityLower = (task.priority || '').toLowerCase();
                    let badgeClass = 'text-bg-primary'; // Default: Média
                    if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                    else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                    else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                    badgeElement.classList.add(...badgeClass.split(' '));
                }
            });
        } catch (error) {
            console.error("Erro ao carregar tarefas genéricas:", error);
            genericTasksBody.innerHTML = `<div class="alert alert-danger">Erro ao carregar tarefas genéricas: ${error.message}</div>`;
        }
    }

    // Modal de Tarefa Genérica
    const genericTaskModal = new bootstrap.Modal(document.getElementById('genericTaskModal'));
    const genericTaskForm = document.getElementById('genericTaskForm');
    const genericTaskDeleteBtn = document.getElementById('genericTaskDeleteBtn');
    let editingGenericTaskId = null;

    // Função para abrir o modal de tarefa genérica
    function openGenericTaskModal(task = null) {
        const modalTitle = document.getElementById('genericTaskModalLabel');
        const deleteBtn = document.getElementById('genericTaskDeleteBtn');
        
        genericTaskForm.reset();
        
        if (task) {
            modalTitle.textContent = 'Editar Tarefa Genérica';
            document.getElementById('genericTaskId').value = task.id;
            document.getElementById('genericTaskTitle').value = task.title;
            document.getElementById('genericTaskDescription').value = task.description || '';
            document.getElementById('genericTaskPriority').value = task.priority || 'Média';
            document.getElementById('genericTaskEffort').value = task.estimated_effort || '';
            document.getElementById('genericTaskSpecialist').value = task.specialist_name || '';
            deleteBtn.style.display = 'block';
            editingGenericTaskId = task.id;
        } else {
            modalTitle.textContent = 'Nova Tarefa Genérica';
            deleteBtn.style.display = 'none';
            editingGenericTaskId = null;
        }
        
        genericTaskModal.show();
    }

    // Handler para submissão do formulário de tarefa genérica
    genericTaskForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(genericTaskForm);
        const data = {
            title: formData.get('title'),
            description: formData.get('description'),
            priority: formData.get('priority'),
            estimated_hours: formData.get('estimated_effort') ? parseFloat(formData.get('estimated_effort')) : null,
            specialist_name: formData.get('specialist_name') || null
        };
        
        try {
            const url = editingGenericTaskId 
                ? `/sprints/api/generic-tasks/${editingGenericTaskId}`
                : '/sprints/api/generic-tasks';
            
            const response = await fetch(url, {
                method: editingGenericTaskId ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks();
            
        } catch (error) {
            console.error("Erro ao salvar tarefa genérica:", error);
            alert(`Erro ao salvar tarefa genérica: ${error.message}`);
        }
    });

    // Handler para exclusão de tarefa genérica
    genericTaskDeleteBtn.addEventListener('click', async function() {
        if (!editingGenericTaskId || !confirm('Tem certeza que deseja excluir esta tarefa genérica?')) {
            return;
        }
        
        try {
            const response = await fetch(`/sprints/api/generic-tasks/${editingGenericTaskId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks(); // Recarrega as tarefas genéricas
            loadSprints(); // Recarrega as sprints para atualizar caso a tarefa estivesse em alguma sprint
            
        } catch (error) {
            console.error("Erro ao excluir tarefa genérica:", error);
            alert(`Erro ao excluir tarefa genérica: ${error.message}`);
        }
    });

    // Carrega as tarefas genéricas junto com o resto dos dados
    loadGenericTasks();

    // Adiciona listener para o botão de adicionar tarefa genérica
    const addGenericTaskBtn = document.getElementById('addGenericTaskBtn');
    if (addGenericTaskBtn) {
        addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    }

    // Função para atualizar o popover de horas por especialista de uma sprint
    function updateSpecialistPopover(sprintListElement) {
        const sprintCard = sprintListElement.closest('.sprint-card');
        if (!sprintCard) return;

        // Encontra todas as tarefas na sprint
        const tasks = sprintListElement.querySelectorAll('.backlog-task-card');
        let hoursBySpecialist = {};

        // Calcula horas por especialista
        tasks.forEach(task => {
            const specialist = task.dataset.specialistName;
            if (specialist && specialist.trim()) { // Só considera se tiver especialista
                const hours = parseFloat(task.dataset.estimatedHours) || 0;
                hoursBySpecialist[specialist] = (hoursBySpecialist[specialist] || 0) + hours;
            }
        });

        // Formata o conteúdo do popover com informações básicas
        let popoverContent = '';
        Object.entries(hoursBySpecialist).forEach(([specialist, hours]) => {
            if (specialist !== 'Não Atribuído') {
                const capacidadeTotal = capacidadeTotalPorEspecialista;
                const horasRestantes = capacidadeTotal - hours;
                const percentualUtilizado = Math.round((hours / capacidadeTotal) * 100);
                
                // Define cor do badge baseado na utilização
                let badgeClass = 'success';
                if (percentualUtilizado > 100) {
                    badgeClass = 'danger';
                } else if (percentualUtilizado > 80) {
                    badgeClass = 'warning';
                }
                
                popoverContent += `
                    <div class="mb-2">
                        <strong>${escapeHtml(specialist)}</strong><br>
                        <small>
                            ${hours.toFixed(1)}h utilizadas / ${capacidadeTotal}h disponíveis (${semanasSprint} sem.)<br>
                            Saldo: ${horasRestantes.toFixed(1)}h 
                            <span class="badge bg-${badgeClass} ms-1">${percentualUtilizado}%</span>
                        </small>
                    </div>
                `;
            }
        });
        
        if (!popoverContent) {
            popoverContent = '<small class="text-muted">Nenhum especialista alocado</small>';
        }

        // Escape do conteúdo do popover para uso seguro
        const escapedPopoverContent = popoverContent.replace(/"/g, '&quot;').replace(/'/g, '&#39;');

        // Atualiza o popover
        const popoverButton = sprintCard.querySelector('.specialist-hours-popover');
        if (popoverButton) {
            // Destrói o popover existente
            const popoverInstance = bootstrap.Popover.getInstance(popoverButton);
            if (popoverInstance) {
                popoverInstance.dispose();
            }

            if (Object.keys(hoursBySpecialist).length > 0) {
                // Atualiza o div oculto com o novo conteúdo
                const contentId = popoverButton.getAttribute('data-popover-content-id');
                const contentDiv = document.getElementById(contentId);
                if (contentDiv) {
                    contentDiv.innerHTML = popoverContent;
                }
                
                // Cria um novo popover com o conteúdo atualizado
                new bootstrap.Popover(popoverButton, {
                    content: popoverContent, // Usa conteúdo não-escapado para JavaScript
                    html: true,
                    placement: 'bottom',
                    trigger: 'hover focus',
                    title: 'Especialistas'
                });
                popoverButton.style.display = 'inline-flex';
            } else {
                popoverButton.style.display = 'none';
            }
        }
    }

    // Função para abrir o modal de detalhes da tarefa
    function openTaskDetailsModal(taskElement) {
        const taskId = taskElement.dataset.taskId;
        const taskType = taskElement.classList.contains('generic-task') ? 'generic' : 'backlog';
        const form = document.getElementById('taskDetailsForm');
        const backlogFields = document.getElementById('backlogSpecificFields');
        const modalTitle = document.getElementById('taskDetailsModalLabel');
        const deleteBtn = document.getElementById('taskDeleteBtn');

        // Reset form e configura campos básicos
        form.reset();
        document.getElementById('taskId').value = taskId;
        document.getElementById('taskType').value = taskType;

        // Configura visibilidade dos campos específicos do backlog
        backlogFields.classList.toggle('d-none', taskType === 'generic');

        // Busca dados da tarefa na API
        fetch(`/backlog/api/tasks/${taskId}`)
            .then(response => {
                if (!response.ok) throw new Error(`Erro ${response.status}`);
                return response.json();
            })
            .then(task => {
                // Preenche os campos do formulário
                document.getElementById('taskTitle').value = task.name || '';
                document.getElementById('taskPriority').value = task.priority || 'Média';
                document.getElementById('taskSpecialist').value = task.specialist_name || '';
                document.getElementById('taskEstimatedHours').value = task.estimated_effort || '';
                document.getElementById('taskDescription').value = task.description || '';
                document.getElementById('taskStatus').value = task.status || 'pendente';

                if (taskType === 'backlog') {
                    document.getElementById('taskProjectId').value = task.project_id || '';
                    document.getElementById('taskColumnIdentifier').value = task.column_identifier || '';
                }

                // Configura título do modal
                modalTitle.textContent = `Detalhes da Tarefa - ${task.name}`;

                // Mostra o modal
                const taskModal = new bootstrap.Modal(document.getElementById('taskDetailsModal'));
                taskModal.show();
            })
            .catch(error => {
                console.error('Erro ao carregar detalhes da tarefa:', error);
                alert('Erro ao carregar detalhes da tarefa. Por favor, tente novamente.');
            });
    }

    // Handler para submissão do formulário de detalhes da tarefa
    document.getElementById('taskDetailsForm').addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(this);
        const taskId = formData.get('taskId');
        const taskType = formData.get('taskType');
        
        const data = {
            name: formData.get('title'),
            priority: formData.get('priority'),
            specialist_name: formData.get('specialist_name'),
            estimated_hours: formData.get('estimated_hours') ? parseFloat(formData.get('estimated_hours')) : null,
            description: formData.get('description')
        };
        const statusValue = formData.get('status');
        if (statusValue && statusValue !== 'None' && statusValue !== '') {
            data.status = statusValue;
        }

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao salvar tarefa:', error);
            alert('Erro ao salvar alterações. Por favor, tente novamente.');
        }
    });

    // Handler para exclusão de tarefa
    document.getElementById('taskDeleteBtn').addEventListener('click', async function() {
        const taskId = document.getElementById('taskId').value;
        const taskType = document.getElementById('taskType').value;
        
        if (!confirm('Tem certeza que deseja excluir esta tarefa?')) return;

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'DELETE'
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao excluir tarefa:', error);
            alert('Erro ao excluir tarefa. Por favor, tente novamente.');
        }
    });

    // Adiciona evento de clique nas tarefas
    document.addEventListener('click', function(event) {
        const taskCard = event.target.closest('.backlog-task-card:not(.generic-task)');
        if (taskCard && !event.target.closest('.task-actions')) {
            openTaskDetailsModal(taskCard);
        }
    });

    // Delegação de eventos para botões de editar e excluir Sprints
    sprintBoard.addEventListener('click', function(event) {
        const editButton = event.target.closest('.edit-btn');
        const deleteButton = event.target.closest('.delete-btn');

        if (editButton) {
            const sprintId = editButton.dataset.id;
            openEditModal(sprintId);
        } else if (deleteButton) {
            const sprintId = deleteButton.dataset.id;
            const sprintName = deleteButton.dataset.name;
            deleteSprint(sprintId, sprintName);
        }
    });

    // Carrega os dados iniciais (Este bloco de chamadas diretas é redundante se Promise.all está sendo usado)
    // loadSprints(); // Redundante
    // loadBacklogTasks(); // Redundante
    // loadGenericTasks(); // Redundante

    // <<< INÍCIO: Event Listeners para Coluna de Tarefas Genéricas >>>
    // A declaração e o listener para addGenericTaskBtn já foram feitos anteriormente no código.
    // Este bloco abaixo é uma duplicação e causa o erro de linter, então será removido.
    // const addGenericTaskBtn = document.getElementById('addGenericTaskBtn'); 
    // if (addGenericTaskBtn) {
    //     addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    // }
    // <<< FIM: Event Listeners para Coluna de Tarefas Genéricas >>>

    // <<< INÍCIO: Funções Globais para Atualização Automática de Contadores >>>
    
    // Função global para recalcular e atualizar horas de uma sprint específica
    window.updateSprintHourCounters = function(sprintId) {
        console.log(`[Sprint Update] Atualizando contadores da sprint ${sprintId}`);
        
        const sprintCard = document.querySelector(`.sprint-card[data-sprint-id="${sprintId}"]`);
        if (!sprintCard) {
            console.warn(`[Sprint Update] Sprint card ${sprintId} não encontrado`);
            return;
        }

        const sprintTasksContainer = sprintCard.querySelector('.sprint-tasks');
        if (!sprintTasksContainer) {
            console.warn(`[Sprint Update] Container de tarefas da sprint ${sprintId} não encontrado`);
            return;
        }

        // Recalcula total de horas da sprint
        const tasks = sprintTasksContainer.querySelectorAll('.backlog-task-card');
        let totalSprintHours = 0;
        let hoursBySpecialist = {};

        tasks.forEach(task => {
            const hours = parseFloat(task.dataset.estimatedHours) || 0;
            totalSprintHours += hours;

            // Calcula horas por especialista para o popover
            const specialist = task.dataset.specialistName;
            if (specialist && specialist.trim() && specialist !== 'Não Atribuído') {
                hoursBySpecialist[specialist] = (hoursBySpecialist[specialist] || 0) + hours;
            }
        });

        // Busca o badge de horas totais de forma mais robusta
        let hoursSpan = sprintCard.querySelector('.sprint-badge:has(i.bi-stopwatch)');
        if (!hoursSpan) {
            // Fallback: procura por qualquer elemento que contenha o ícone stopwatch
            hoursSpan = sprintCard.querySelector('.sprint-badge i.bi-stopwatch');
            if (hoursSpan) {
                hoursSpan = hoursSpan.parentElement;
            }
        }
        
        // Terceiro fallback: procura pelo padrão de texto das horas
        if (!hoursSpan) {
            const allBadges = sprintCard.querySelectorAll('.sprint-badge');
            allBadges.forEach(badge => {
                if (badge.textContent.includes('h') && badge.querySelector('i.bi-stopwatch')) {
                    hoursSpan = badge;
                }
            });
        }

        if (hoursSpan) {
            hoursSpan.innerHTML = `<i class="bi bi-stopwatch"></i>${totalSprintHours.toFixed(1)}h`;
            console.log(`[Sprint Update] Horas atualizadas para ${totalSprintHours.toFixed(1)}h na sprint ${sprintId}`);
        } else {
            console.warn(`[Sprint Update] Elemento de horas não encontrado na sprint ${sprintId}`);
            console.log('[Sprint Update] Elementos encontrados:', sprintCard.querySelectorAll('.sprint-badge'));
        }

        // Atualiza popover de especialistas
        updateSpecialistPopoverForSprint(sprintCard, hoursBySpecialist);
    };

    // Função para atualizar popover de especialistas de uma sprint específica
    function updateSpecialistPopoverForSprint(sprintCard, hoursBySpecialist) {
        const popoverButton = sprintCard.querySelector('.specialist-hours-popover');
        if (!popoverButton) return;

        // Destrói popover existente para evitar conflitos
        const existingPopover = bootstrap.Popover.getInstance(popoverButton);
        if (existingPopover) {
            existingPopover.dispose();
        }

        if (Object.keys(hoursBySpecialist).length > 0) {
            // Gera novo conteúdo
            let popoverContent = '';
            Object.entries(hoursBySpecialist).forEach(([specialist, hours]) => {
                const capacidadeTotal = 80; // Valor padrão, idealmente vir da API
                const horasRestantes = capacidadeTotal - hours;
                const percentualUtilizado = Math.round((hours / capacidadeTotal) * 100);
                
                let badgeClass = 'success';
                if (percentualUtilizado > 100) {
                    badgeClass = 'danger';
                } else if (percentualUtilizado > 80) {
                    badgeClass = 'warning';
                }
                
                popoverContent += `
                    <div class="mb-2">
                        <strong>${escapeHtml(specialist)}</strong><br>
                        <small>
                            ${hours.toFixed(1)}h utilizadas / ${capacidadeTotal}h disponíveis<br>
                            Saldo: ${horasRestantes.toFixed(1)}h 
                            <span class="badge bg-${badgeClass} ms-1">${percentualUtilizado}%</span>
                        </small>
                    </div>
                `;
            });

            // Cria novo popover com configuração melhorada
            const popoverInstance = new bootstrap.Popover(popoverButton, {
                content: popoverContent,
                html: true,
                placement: 'bottom',
                trigger: 'hover', // Apenas hover, remove focus para evitar problemas
                title: 'Especialistas',
                delay: { show: 300, hide: 100 }, // Adiciona delays para melhor UX
                container: 'body' // Anexa ao body para evitar conflitos de z-index
            });

            // Adiciona listeners manuais para melhor controle
            let hideTimeout;
            
            popoverButton.addEventListener('mouseenter', () => {
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                }
            });
            
            popoverButton.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    if (popoverInstance) {
                        popoverInstance.hide();
                    }
                }, 200); // Delay de 200ms antes de esconder
            });
            
            popoverButton.style.display = 'inline-flex';
        } else {
            popoverButton.style.display = 'none';
        }
    }

    // Função global para adicionar uma tarefa visualmente a uma sprint (sem API)
    window.addTaskToSprintVisually = function(sprintId, taskData) {
        console.log(`[Sprint Update] Adicionando tarefa ${taskData.id} visualmente à sprint ${sprintId}`);
        
        const sprintCard = document.querySelector(`.sprint-card[data-sprint-id="${sprintId}"]`);
        if (!sprintCard) {
            console.warn(`[Sprint Update] Sprint card ${sprintId} não encontrado`);
            return false;
        }

        const sprintTasksContainer = sprintCard.querySelector('.sprint-tasks');
        if (!sprintTasksContainer) {
            console.warn(`[Sprint Update] Container de tarefas da sprint ${sprintId} não encontrado`);
            return false;
        }

        // Remove mensagem de "nenhuma tarefa" se existir
        const emptyMessage = sprintTasksContainer.querySelector('.text-muted.fst-italic');
        if (emptyMessage) {
            emptyMessage.remove();
        }

        // Cria o elemento HTML da tarefa
        const taskCard = document.createElement('div');
        taskCard.className = `backlog-task-card sprint-task-card ${taskData.status === 'concluido' ? 'task-completed' : ''}`;
        taskCard.dataset.taskId = taskData.id;
        taskCard.dataset.estimatedHours = taskData.estimated_effort || 0;
        taskCard.dataset.specialistName = taskData.specialist_name || '';
        taskCard.dataset.isGeneric = taskData.is_generic || false;
        taskCard.draggable = true;

        const projectPart = taskData.project_id || 'PROJ';
        const columnPart = (taskData.column_identifier || 'UNK').substring(0, 3).toUpperCase();

        taskCard.innerHTML = `
            <div class="task-title">${escapeHtml(taskData.title || taskData.name)}</div>
            
            ${taskData.project_id && !taskData.is_generic ? `<div class="task-project-info small text-muted mb-2">
                <i class="bi bi-folder2 me-1"></i><strong>${taskData.project_id}</strong>${taskData.project_name ? ` - ${escapeHtml(taskData.project_name.length > 25 ? taskData.project_name.substring(0, 25) + '...' : taskData.project_name)}` : ''}
            </div>` : ''}
            
            <div class="task-meta d-flex justify-content-between align-items-center mb-2">
                <div class="task-meta-left">
                    <span class="badge rounded-pill task-priority-badge">${escapeHtml(taskData.priority || 'Média')}</span>
                </div>
                <div class="task-meta-right d-flex align-items-center gap-2">
                    ${taskData.estimated_effort ? `<span class="text-muted small"><i class="bi bi-clock me-1"></i>${taskData.estimated_effort}h</span>` : ''}
                </div>
            </div>
            
            ${taskData.specialist_name ? `<div class="task-specialist small text-primary">
                <i class="bi bi-person-fill me-1"></i>${escapeHtml(taskData.specialist_name)}
            </div>` : '<div class="task-specialist small text-muted"><i class="bi bi-person me-1"></i>Não atribuído</div>'}
        `;

        // Adiciona classe de cor ao badge de prioridade
        const badgeElement = taskCard.querySelector('.task-priority-badge');
        if (badgeElement) {
            const priorityLower = (taskData.priority || '').toLowerCase();
            let badgeClass = 'text-bg-primary'; // Default: Média
            if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
            else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
            else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
            badgeElement.classList.add(...badgeClass.split(' '));
        }

        // Adiciona a tarefa ao container
        sprintTasksContainer.appendChild(taskCard);

        // Atualiza contadores automaticamente
        window.updateSprintHourCounters(sprintId);

        // Reinicializa sortable para incluir a nova tarefa
        initializeSortable();

        console.log(`[Sprint Update] Tarefa ${taskData.id} adicionada com sucesso à sprint ${sprintId}`);
        return true;
    };

    // Função global para remover uma tarefa visualmente de uma sprint
    window.removeTaskFromSprintVisually = function(sprintId, taskId) {
        console.log(`[Sprint Update] Removendo tarefa ${taskId} visualmente da sprint ${sprintId}`);
        
        const sprintCard = document.querySelector(`.sprint-card[data-sprint-id="${sprintId}"]`);
        if (!sprintCard) {
            console.warn(`[Sprint Update] Sprint card ${sprintId} não encontrado`);
            return false;
        }

        const taskCard = sprintCard.querySelector(`.sprint-task-card[data-task-id="${taskId}"]`);
        if (!taskCard) {
            console.warn(`[Sprint Update] Tarefa ${taskId} não encontrada na sprint ${sprintId}`);
            return false;
        }

        // Remove a tarefa
        taskCard.remove();

        // Verifica se precisa adicionar mensagem de "nenhuma tarefa"
        const sprintTasksContainer = sprintCard.querySelector('.sprint-tasks');
        const remainingTasks = sprintTasksContainer.querySelectorAll('.backlog-task-card');
        if (remainingTasks.length === 0) {
            sprintTasksContainer.innerHTML = '<small class="text-muted fst-italic ps-2">Nenhuma tarefa alocada.</small>';
        }

        // Atualiza contadores automaticamente
        window.updateSprintHourCounters(sprintId);

        console.log(`[Sprint Update] Tarefa ${taskId} removida com sucesso da sprint ${sprintId}`);
        return true;
    };

    // Função global para atualizar dados de uma tarefa existente em uma sprint
    window.updateTaskInSprintVisually = function(sprintId, taskId, updatedTaskData) {
        console.log(`[Sprint Update] Atualizando tarefa ${taskId} na sprint ${sprintId}`);
        
        const sprintCard = document.querySelector(`.sprint-card[data-sprint-id="${sprintId}"]`);
        if (!sprintCard) {
            console.warn(`[Sprint Update] Sprint card ${sprintId} não encontrado`);
            return false;
        }

        const taskCard = sprintCard.querySelector(`.sprint-task-card[data-task-id="${taskId}"]`);
        if (!taskCard) {
            console.warn(`[Sprint Update] Tarefa ${taskId} não encontrada na sprint ${sprintId}`);
            return false;
        }

        // Atualiza datasets
        if (updatedTaskData.estimated_effort !== undefined) {
            taskCard.dataset.estimatedHours = updatedTaskData.estimated_effort || 0;
        }
        if (updatedTaskData.specialist_name !== undefined) {
            taskCard.dataset.specialistName = updatedTaskData.specialist_name || '';
        }

        // Atualiza contadores automaticamente
        window.updateSprintHourCounters(sprintId);

        console.log(`[Sprint Update] Tarefa ${taskId} atualizada com sucesso na sprint ${sprintId}`);
        return true;
    };

    // <<< FIM: Funções Globais para Atualização Automática de Contadores >>>

    // <<< INÍCIO: Exemplo de Integração com APIs Externas >>>
    
    // Exemplo de como integrar com outras partes do sistema:
    // 
    // 1. Quando uma tarefa é criada e associada a uma sprint:
    //    window.addTaskToSprintVisually(sprintId, taskData);
    //
    // 2. Quando uma tarefa é editada e suas horas mudam:
    //    window.updateTaskInSprintVisually(sprintId, taskId, {estimated_effort: newHours});
    //
    // 3. Quando uma tarefa é removida de uma sprint:
    //    window.removeTaskFromSprintVisually(sprintId, taskId);
    //
    // 4. Para forçar recálculo de uma sprint específica:
    //    window.updateSprintHourCounters(sprintId);
    
    // Hook global que pode ser usado por outras páginas/modais
    window.sprintManagementHooks = {
        onTaskCreated: function(taskData, sprintId) {
            if (sprintId && taskData) {
                return window.addTaskToSprintVisually(sprintId, taskData);
            }
            return false;
        },
        
        onTaskUpdated: function(taskId, updatedData, sprintId) {
            if (sprintId && taskId) {
                return window.updateTaskInSprintVisually(sprintId, taskId, updatedData);
            }
            return false;
        },
        
        onTaskDeleted: function(taskId, sprintId) {
            if (sprintId && taskId) {
                return window.removeTaskFromSprintVisually(sprintId, taskId);
            }
            return false;
        },
        
        refreshSprint: function(sprintId) {
            if (sprintId) {
                window.updateSprintHourCounters(sprintId);
                return true;
            }
            return false;
        }
    };
    
    // Expõe o hook globalmente para uso em console ou outras páginas
    console.log("[Sprint Management] Hooks globais disponíveis em window.sprintManagementHooks");
    console.log("[Sprint Management] Funções diretas disponíveis:");
    console.log("  - window.updateSprintHourCounters(sprintId)");
    console.log("  - window.addTaskToSprintVisually(sprintId, taskData)");
    console.log("  - window.removeTaskFromSprintVisually(sprintId, taskId)");
    console.log("  - window.updateTaskInSprintVisually(sprintId, taskId, updatedData)");
    
    // Função para habilitar modo de teste (para desenvolvedores)
    window.enableSprintTestMode = function() {
        const testButtons = document.querySelectorAll('.test-update-btn');
        testButtons.forEach(btn => {
            btn.style.display = 'inline-block';
        });
        console.log("[Sprint Management] Modo de teste habilitado! Botões de teste aparecem nos cards das sprints.");
        console.log("Execute window.disableSprintTestMode() para ocultar.");
    };
    
    window.disableSprintTestMode = function() {
        const testButtons = document.querySelectorAll('.test-update-btn');
        testButtons.forEach(btn => {
            btn.style.display = 'none';
        });
        console.log("[Sprint Management] Modo de teste desabilitado.");
    };
    
    console.log("[Sprint Management] Para testar: execute window.enableSprintTestMode() no console");
    
    // <<< FIM: Exemplo de Integração com APIs Externas >>>

    // Função para inicializar todos os popovers
  }); // Fim DOMContentLoaded
</script>
{# Adiciona SortableJS #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
{% endblock %} 