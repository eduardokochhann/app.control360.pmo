{% extends 'base.html' %}

{% block title %}{{ title }}{% endblock %}

{% block extra_css %}
<style>
  /* Variáveis de Cores e Estilos */
  :root {
    --sprint-primary: #0d6efd;
    --sprint-secondary: #6c757d;
    --sprint-success: #198754;
    --sprint-info: #0dcaf0;
    --sprint-warning: #ffc107;
    --sprint-danger: #dc3545;
    --sprint-light: #f8f9fa;
    --sprint-dark: #212529;
    --sprint-border: #dee2e6;
    --sprint-hover: #e9ecef;
    --sprint-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    --sprint-shadow-lg: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    
    /* Cores de Criticidade */
    --criticality-normal-bg: #f8f9fa;
    --criticality-normal-border: #dee2e6;
    --criticality-alta-bg: #fff3cd;
    --criticality-alta-border: #ffc107;
    --criticality-critica-bg: #f8d7da;
    --criticality-critica-border: #dc3545;
  }

  /* Layout Geral */
  .sprint-board-container {
    display: flex;
    align-items: flex-start;
    gap: 1.5rem;
    height: calc(100vh - 180px);
    min-height: 400px;
    background-color: #ffffff;
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--sprint-border);
    box-shadow: var(--sprint-shadow);
    overflow: hidden; /* Previne scroll não intencional */
  }

  /* Sprint Board */
  .sprint-board {
    flex-grow: 1;
    display: flex;
    gap: 1.5rem;
    overflow-x: auto;
    padding: 0.5rem;
    align-items: flex-start;
    height: 100%;
    padding-bottom: 1rem; /* Espaço para evitar corte */
  }

  /* Sprint Cards */
  .sprint-card {
    flex: 0 0 400px !important;
    width: 400px !important;
    min-width: 400px !important;
    max-width: 400px !important;
    height: 680px !important; /* Reduzido ~10% de 760px */
    min-height: 680px !important;
    max-height: 680px !important;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    transition: all 0.2s ease;
    margin-bottom: 0.5rem;
  }

  /* Cabeçalho da Sprint */
  .sprint-card-header {
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    border-radius: 0.5rem 0.5rem 0 0;
    min-height: 120px; /* Altura mínima fixa para o cabeçalho */
  }

  /* Cores de Criticidade */
  .sprint-card-header.criticality-normal {
    background-color: var(--criticality-normal-bg);
    border-bottom: 2px solid var(--criticality-normal-border);
  }

  .sprint-card-header.criticality-alta {
    background-color: var(--criticality-alta-bg);
    border-bottom: 2px solid var(--criticality-alta-border);
  }

  .sprint-card-header.criticality-critica {
    background-color: var(--criticality-critica-bg);
    border-bottom: 2px solid var(--criticality-critica-border);
  }

  /* Linha Superior do Cabeçalho */
  .sprint-header-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    width: 100%;
    gap: 1rem;
  }

  /* Área do Título e Informações */
  .sprint-title-area {
    flex: 1;
    min-width: 0; /* Importante para text-overflow funcionar */
  }

  .sprint-card-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--sprint-dark);
    margin: 0 0 0.5rem 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Badges e Metadados */
  .sprint-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .sprint-badge {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    font-weight: normal;
    border-radius: 0.25rem;
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--sprint-secondary);
  }

  .sprint-badge i {
    margin-right: 0.25rem;
  }

  /* Área de Ações */
  .sprint-card-actions {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .sprint-card-actions button {
    padding: 0.25rem 0.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.375rem;
    transition: all 0.2s ease;
  }

  /* Linha Inferior do Cabeçalho */
  .sprint-header-bottom {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .sprint-dates {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .sprint-goal {
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0;
  }

  /* Corpo da Sprint */
  .sprint-card-body {
    padding: 1rem;
    overflow-y: auto;
    flex-grow: 1;
    background-color: #ffffff;
    height: calc(100% - 120px);
  }

  .sprint-tasks {
    min-height: 50px;
    padding: 0.5rem;
    background-color: var(--sprint-light);
    border-radius: 0.375rem;
  }

  /* Task Cards */
  .backlog-task-card {
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    cursor: grab;
    transition: all 0.2s ease;
  }

  .backlog-task-card:last-child {
    margin-bottom: 0;
  }

  .task-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
  }

  .task-priority-badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    white-space: nowrap;
  }

  .task-hours {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  .task-full-id {
    font-family: monospace;
    font-size: 0.7rem;
    padding: 0.1rem 0.3rem;
    background-color: var(--sprint-light);
    border-radius: 0.2rem;
    color: var(--sprint-secondary);
  }

  /* Responsividade */
  @media (max-width: 1600px) {
    .sprint-card {
      flex: 0 0 350px !important;
      width: 350px !important;
      min-width: 350px !important;
      max-width: 350px !important;
      height: 650px !important; /* Reduzido ~10% de 720px */
      min-height: 650px !important;
      max-height: 650px !important;
    }

    #backlogColumn {
      flex: 0 0 350px;
      min-width: 350px;
      max-width: 350px;
    }
  }

  /* Colunas Laterais (Backlog e Tarefas Genéricas) */
  .side-column {
    flex: 0 0 350px;
    min-width: 350px;
    max-width: 350px;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.5rem;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }

  /* Coluna de Backlog específica */
  #backlogColumn {
    flex: 0 0 400px;
    min-width: 400px;
    max-width: 400px;
  }

  .side-column-header {
    padding: 1rem;
    background-color: #ffffff;
    border-bottom: 1px solid var(--sprint-border);
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .side-column-title {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .side-column-title h6 {
    margin: 0;
    font-weight: 600;
  }

  .search-container {
    position: relative;
  }

  .search-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    padding-left: 2rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    font-size: 0.875rem;
  }

  .search-icon {
    position: absolute;
    left: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    color: var(--sprint-secondary);
  }

  .side-column-body {
    padding: 0.75rem;
    overflow-y: auto;
    flex-grow: 1;
  }

  /* Projetos no Backlog */
  .backlog-project {
    margin-bottom: 0.5rem;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    overflow: hidden;
  }

  .backlog-project-header {
    padding: 0.75rem;
    background-color: var(--sprint-light);
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 0.5rem;
  }

  .project-info {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    min-width: 0;
  }

  .project-id {
    font-family: monospace;
    font-size: 0.8rem;
    color: var(--sprint-secondary);
    white-space: nowrap;
  }

  .project-name {
    font-size: 0.875rem;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .project-tasks {
    display: none;
    padding: 0.75rem;
    background-color: #ffffff;
  }

  .project-tasks.show {
    display: block;
  }

  /* Tarefas Genéricas */
  .generic-task {
    padding: 0.75rem;
    background-color: #ffffff;
    border: 1px solid var(--sprint-border);
    border-radius: 0.375rem;
    margin-bottom: 0.5rem;
    cursor: pointer;
  }

  .generic-task:hover {
    background-color: var(--sprint-hover);
  }

  .generic-task-title {
    font-size: 0.875rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  .generic-task-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.75rem;
    color: var(--sprint-secondary);
  }

  /* Badges */
  .project-badge {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    background-color: var(--sprint-light);
    color: var(--sprint-secondary);
    white-space: nowrap;
  }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
  <div class="card shadow mb-4">
    <div class="card-header py-3 d-flex flex-row align-items-center justify-content-between">
      {# <<< INÍCIO: Agrupamento Título + Botão Collapse >>> #}
      <div class="d-flex align-items-center">
        <button class="btn btn-sm btn-outline-secondary me-2" id="toggleBacklogBtn" title="Recolher Backlog">
            <i class="bi bi-chevron-double-left"></i>
        </button>
        <h6 class="m-0 font-weight-bold text-primary"><i class="bi bi-calendar3-week me-2"></i>{{ title }}</h6>
      </div>
      {# <<< FIM: Agrupamento Título + Botão Collapse >>> #}
      <div>
        <a href="{{ url_for('sprints.consolidated_report_page') }}" class="btn btn-sm btn-outline-primary me-2">
            <i class="bi bi-file-earmark-text me-1"></i>Relatório Consolidado
        </a>
        <button class="btn btn-sm btn-primary" id="addSprintBtn" data-bs-toggle="modal" data-bs-target="#sprintModal">
            <i class="bi bi-plus-lg me-1"></i>Nova Sprint
        </button>
      </div>
    </div>
    <div class="card-body">
      {# Área do Quadro de Sprints #}
      <div class="sprint-board-container" id="sprintBoardContainer"> {# Novo container geral #}
          {# Coluna do Backlog #}
          <div class="side-column" id="backlogColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Backlog</h6>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar projeto..." id="backlogSearch">
                  </div>
              </div>
              <div class="side-column-body" id="backlogList">
                  {# Conteúdo do backlog será carregado via JavaScript #}
              </div>
          </div>

          {# Nova Coluna de Tarefas Genéricas #}
          <div class="side-column" id="genericTasksColumn">
              <div class="side-column-header">
                  <div class="side-column-title">
                      <h6>Tarefas Genéricas</h6>
                      <button class="btn btn-sm btn-outline-primary" id="addGenericTaskBtn">
                          <i class="bi bi-plus"></i>
                      </button>
                  </div>
                  <div class="search-container">
                      <i class="bi bi-search search-icon"></i>
                      <input type="text" class="search-input" placeholder="Buscar tarefa..." id="genericTaskSearch">
                  </div>
              </div>
              <div class="side-column-body" id="genericTasksList">
                  {# Conteúdo das tarefas genéricas será carregado via JavaScript #}
              </div>
          </div>

          {# Área Rolável para Sprints #}
          <div id="sprintBoard" class="sprint-board">
          <div class="text-center text-muted p-5">Carregando sprints...</div>
          </div>
      </div>
    </div>
  </div>
</div>

{# Modal Adicionar/Editar Sprint #}
<div class="modal fade" id="sprintModal" tabindex="-1" aria-labelledby="sprintModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <form id="sprintForm">
        <div class="modal-header bg-primary text-white">
          <h5 class="modal-title" id="sprintModalLabel">Nova Sprint</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="sprintId" name="sprintId">
          
          <div class="mb-3">
            <label for="sprintName" class="form-label">Nome <span class="text-danger">*</span></label>
            <input type="text" class="form-control form-control-sm" id="sprintName" name="name" required placeholder="Ex: Sprint 24.01">
          </div>
          
          <div class="row mb-3">
              <div class="col-md-6">
                  <label for="sprintStartDate" class="form-label">Data Início <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintStartDate" name="start_date" required>
              </div>
              <div class="col-md-6">
                  <label for="sprintEndDate" class="form-label">Data Fim <span class="text-danger">*</span></label>
                  <input type="date" class="form-control form-control-sm" id="sprintEndDate" name="end_date" required>
              </div>
          </div>

          <div class="mb-3">
            <label for="sprintGoal" class="form-label">Objetivo</label>
            <textarea class="form-control form-control-sm" id="sprintGoal" name="goal" rows="3" placeholder="Descreva o objetivo principal desta Sprint..."></textarea>
          </div>
          <div class="mb-3">
            <label for="sprintCriticality" class="form-label">Criticidade</label>
            <select class="form-select form-select-sm" id="sprintCriticality" name="criticality">
                <option value="Normal" selected>Normal</option>
                <option value="Alta">Alta</option>
                <option value="Crítica">Crítica</option>
            </select>
          </div>
          {# Campo oculto para o método HTTP (usado para PUT em edição) #}
          <input type="hidden" id="formMethod" name="_method" value="POST">
        </div>
        <div class="modal-footer">
          {# Botão Excluir aparece apenas na edição #}
          <button type="button" class="btn btn-danger me-auto" id="modalDeleteBtn" style="display: none;">Excluir Sprint</button>
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
          <button type="submit" class="btn btn-primary" onclick="console.log('[Inline Click] Botão Salvar clicado!')">Salvar Sprint</button>
        </div>
        {# Loading Feedback #}
        <div class="loading-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); z-index: 1056; display: flex; justify-content: center; align-items: center; border-radius: inherit;">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
      </form>
    </div>
  </div>
</div>

{# Modal para Adicionar/Editar Tarefa Genérica #}
<div class="modal fade" id="genericTaskModal" tabindex="-1" aria-labelledby="genericTaskModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <form id="genericTaskForm">
                <div class="modal-header">
                    <h5 class="modal-title" id="genericTaskModalLabel">Nova Tarefa Genérica</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="hidden" id="genericTaskId" name="taskId">
                    
                    <div class="mb-3">
                        <label for="genericTaskTitle" class="form-label">Título <span class="text-danger">*</span></label>
                        <input type="text" class="form-control" id="genericTaskTitle" name="title" required>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskDescription" class="form-label">Descrição</label>
                        <textarea class="form-control" id="genericTaskDescription" name="description" rows="3"></textarea>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskPriority" class="form-label">Prioridade</label>
                            <select class="form-select" id="genericTaskPriority" name="priority">
                                <option value="Baixa">Baixa</option>
                                <option value="Média" selected>Média</option>
                                <option value="Alta">Alta</option>
                                <option value="Urgente">Urgente</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="genericTaskEffort" class="form-label">Esforço (horas)</label>
                            <input type="number" class="form-control" id="genericTaskEffort" name="estimated_effort" step="0.5" min="0">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label for="genericTaskSpecialist" class="form-label">Especialista</label>
                        <input type="text" class="form-control" id="genericTaskSpecialist" name="specialist_name">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-danger me-auto" id="genericTaskDeleteBtn" style="display: none;">Excluir</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="submit" class="btn btn-primary">Salvar</button>
                </div>
            </form>
        </div>
    </div>
</div>

{# Modal para Visualizar/Editar Tarefa #}
<div class="modal fade" id="taskDetailsModal" tabindex="-1" aria-labelledby="taskDetailsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="taskDetailsModalLabel">Detalhes da Tarefa</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="taskDetailsForm">
          <input type="hidden" id="taskId" name="taskId">
          <input type="hidden" id="taskType" name="taskType">
          
          <div class="row mb-3">
            <div class="col-md-8">
              <label for="taskTitle" class="form-label">Título <span class="text-danger">*</span></label>
              <input type="text" class="form-control" id="taskTitle" name="title" required>
            </div>
            <div class="col-md-4">
              <label for="taskPriority" class="form-label">Prioridade</label>
              <select class="form-select" id="taskPriority" name="priority">
                <option value="Baixa">Baixa</option>
                <option value="Média" selected>Média</option>
                <option value="Alta">Alta</option>
                <option value="Urgente">Urgente</option>
              </select>
            </div>
          </div>

          <div class="row mb-3">
            <div class="col-md-6">
              <label for="taskSpecialist" class="form-label">Especialista</label>
              <input type="text" class="form-control" id="taskSpecialist" name="specialist_name">
            </div>
            <div class="col-md-3">
              <label for="taskEstimatedHours" class="form-label">Horas Estimadas</label>
              <input type="number" class="form-control" id="taskEstimatedHours" name="estimated_hours" step="0.5" min="0">
            </div>
            <div class="col-md-3">
              <label for="taskStatus" class="form-label">Status</label>
              <select class="form-select" id="taskStatus" name="status">
                <option value="pendente">Pendente</option>
                <option value="em_andamento">Em Andamento</option>
                <option value="concluido">Concluído</option>
                <option value="bloqueado">Bloqueado</option>
              </select>
            </div>
          </div>

          <div class="mb-3">
            <label for="taskDescription" class="form-label">Descrição</label>
            <textarea class="form-control" id="taskDescription" name="description" rows="4"></textarea>
          </div>

          <div id="backlogSpecificFields" class="d-none">
            <div class="row mb-3">
              <div class="col-md-6">
                <label for="taskProjectId" class="form-label">ID do Projeto</label>
                <input type="text" class="form-control" id="taskProjectId" name="project_id" readonly>
              </div>
              <div class="col-md-6">
                <label for="taskColumnIdentifier" class="form-label">Coluna</label>
                <input type="text" class="form-control" id="taskColumnIdentifier" name="column_identifier" readonly>
              </div>
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-danger me-auto" id="taskDeleteBtn">Excluir Tarefa</button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        <button type="submit" form="taskDetailsForm" class="btn btn-primary">Salvar Alterações</button>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    console.log("[Sprint Mgmt] DOMContentLoaded iniciado.");
    const backlogColumnBody = document.querySelector('#backlogColumn .side-column-body'); // Corpo da coluna de backlog
    const sprintBoard = document.getElementById('sprintBoard'); // Seleciona o contêiner do quadro
    const sprintModalElement = document.getElementById('sprintModal');
    const sprintModal = new bootstrap.Modal(sprintModalElement);
    const sprintForm = document.getElementById('sprintForm');
    console.log("[Sprint Mgmt] Elemento sprintForm encontrado:", sprintForm); // Log de verificação
    const sprintModalLabel = document.getElementById('sprintModalLabel');
    let editingSprintId = null; // Para controle de edição futura
    const formMethodInput = document.getElementById('formMethod'); // Input oculto para método
    const modalDeleteBtn = document.getElementById('modalDeleteBtn'); // Botão excluir no modal
    const apiSprintsBaseUrl = '/sprints/api/sprints'; // API Sprints
    const apiBacklogTasksUrl = '/backlog/api/backlogs/unassigned-tasks'; // API Backlog Tasks

    // Função para mostrar feedback de loading no modal
    function showModalLoading(isLoading) {
        const overlay = sprintForm.querySelector('.loading-overlay');
        const submitButton = sprintForm.querySelector('button[type="submit"]');
        const cancelButton = sprintForm.querySelector('button[data-bs-dismiss="modal"]');
        if (overlay) overlay.style.display = isLoading ? 'flex' : 'none';
        if (modalDeleteBtn) modalDeleteBtn.disabled = isLoading;
        if (submitButton) submitButton.disabled = isLoading;
        if (cancelButton) cancelButton.disabled = isLoading;
    }

    // Função para formatar data (DD/MM/YYYY)
    function formatDate(isoDateString) {
        if (!isoDateString) return '-';
        try {
            // Tenta criar a data. Adiciona 'T00:00:00' se for apenas YYYY-MM-DD
            const dateStr = isoDateString.includes('T') ? isoDateString : isoDateString + 'T00:00:00';
            const date = new Date(dateStr);
            // Verifica se a data é válida
            if (isNaN(date.getTime())) {
                console.warn("Data inválida recebida:", isoDateString);
                return 'Data Inválida';
            }
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0'); // Mês é 0-indexed
            const year = date.getFullYear();
            return `${day}/${month}/${year}`;
        } catch (e) {
            console.error("Erro ao formatar data:", isoDateString, e);
            return 'Erro Data';
        }
    }

    // Função para carregar e renderizar sprints
    async function loadSprints() {
        console.log("[Sprint Mgmt] loadSprints() chamado.");
        sprintBoard.innerHTML = '<div class="text-center text-muted p-5"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Carregando...</span></div> Carregando sprints...</div>';
        try {
            console.log(`[Sprint Mgmt] Tentando fetch sprints: ${apiSprintsBaseUrl}`);
            const response = await fetch(apiSprintsBaseUrl);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar sprints`);
            }
            const sprintsApiResponse = await response.json();

            sprintBoard.innerHTML = ''; // Limpa o quadro
            if (!sprintsApiResponse || sprintsApiResponse.length === 0) {
                sprintBoard.innerHTML = '<div class="text-center text-muted p-5">Nenhuma sprint encontrada. Crie uma nova!</div>';
            } else {
                sprintsApiResponse.forEach(sprint => {
                    // INÍCIO DA NOVA VERIFICAÇÃO DE ERRO
                    if (sprint.error) {
                        console.warn(`[Sprint Mgmt] Sprint ID ${sprint.id || 'N/A'} retornou com erro da API: ${sprint.error}`);
                        const errorCard = document.createElement('div');
                        // Adicionar classes para estilizar o card de erro, se desejado
                        errorCard.className = 'sprint-card'; 
                        errorCard.style.border = '2px solid red';
                        errorCard.innerHTML = `
                            <div class="sprint-card-header" style="background-color: #f8d7da; color: #721c24;">
                                <h6 class="sprint-card-title">Erro ao carregar Sprint ${sprint.id || '(ID Desconhecido)'}</h6>
                            </div>
                            <div class="sprint-card-body">
                                <p><strong>Detalhe do erro:</strong> ${escapeHtml(sprint.error)}</p>
                                <p class="text-muted small">Verifique os logs do servidor para mais informações.</p>
                            </div>
                        `;
                        sprintBoard.appendChild(errorCard);
                        return; // Pula para a próxima sprint
                    }
                    // FIM DA NOVA VERIFICAÇÃO DE ERRO

                    const sprintCard = document.createElement('div');
                    sprintCard.className = 'sprint-card';
                    sprintCard.dataset.sprintId = sprint.id;

                    // <<< INÍCIO: Calcular Total de Horas Estimadas da Sprint >>>
                    let totalSprintHours = 0;
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        totalSprintHours = sprint.tasks.reduce((sum, task) => {
                            const hours = parseFloat(task.estimated_hours);
                            return sum + (isNaN(hours) ? 0 : hours);
                        }, 0);
                    }
                    // <<< FIM: Calcular Total de Horas Estimadas da Sprint >>>

                    // <<< INÍCIO: Calcular Horas por Especialista >>>
                    let hoursBySpecialist = {};
                    if (sprint.tasks && sprint.tasks.length > 0) {
                        hoursBySpecialist = sprint.tasks.reduce((acc, task) => {
                            const specialist = task.specialist_name || 'Não Atribuído';
                            const hours = parseFloat(task.estimated_hours);
                            if (!isNaN(hours)) {
                                acc[specialist] = (acc[specialist] || 0) + hours;
                            }
                            return acc;
                        }, {});
                    }
                    // Formata o conteúdo do popover
                    let popoverContent = Object.entries(hoursBySpecialist)
                        .map(([name, hours]) => `<div>${escapeHtml(name)}: <strong>${hours.toFixed(1)}h</strong></div>`)
                        .join('');
                    if (!popoverContent) {
                        popoverContent = '<div class="text-muted small">Especialista</div>';
                    }
                    // <<< FIM: Calcular Horas por Especialista >>>

                    sprintCard.innerHTML = `
                        <div class="sprint-card-header criticality-${(sprint.criticality || 'normal').toLowerCase()}">
                            <div class="sprint-header-top">
                                <div class="sprint-title-area">
                                    <h6 class="sprint-card-title">${escapeHtml(sprint.name)}</h6>
                                    <div class="sprint-meta">
                                        <span class="sprint-badge">
                                            <i class="bi bi-stopwatch"></i>${totalSprintHours.toFixed(1)}h
                                        </span>
                                        ${Object.keys(hoursBySpecialist).length > 0 ? `
                                        <button type="button" class="sprint-badge specialist-hours-popover" 
                                                data-bs-toggle="popover" 
                                                data-bs-placement="bottom"
                                                data-bs-trigger="hover focus"
                                                data-bs-html="true" 
                                                title="Horas por Especialista"
                                                data-bs-content="${popoverContent}">
                                            <i class="bi bi-people"></i>Especialistas
                                        </button>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="sprint-card-actions">
                                    <button class="btn btn-sm btn-outline-secondary edit-btn" data-id="${sprint.id}" title="Editar Sprint">
                                        <i class="bi bi-pencil"></i>
                                    </button>
                                    <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${sprint.id}" data-name="${escapeHtml(sprint.name)}" title="Excluir Sprint">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="sprint-header-bottom">
                                <div class="sprint-dates">
                                    <i class="bi bi-calendar-range"></i>
                                    ${formatDate(sprint.start_date)} - ${formatDate(sprint.end_date)}
                                </div>
                                <div class="sprint-goal">
                                    ${escapeHtml(sprint.goal || 'Sem objetivo definido.')}
                                </div>
                            </div>
                        </div>
                        <div class="sprint-card-body">
                            <div class="sprint-tasks" data-sprint-id="${sprint.id}">
                                ${sprint.tasks && sprint.tasks.length > 0 ? 
                                    sprint.tasks.map(task => {
                                        const projectPart = task.project_id || 'PROJ';
                                        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase(); 
                                        const isCompleted = task.column_identifier === 'concluido';
                                        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;
                                        return `
                                        <div class="backlog-task-card sprint-task-card ${isCompleted ? 'task-completed' : ''}" data-task-id="${task.id}" draggable="true" data-estimated-hours="${task.estimated_hours || 0}" data-specialist-name="${escapeHtml(task.specialist_name || '')}" data-is-generic="${task.is_generic || false}">
                                            <div class="task-title">${escapeHtml(task.name)}</div>
                                            <div class="task-meta">
                                                <div class="task-meta-left">
                                                    <span class="badge rounded-pill task-priority-badge">${escapeHtml(task.priority || 'Média')}</span>
                                                </div>
                                                <div class="task-meta-right text-muted task-hours">
                                                    ${task.estimated_hours ? `<i class="bi bi-clock"></i> ${task.estimated_hours}h` : ''}
                                                </div>
                                            </div>
                                            ${task.specialist_name ? `<div class="task-specialist"><i class="bi bi-person-fill"></i> ${escapeHtml(task.specialist_name)}</div>` : ''}
                                            <div class="task-actions">
                                                {# REMOVIDO BOTÃO DEVOLVER DAQUI #}
                                            </div>
                                        </div>`;
                                    }).join('') 
                                    : '<small class="text-muted fst-italic ps-2">Nenhuma tarefa alocada.</small>' 
                                } 
                            </div>
                        </div>
                    `;
                    sprintBoard.appendChild(sprintCard);

                    // Aplica classe de cor ao badge de prioridade APÓS adicionar ao DOM
                    sprint.tasks.forEach(task => {
                        const cardElement = sprintBoard.querySelector(`.sprint-task-card[data-task-id="${task.id}"]`);
                        if (cardElement) {
                            const badgeElement = cardElement.querySelector('.task-priority-badge');
                            if (badgeElement) {
                                const priorityLower = (task.priority || '').toLowerCase();
                                let badgeClass = 'text-bg-primary'; // Default: Média
                                if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                                else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                                else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                                badgeElement.classList.add(...badgeClass.split(' '));
                            }
                        }
                    });
                });
                initializeSortable(); // Inicializa Sortable DEPOIS de renderizar sprints
                initializePopovers(); // <<< INICIALIZA Popovers DEPOIS de renderizar sprints >>>
            }
        } catch (error) {
            console.error("Erro ao carregar sprints:", error);
            sprintBoard.innerHTML = `<div class="alert alert-danger">Erro ao carregar sprints: ${error.message}</div>`;
        }
    }

    // Função para renderizar uma tarefa do backlog
    function renderBacklogTask(task) {
        const projectPart = task.project_id || 'PROJ';
        const columnPart = (task.column_identifier || 'UNK').substring(0, 3).toUpperCase();
        const isCompleted = task.column_identifier === 'concluido';
        const fullTaskId = `${projectPart}-${columnPart}-${task.id}`;

        return `
            <div class="backlog-task-card ${isCompleted ? 'task-completed' : ''}" 
                 data-task-id="${task.id}" 
                 draggable="true" 
                 data-estimated-hours="${task.estimated_hours || 0}" 
                 data-specialist-name="${escapeHtml(task.specialist_name || '')}">
                <div class="task-title">${escapeHtml(task.name)}</div>
                <div class="task-meta">
                    <div class="task-meta-left">
                        <span class="badge rounded-pill task-priority-badge ${getPriorityClass(task.priority)}">${escapeHtml(task.priority || 'Média')}</span>
                    </div>
                    <div class="task-meta-right text-muted task-hours">
                        <span title="Estimado"><i class="bi bi-clock-history me-1"></i>${task.estimated_hours != null ? task.estimated_hours.toFixed(1) : '-'}h</span>
                        <code class="task-full-id">${fullTaskId}</code>
                    </div>
                </div>
            </div>
        `;
    }

    // Função auxiliar para obter a classe CSS baseada na prioridade
    function getPriorityClass(priority) {
        const priorityLower = (priority || '').toLowerCase();
        switch (priorityLower) {
            case 'urgente': return 'text-bg-danger';
            case 'alta': return 'text-bg-warning';
            case 'baixa': return 'text-bg-secondary';
            default: return 'text-bg-primary'; // Média ou outro
        }
    }

    // Função para renderizar um projeto do backlog
    function renderBacklogProject(backlog) {
        const projectBoardUrl = `/backlog/board/${backlog.project_id}`; // URL de destino para o quadro do projeto
        
        // Limita o nome do projeto até "MSM SOLUCOES PARA"
        let displayName = backlog.project_name || 'Sem Nome';
        const msmIndex = displayName.indexOf('MSM SOLUCOES PARA');
        if (msmIndex >= 0) {
            displayName = displayName.substring(0, msmIndex + 'MSM SOLUCOES PARA'.length);
        }

        return `
            <div class="backlog-project" data-project-id="${backlog.project_id}">
                <div class="backlog-project-header">
                    <div class="project-info">
                        <a href="${projectBoardUrl}" class="project-link-to-board" title="Abrir quadro do projeto ${escapeHtml(backlog.project_name || 'Projeto sem nome')}" style="text-decoration: none; color: inherit;">
                            <span class="project-id">${backlog.project_id}</span>
                            <span class="project-name">${escapeHtml(displayName)}</span>
                        </a>
                    </div>
                    <i class="bi bi-chevron-down" onclick="toggleProjectTasks(this.closest('.backlog-project-header'))" style="cursor: pointer;"></i>
                </div>
                <div class="project-tasks">
                    ${backlog.tasks && backlog.tasks.length > 0 
                        ? backlog.tasks.map(task => renderBacklogTask(task)).join('')
                        : '<div class="text-muted small p-2">Nenhuma tarefa disponível.</div>'
                    }
                </div>
            </div>
        `;
    }

    // Função para carregar e renderizar tarefas do backlog não alocadas
    async function loadBacklogTasks() {
        const backlogList = document.getElementById('backlogList');
        backlogList.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm"></div> Carregando...</div>';

        try {
            const response = await fetch('/backlog/api/backlogs/unassigned-tasks');
            if (!response.ok) throw new Error(`Erro ${response.status}`);
            
            const backlogs = await response.json();
            
            if (!backlogs || backlogs.length === 0) {
                backlogList.innerHTML = '<div class="text-center text-muted p-3">Nenhum projeto encontrado.</div>';
                return;
            }

            backlogList.innerHTML = backlogs.map(backlog => renderBacklogProject(backlog)).join('');

            // Inicializa Sortable para as novas tarefas
            initializeSortable();

        } catch (error) {
            console.error("Erro ao carregar backlogs:", error);
            backlogList.innerHTML = `<div class="alert alert-danger m-3">Erro ao carregar: ${error.message}</div>`;
        }
    }

    // Função para busca nos backlogs
    function setupSearch(inputId, itemsContainer, itemSelector) {
        const searchInput = document.getElementById(inputId);
        if (!searchInput) return;

        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            const items = itemsContainer.querySelectorAll(itemSelector);

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchTerm) ? '' : 'none';
            });
        });
    }

    // Inicializa as buscas
    setupSearch('backlogSearch', document.getElementById('backlogList'), '.backlog-project');
    setupSearch('genericTaskSearch', document.getElementById('genericTasksList'), '.generic-task');

    // Função para alternar visibilidade das tarefas do projeto
    window.toggleProjectTasks = function(header) {
        const tasksDiv = header.nextElementSibling;
        const chevron = header.querySelector('.bi');
        
        if (tasksDiv.classList.contains('show')) {
            tasksDiv.classList.remove('show');
            chevron.classList.replace('bi-chevron-up', 'bi-chevron-down');
        } else {
            tasksDiv.classList.add('show');
            chevron.classList.replace('bi-chevron-down', 'bi-chevron-up');
        }
    };

    // --- Funções de Drag and Drop (SortableJS) ---
    let sortableInstances = []; // Guarda instâncias para possível destruição/recriação

    // <<< INÍCIO: Armazena instâncias de Popover para atualização >>>
    let popoverInstances = {}; // Guarda instâncias por ID do botão (ex: popover-sprint-123)
    // <<< FIM: Armazena instâncias de Popover >>>

    function initializeSortable() {
        // Destroi instâncias antigas se existirem (útil se recarregar dinamicamente)
        sortableInstances.forEach(instance => instance.destroy());
        sortableInstances = [];

        console.log("[Sprint Mgmt] Inicializando SortableJS...");

        // Seleciona TODAS as listas de tarefas (backlog, sprints e tarefas genéricas)
        const taskLists = document.querySelectorAll('.project-tasks, #genericTasksList, .sprint-tasks');
        
        taskLists.forEach(list => {
            const instance = new Sortable(list, {
                group: 'shared-tasks', // Nome do grupo para permitir mover entre listas
                animation: 150,
                ghostClass: 'sortable-ghost-task', // Classe CSS para o fantasma
                chosenClass: 'sortable-chosen-task', // Classe CSS para o item escolhido
                draggable: '.backlog-task-card, .generic-task', // Itens arrastáveis
                
                onEnd: function (evt) {
                    const item = evt.item; // O elemento da tarefa movida
                    const taskId = item.dataset.taskId;
                    const fromList = evt.from; // Lista de origem
                    const toList = evt.to;     // Lista de destino
                    const newIndex = evt.newIndex; // Nova posição na lista de destino

                    // Atualiza horas estimadas na UI
                    const taskHours = parseFloat(item.dataset.estimatedHours) || 0;
                    const taskSpecialist = item.dataset.specialistName || 'Não Atribuído';

                    // Função auxiliar para atualizar o display de horas de uma sprint
                    function updateSprintHoursDisplay(sprintListElement, hoursDelta) {
                        const sprintCard = sprintListElement.closest('.sprint-card');
                        if (!sprintCard) return;
                        const hoursSpan = sprintCard.querySelector('.sprint-total-hours');
                        if (!hoursSpan) return;

                        try {
                            const currentHoursText = hoursSpan.textContent.match(/([\d\.]+)/);
                            let currentHours = currentHoursText ? parseFloat(currentHoursText[1]) : 0;
                            if (isNaN(currentHours)) currentHours = 0;
                            
                            const newTotalHours = currentHours + hoursDelta;
                            
                            hoursSpan.innerHTML = `<i class="bi bi-stopwatch me-1"></i>${newTotalHours.toFixed(1)}h`;
                        } catch (e) {
                            console.error("Erro ao atualizar display de horas da sprint:", e);
                        }
                    }

                    // Atualiza horas da sprint de ORIGEM (se for uma sprint)
                    if (fromList.classList.contains('sprint-tasks')) {
                        updateSprintHoursDisplay(fromList, -taskHours);
                        updateSpecialistPopover(fromList);
                    }

                    // Atualiza horas da sprint de DESTINO (se for uma sprint)
                    if (toList.classList.contains('sprint-tasks')) {
                        updateSprintHoursDisplay(toList, taskHours);
                        updateSpecialistPopover(toList);
                    }

                    // Identifica o destino (para a API)
                    let targetSprintId = null;
                    if (toList.classList.contains('sprint-tasks')) {
                        targetSprintId = toList.dataset.sprintId;
                    }

                    // Se a tarefa foi movida para uma sprint, atualiza o sprint_id
                    if (targetSprintId) {
                        updateTaskSprintAssignment(taskId, targetSprintId, newIndex);
                    } else {
                        // Se a tarefa foi movida para fora de uma sprint (para Backlog ou Tarefas Genéricas na UI)
                        // chamar a API de "move-to-backlog".
                        console.log(`[Sortable onEnd] Tarefa ${taskId} movida para fora da sprint (destino não é uma sprint). Chamando API /move-to-backlog.`);
                        fetch(`/sprints/api/sprints/tasks/${taskId}/move-to-backlog`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                // Adicionar CSRF token se necessário
                                // {% raw %}'X-CSRFToken': '{{ csrf_token() }}'{% endraw %} 
                            }
                        })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => { throw new Error(err.message || `Erro ${response.status}`); });
                            }
                            return response.json();
                        })
                        .then(updatedTask => {
                            console.log(`[Sortable onEnd] Tarefa ${taskId} movida para backlog via API. Dados:`, updatedTask);
                            // O elemento já foi movido pelo SortableJS.
                            // A sprint de origem precisa ser atualizada (contagem de horas).
                            // As listas de backlog/genéricas precisam ser atualizadas para refletir a tarefa devolvida corretamente.
                            if (updatedTask.is_generic) {
                                console.log(`[Sortable onEnd] Tarefa ${taskId} (genérica) devolvida. Recarregando tarefas genéricas.`);
                                loadGenericTasks();
                            } else {
                                console.log(`[Sortable onEnd] Tarefa ${taskId} (de projeto) devolvida. Recarregando backlog de projetos.`);
                                loadBacklogTasks();
                            }
                            loadSprints(); // Atualiza a sprint de origem e outras para consistência
                        })
                        .catch(error => {
                            console.error(`[Sortable onEnd] Erro ao mover tarefa ${taskId} para o backlog via API:`, error);
                            alert(`Erro ao tentar mover tarefa para o backlog: ${error.message}. A interface pode estar dessincronizada. Por favor, atualize a página.`);
                            // Para garantir, recarregar tudo para tentar sincronizar
                            loadSprints();
                            loadBacklogTasks();
                            loadGenericTasks();
                        });
                    }
                }
            });
            sortableInstances.push(instance);
        });
    }

    // <<< INÍCIO: Função para inicializar todos os popovers >>>
    function initializePopovers() {
        console.log("[Sprint Mgmt] Inicializando Popovers...");
        const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
        popoverTriggerList.forEach(popoverTriggerEl => {
            // Gera um ID único para o botão se não existir (necessário para armazenar instância)
            if (!popoverTriggerEl.id) {
                popoverTriggerEl.id = `popover-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
            }
            // Cria e armazena a instância
            const instance = new bootstrap.Popover(popoverTriggerEl);
            popoverInstances[popoverTriggerEl.id] = instance;
        });
        console.log(`[Sprint Mgmt] ${Object.keys(popoverInstances).length} instâncias Popover inicializadas.`);

        // Opcional: Adicionar listener para destruir popovers ao sair da página?
    }
    // <<< FIM: Função para inicializar todos os popovers >>>

    // *** TODO: Função para chamar a API ***
    // Função para chamar a API e atualizar a associação da sprint da tarefa
    async function updateTaskSprintAssignment(taskId, sprintId, newPosition) {
        const apiUrl = `/backlog/api/tasks/${taskId}/assign`;
        // Se sprintId for undefined (arrastado para a coluna de backlog), envia null
        const payload = {
             sprint_id: sprintId === undefined ? null : sprintId, 
             position: newPosition 
            };

        console.log(`[API Call] Chamando ${apiUrl} com payload:`, payload);

        try {
            const response = await fetch(apiUrl, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { 
                    const errorData = await response.json();
                    errorMsg = errorData.message || errorData.description || errorMsg; 
                } catch(e) {}
                throw new Error(errorMsg);
            }

            const updatedTask = await response.json();
            console.log("[API Call] Tarefa atualizada com sucesso:", updatedTask);
            // Opcional: Atualizar visualmente o card da tarefa se a API retornar dados úteis
            // Por enquanto, a mudança visual já foi feita pelo SortableJS.

        } catch (error) {
            console.error("[API Call] Erro ao atualizar sprint da tarefa:", error);
            alert(`Erro ao mover tarefa: ${error.message}\nA interface pode estar dessincronizada. Recarregue a página.`);
            // TODO: Implementar lógica para reverter a mudança visual do SortableJS?
            // Isso é complexo, recarregar a página pode ser a solução mais simples.
            // window.location.reload(); 
        }
    }

    // Função para escapar HTML (segurança)
    function escapeHtml(unsafe) {
      if (!unsafe) return '';
      return unsafe
           .replace(/&/g, "&amp;")
           .replace(/</g, "&lt;")
           .replace(/>/g, "&gt;")
           .replace(/"/g, "&quot;")
           .replace(/'/g, "&#039;");
    }

    // --- Funções de Ação (Editar/Excluir) ---

    // Prepara e abre o modal para edição
    async function openEditModal(sprintId) {
        console.log(`Abrindo modal para editar Sprint ID: ${sprintId}`);
        sprintForm.reset(); // Limpa o formulário
        editingSprintId = sprintId;
        formMethodInput.value = 'PUT'; // Define método como PUT
        sprintModalLabel.textContent = 'Editar Sprint';
        modalDeleteBtn.style.display = 'inline-block'; // Mostra botão excluir
        showModalLoading(true); // Mostra loading antes do fetch
        sprintModal.show();

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`);
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar dados da sprint ${sprintId}`);
            }
            const sprintData = await response.json();

            // Preenche o formulário
            document.getElementById('sprintId').value = sprintData.id;
            document.getElementById('sprintName').value = sprintData.name;
            // Formata data para YYYY-MM-DD para input date
            document.getElementById('sprintStartDate').value = sprintData.start_date ? sprintData.start_date.substring(0, 10) : '';
            document.getElementById('sprintEndDate').value = sprintData.end_date ? sprintData.end_date.substring(0, 10) : '';
            document.getElementById('sprintGoal').value = sprintData.goal || '';
            document.getElementById('sprintCriticality').value = sprintData.criticality || 'Normal';

        } catch (error) {
            console.error("Erro ao carregar dados para edição:", error);
            alert(`Erro ao carregar dados da sprint: ${error.message}`)
            sprintModal.hide(); // Esconde o modal se deu erro ao carregar
        } finally {
            showModalLoading(false);
        }
    }

    // Exclui uma sprint
    async function deleteSprint(sprintId, sprintName) {
        if (!confirm(`Tem certeza que deseja excluir a sprint "${sprintName}"?\nAs tarefas associadas serão desvinculadas.`)) {
            return;
        }
        console.log(`Tentando excluir Sprint ID: ${sprintId}`);
        // Poderíamos mostrar um loading na linha da tabela ou geral

        try {
            const response = await fetch(`${apiSprintsBaseUrl}/${sprintId}`, {
                method: 'DELETE'
            });

            if (!response.ok && response.status !== 200 && response.status !== 204) { // Aceita 200 ou 204
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            console.log(`Sprint ${sprintId} excluída com sucesso.`);
            // Opcional: Mostrar um toast/alert de sucesso
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("Erro ao excluir sprint:", error);
            alert(`Erro ao excluir sprint: ${error.message}`);
        }
    }

    // --- Fim Funções de Ação ---

    // Listener para submissão do formulário (Criar/Editar Sprint)
    sprintForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        console.log("[Submit Handler] Evento submit detectado."); // Log A
        showModalLoading(true);

        const formData = new FormData(sprintForm);
        console.log("[Submit Handler] FormData criado."); // Log B
        const data = {
            name: formData.get('name'),
            // Input type=date já retorna YYYY-MM-DD, que é compatível com fromisoformat no backend
            start_date: formData.get('start_date'), 
            end_date: formData.get('end_date'),   // O input type=date já retorna YYYY-MM-DD
            goal: formData.get('goal') || null,
            criticality: formData.get('criticality') || 'Normal'
        };

        // Validação simples das datas no frontend
        if (data.start_date && data.end_date && data.start_date > data.end_date) {
            alert('A data de início não pode ser posterior à data de fim.');
            showModalLoading(false);
            return;
        }

        console.log("[Submit Handler] Validação passou. Preparando fetch..."); // Log C
        // Define URL e Método baseado na edição ou criação
        const isEditing = !!editingSprintId;
        const url = isEditing ? `${apiSprintsBaseUrl}/${editingSprintId}` : apiSprintsBaseUrl;
        const method = isEditing ? 'PUT' : 'POST';
        console.log(`Enviando ${method} para ${url}`);

        try {
            console.log("[Submit Handler] Dentro do try, antes do fetch."); // Log D
            const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            console.log("[Submit Handler] Fetch concluído, resposta recebida.", response.status); // Log E

            if (!response.ok) {
                let errorMsg = `Erro ${response.status}`; 
                try { errorMsg = (await response.json()).message || errorMsg; } catch(e) {}
                throw new Error(errorMsg);
            }

            const savedSprint = await response.json();
            console.log(`Sprint ${isEditing ? 'atualizada' : 'criada'}:`, savedSprint);
            sprintModal.hide();
            loadSprints(); // Recarrega a lista

        } catch (error) {
            console.error("[Submit Handler] Erro no bloco catch:", error); // Log F
            console.error("Erro ao salvar sprint:", error);
            alert(`Erro ao salvar sprint: ${error.message}`);
        } finally {
            console.log("[Submit Handler] Bloco finally executado."); // Log G
            showModalLoading(false);
        }
    });

    // Listener de CLIQUE no botão Salvar (para depuração)
    const submitButton = sprintForm.querySelector('button[type="submit"]');
    if (submitButton) {
        submitButton.addEventListener('click', function(clickEvent) {
            console.log("[Submit Button Click] Botão Salvar clicado!");
            // Poderíamos até chamar a função de submit daqui manualmente se necessário,
            // mas primeiro vamos ver se o clique é registrado.
        });
    } else {
        console.error("[Sprint Mgmt] Botão Salvar (submit) não encontrado dentro do formulário!");
    }

    // Event Delegation para botões de Ação na tabela
    sprintBoard.addEventListener('click', function(event) { // Agora escuta cliques no quadro
        const target = event.target.closest('button'); // Encontra o botão clicado
        if (!target) return; // Sai se o clique não foi em um botão

        const sprintId = target.dataset.id;
        if (!sprintId) return; // Sai se o botão não tem ID

        if (target.classList.contains('edit-btn')) {
            openEditModal(sprintId);
        }
        else if (target.classList.contains('delete-btn')) {
            const sprintName = target.dataset.name || `Sprint ${sprintId}`; // Pega nome do data attribute
            deleteSprint(sprintId, sprintName);
        }
        // Adicionar else if para 'allocate-btn' futuramente
    });

    // Listener para botão Excluir DENTRO do modal (apenas na edição)
    modalDeleteBtn.addEventListener('click', function() {
        if (editingSprintId) {
            const sprintNameInput = document.getElementById('sprintName');
            const sprintName = sprintNameInput ? sprintNameInput.value : `Sprint ${editingSprintId}`; 
            sprintModal.hide(); // Esconde o modal antes de confirmar exclusão
            deleteSprint(editingSprintId, sprintName);
        }
    });

    // Listener para quando o modal é fechado (resetar)
    sprintModalElement.addEventListener('hidden.bs.modal', function (event) {
        sprintForm.reset();
        sprintModalLabel.textContent = 'Nova Sprint';
        formMethodInput.value = 'POST'; // Reseta método para POST
        editingSprintId = null;
        modalDeleteBtn.style.display = 'none'; // Esconde botão excluir
    });

    // Listener para quando o modal está PRESTES A SER EXIBIDO
    sprintModalElement.addEventListener('show.bs.modal', function (event) {
        // Garante que o modal sempre abra sem o loading ativo
        // A função openEditModal vai ativar o loading se necessário DEPOIS disso.
        console.log("[Sprint Mgmt] Evento show.bs.modal disparado. Garantindo que loading está desligado.");
        showModalLoading(false);
        // O reset do formulário e título já é feito no hidden.bs.modal
        // Mas podemos garantir o título aqui também para o caso de criação
        if (!editingSprintId) {
            sprintModalLabel.textContent = 'Nova Sprint';
            modalDeleteBtn.style.display = 'none';
            formMethodInput.value = 'POST';
        }
    });

    // Carrega Sprints e Backlog em paralelo e inicializa SortableJS DEPOIS que ambos terminarem
    console.log("[Sprint Mgmt] Iniciando carregamento inicial de Sprints e Backlog...");
    Promise.all([
        loadSprints(),      // loadSprints já é async
        loadBacklogTasks()  // loadBacklogTasks já é async
    ]).then(() => {
        console.log("[Sprint Mgmt] Carregamento inicial de Sprints e Backlog CONCLUÍDO.");
        initializeSortable(); // Chama UMA VEZ após tudo estar carregado
        initializePopovers(); // <<< INICIALIZA Popovers após carregamento inicial >>>
    }).catch(error => {
        console.error("[Sprint Mgmt] Erro durante o carregamento inicial (Promise.all):", error);
        // Mostrar uma mensagem de erro geral para o usuário?
        sprintBoard.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais. Recarregue a página.</div>';
        backlogColumnBody.innerHTML = '<div class="alert alert-danger">Erro crítico ao carregar dados iniciais.</div>';
    });

    // <<< INÍCIO: Lógica para Recolher/Expandir Backlog (JS Manipula Estilos) >>>
    const toggleBtn = document.getElementById('toggleBacklogBtn');
    const backlogColumn = document.getElementById('backlogColumn'); // Seleciona a coluna diretamente
    const boardContainer = document.getElementById('sprintBoardContainer'); // Container ainda útil?

    if (toggleBtn && backlogColumn) { // Verifica se botão e COLUNA existem
        // Função para aplicar estilos de recolhimento/expansão
        function applyCollapseStyles(collapse) {
            if (collapse) {
                backlogColumn.style.flexBasis = '0px';
                backlogColumn.style.minWidth = '0px';
                backlogColumn.style.opacity = '0';
                backlogColumn.style.paddingLeft = '0';
                backlogColumn.style.paddingRight = '0';
                backlogColumn.style.borderWidth = '0';
                backlogColumn.style.pointerEvents = 'none';
                toggleBtn.classList.add('collapsed-trigger'); // Adiciona classe ao botão
            } else {
                // Remove estilos inline para voltar aos padrões do CSS
                backlogColumn.style.removeProperty('flex-basis');
                backlogColumn.style.removeProperty('min-width');
                backlogColumn.style.removeProperty('opacity');
                backlogColumn.style.removeProperty('padding-left');
                backlogColumn.style.removeProperty('padding-right');
                backlogColumn.style.removeProperty('border-width');
                backlogColumn.style.removeProperty('pointer-events');
                toggleBtn.classList.remove('collapsed-trigger'); // Remove classe do botão
            }
        }

        // Função para atualizar ícone e título do botão
        function updateButtonState(collapsed) {
            const icon = toggleBtn.querySelector('i');
            if (collapsed) {
                if (icon) icon.className = 'bi bi-chevron-double-right';
                toggleBtn.title = 'Expandir Backlog';
            } else {
                if (icon) icon.className = 'bi bi-chevron-double-left';
                toggleBtn.title = 'Recolher Backlog';
            }
        }

        // Estado inicial (lido do localStorage)
        let isCollapsed = localStorage.getItem('sprintBacklogCollapsed') === 'true';
        applyCollapseStyles(isCollapsed); // Aplica estilos iniciais
        updateButtonState(isCollapsed); // Define botão inicial

        // Listener de clique no botão
        toggleBtn.addEventListener('click', () => {
            isCollapsed = !isCollapsed; // Inverte o estado
            applyCollapseStyles(isCollapsed); // Aplica novos estilos
            updateButtonState(isCollapsed); // Atualiza botão
            localStorage.setItem('sprintBacklogCollapsed', isCollapsed ? 'true' : 'false'); // Salva estado
        });

    } else {
        console.error('[Sprint Mgmt] Botão #toggleBacklogBtn ou Coluna #backlogColumn não encontrados.');
    }
    // <<< FIM: Lógica para Recolher/Expandir Backlog >>>

    // Função para carregar tarefas genéricas
    async function loadGenericTasks() {
        const genericTasksBody = document.querySelector('#genericTasksColumn .side-column-body');
        genericTasksBody.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm" role="status"></div> Carregando tarefas genéricas...</div>';
        
        try {
            const response = await fetch('/sprints/api/generic-tasks');
            if (!response.ok) {
                throw new Error(`Erro ${response.status}: Falha ao buscar tarefas genéricas`);
            }
            const tasks = await response.json();
            
            genericTasksBody.innerHTML = '';
            if (tasks.length === 0) {
                genericTasksBody.innerHTML = '<div class="text-center text-muted p-3">Nenhuma tarefa genérica encontrada.</div>';
                return;
            }
            
            tasks.forEach(task => {
                const taskCard = document.createElement('div');
                taskCard.className = `generic-task ${task.status === 'Concluído' ? 'task-completed' : ''}`;
                taskCard.dataset.taskId = task.id;
                taskCard.draggable = true;
                
                taskCard.innerHTML = `
                    <div class="generic-task-title">${escapeHtml(task.title)}</div>
                    <div class="generic-task-meta">
                        <span class="project-badge">${escapeHtml(task.priority)}</span>
                    </div>
                `;
                
                // Adiciona evento de clique para edição
                taskCard.addEventListener('click', () => openGenericTaskModal(task));
                
                genericTasksBody.appendChild(taskCard);
                
                // Aplica classe de cor ao badge de prioridade
                const badgeElement = taskCard.querySelector('.project-badge');
                if (badgeElement) {
                    const priorityLower = (task.priority || '').toLowerCase();
                    let badgeClass = 'text-bg-primary'; // Default: Média
                    if (priorityLower === 'urgente') badgeClass = 'text-bg-danger';
                    else if (priorityLower === 'alta') badgeClass = 'text-bg-warning';
                    else if (priorityLower === 'baixa') badgeClass = 'text-bg-secondary';
                    badgeElement.classList.add(...badgeClass.split(' '));
                }
            });
        } catch (error) {
            console.error("Erro ao carregar tarefas genéricas:", error);
            genericTasksBody.innerHTML = `<div class="alert alert-danger">Erro ao carregar tarefas genéricas: ${error.message}</div>`;
        }
    }

    // Modal de Tarefa Genérica
    const genericTaskModal = new bootstrap.Modal(document.getElementById('genericTaskModal'));
    const genericTaskForm = document.getElementById('genericTaskForm');
    const genericTaskDeleteBtn = document.getElementById('genericTaskDeleteBtn');
    let editingGenericTaskId = null;

    // Função para abrir o modal de tarefa genérica
    function openGenericTaskModal(task = null) {
        const modalTitle = document.getElementById('genericTaskModalLabel');
        const deleteBtn = document.getElementById('genericTaskDeleteBtn');
        
        genericTaskForm.reset();
        
        if (task) {
            modalTitle.textContent = 'Editar Tarefa Genérica';
            document.getElementById('genericTaskId').value = task.id;
            document.getElementById('genericTaskTitle').value = task.title;
            document.getElementById('genericTaskDescription').value = task.description || '';
            document.getElementById('genericTaskPriority').value = task.priority || 'Média';
            document.getElementById('genericTaskEffort').value = task.estimated_hours || '';
            document.getElementById('genericTaskSpecialist').value = task.specialist_name || '';
            deleteBtn.style.display = 'block';
            editingGenericTaskId = task.id;
        } else {
            modalTitle.textContent = 'Nova Tarefa Genérica';
            deleteBtn.style.display = 'none';
            editingGenericTaskId = null;
        }
        
        genericTaskModal.show();
    }

    // Handler para submissão do formulário de tarefa genérica
    genericTaskForm.addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(genericTaskForm);
        const data = {
            title: formData.get('title'),
            description: formData.get('description'),
            priority: formData.get('priority'),
            estimated_hours: formData.get('estimated_effort') ? parseFloat(formData.get('estimated_effort')) : null,
            specialist_name: formData.get('specialist_name') || null
        };
        
        try {
            const url = editingGenericTaskId 
                ? `/sprints/api/generic-tasks/${editingGenericTaskId}`
                : '/sprints/api/generic-tasks';
            
            const response = await fetch(url, {
                method: editingGenericTaskId ? 'PUT' : 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks();
            
        } catch (error) {
            console.error("Erro ao salvar tarefa genérica:", error);
            alert(`Erro ao salvar tarefa genérica: ${error.message}`);
        }
    });

    // Handler para exclusão de tarefa genérica
    genericTaskDeleteBtn.addEventListener('click', async function() {
        if (!editingGenericTaskId || !confirm('Tem certeza que deseja excluir esta tarefa genérica?')) {
            return;
        }
        
        try {
            const response = await fetch(`/sprints/api/generic-tasks/${editingGenericTaskId}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error(`Erro ${response.status}`);
            }
            
            genericTaskModal.hide();
            loadGenericTasks(); // Recarrega as tarefas genéricas
            loadSprints(); // Recarrega as sprints para atualizar caso a tarefa estivesse em alguma sprint
            
        } catch (error) {
            console.error("Erro ao excluir tarefa genérica:", error);
            alert(`Erro ao excluir tarefa genérica: ${error.message}`);
        }
    });

    // Carrega as tarefas genéricas junto com o resto dos dados
    loadGenericTasks();

    // Adiciona listener para o botão de adicionar tarefa genérica
    const addGenericTaskBtn = document.getElementById('addGenericTaskBtn');
    if (addGenericTaskBtn) {
        addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    }

    // Função para atualizar o popover de horas por especialista de uma sprint
    function updateSpecialistPopover(sprintListElement) {
        const sprintCard = sprintListElement.closest('.sprint-card');
        if (!sprintCard) return;

        // Encontra todas as tarefas na sprint
        const tasks = sprintListElement.querySelectorAll('.backlog-task-card');
        let hoursBySpecialist = {};

        // Calcula horas por especialista
        tasks.forEach(task => {
            const specialist = task.dataset.specialistName;
            if (specialist && specialist.trim()) { // Só considera se tiver especialista
                const hours = parseFloat(task.dataset.estimatedHours) || 0;
                hoursBySpecialist[specialist] = (hoursBySpecialist[specialist] || 0) + hours;
            }
        });

        // Formata o conteúdo do popover
        let popoverContent = Object.entries(hoursBySpecialist)
            .map(([name, hours]) => `<div>${escapeHtml(name)}: <strong>${hours.toFixed(1)}h</strong></div>`)
            .join('');

        // Atualiza o popover
        const popoverButton = sprintCard.querySelector('.specialist-hours-popover');
        if (popoverButton) {
            // Destrói o popover existente
            const popoverInstance = bootstrap.Popover.getInstance(popoverButton);
            if (popoverInstance) {
                popoverInstance.dispose();
            }

            if (Object.keys(hoursBySpecialist).length > 0) {
                // Cria um novo popover com o conteúdo atualizado
                new bootstrap.Popover(popoverButton, {
                    content: popoverContent,
                    html: true,
                    placement: 'bottom',
                    trigger: 'hover focus'
                });
                popoverButton.style.display = 'inline-flex';
            } else {
                popoverButton.style.display = 'none';
            }
        }
    }

    // Função para abrir o modal de detalhes da tarefa
    function openTaskDetailsModal(taskElement) {
        const taskId = taskElement.dataset.taskId;
        const taskType = taskElement.classList.contains('generic-task') ? 'generic' : 'backlog';
        const form = document.getElementById('taskDetailsForm');
        const backlogFields = document.getElementById('backlogSpecificFields');
        const modalTitle = document.getElementById('taskDetailsModalLabel');
        const deleteBtn = document.getElementById('taskDeleteBtn');

        // Reset form e configura campos básicos
        form.reset();
        document.getElementById('taskId').value = taskId;
        document.getElementById('taskType').value = taskType;

        // Configura visibilidade dos campos específicos do backlog
        backlogFields.classList.toggle('d-none', taskType === 'generic');

        // Busca dados da tarefa na API
        fetch(`/backlog/api/tasks/${taskId}`)
            .then(response => {
                if (!response.ok) throw new Error(`Erro ${response.status}`);
                return response.json();
            })
            .then(task => {
                // Preenche os campos do formulário
                document.getElementById('taskTitle').value = task.name || '';
                document.getElementById('taskPriority').value = task.priority || 'Média';
                document.getElementById('taskSpecialist').value = task.specialist_name || '';
                document.getElementById('taskEstimatedHours').value = task.estimated_hours || '';
                document.getElementById('taskDescription').value = task.description || '';
                document.getElementById('taskStatus').value = task.status || 'pendente';

                if (taskType === 'backlog') {
                    document.getElementById('taskProjectId').value = task.project_id || '';
                    document.getElementById('taskColumnIdentifier').value = task.column_identifier || '';
                }

                // Configura título do modal
                modalTitle.textContent = `Detalhes da Tarefa - ${task.name}`;

                // Mostra o modal
                const taskModal = new bootstrap.Modal(document.getElementById('taskDetailsModal'));
                taskModal.show();
            })
            .catch(error => {
                console.error('Erro ao carregar detalhes da tarefa:', error);
                alert('Erro ao carregar detalhes da tarefa. Por favor, tente novamente.');
            });
    }

    // Handler para submissão do formulário de detalhes da tarefa
    document.getElementById('taskDetailsForm').addEventListener('submit', async function(event) {
        event.preventDefault();
        
        const formData = new FormData(this);
        const taskId = formData.get('taskId');
        const taskType = formData.get('taskType');
        
        const data = {
            name: formData.get('title'),
            priority: formData.get('priority'),
            specialist_name: formData.get('specialist_name'),
            estimated_hours: formData.get('estimated_hours') ? parseFloat(formData.get('estimated_hours')) : null,
            description: formData.get('description'),
            status: formData.get('status')
        };

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao salvar tarefa:', error);
            alert('Erro ao salvar alterações. Por favor, tente novamente.');
        }
    });

    // Handler para exclusão de tarefa
    document.getElementById('taskDeleteBtn').addEventListener('click', async function() {
        const taskId = document.getElementById('taskId').value;
        const taskType = document.getElementById('taskType').value;
        
        if (!confirm('Tem certeza que deseja excluir esta tarefa?')) return;

        try {
            const response = await fetch(`/backlog/api/tasks/${taskId}`, {
                method: 'DELETE'
            });

            if (!response.ok) throw new Error(`Erro ${response.status}`);

            // Fecha o modal
            bootstrap.Modal.getInstance(document.getElementById('taskDetailsModal')).hide();
            
            // Recarrega os dados
            loadSprints();
            if (taskType === 'generic') loadGenericTasks();
            else loadBacklogTasks();

        } catch (error) {
            console.error('Erro ao excluir tarefa:', error);
            alert('Erro ao excluir tarefa. Por favor, tente novamente.');
        }
    });

    // Adiciona evento de clique nas tarefas
    document.addEventListener('click', function(event) {
        const taskCard = event.target.closest('.backlog-task-card:not(.generic-task)');
        if (taskCard && !event.target.closest('.task-actions')) {
            openTaskDetailsModal(taskCard);
        }
    });

    // Delegação de eventos para botões de editar e excluir Sprints
    sprintBoard.addEventListener('click', function(event) {
        const editButton = event.target.closest('.edit-btn');
        const deleteButton = event.target.closest('.delete-btn');

        if (editButton) {
            const sprintId = editButton.dataset.id;
            openEditModal(sprintId);
        } else if (deleteButton) {
            const sprintId = deleteButton.dataset.id;
            const sprintName = deleteButton.dataset.name;
            deleteSprint(sprintId, sprintName);
        }
    });

    // Carrega os dados iniciais (Este bloco de chamadas diretas é redundante se Promise.all está sendo usado)
    // loadSprints(); // Redundante
    // loadBacklogTasks(); // Redundante
    // loadGenericTasks(); // Redundante

    // <<< INÍCIO: Event Listeners para Coluna de Tarefas Genéricas >>>
    // A declaração e o listener para addGenericTaskBtn já foram feitos anteriormente no código.
    // Este bloco abaixo é uma duplicação e causa o erro de linter, então será removido.
    // const addGenericTaskBtn = document.getElementById('addGenericTaskBtn'); 
    // if (addGenericTaskBtn) {
    //     addGenericTaskBtn.addEventListener('click', () => openGenericTaskModal());
    // }
    // <<< FIM: Event Listeners para Coluna de Tarefas Genéricas >>>

  }); // Fim DOMContentLoaded
</script>
{# Adiciona SortableJS #}
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
{% endblock %} 